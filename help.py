import sys
from termcolor import colored


def date_time():
    return ('Задачи на дату/время\n'
            '\n'
            'ВРЕМЯ\n'
            '\n'
            'Считывание при вводе:\n'
            'P: h, m, s = [int(i) for i in input().split(\':\')]\n'
            'C: scanf("%d:%d:%d", &h, &m, &s)\n'
            '\n'
            'Перевод из строки в число:\n'
            'P: int(s[0] + s[1])\n'
            'C: (s[0] - \'0\') * 10 + (s[1] - \'0\') # char является числом (кодом символв в ASCII)\n'
            '\n'
            'проще перевести всё в секунды: sec = h * 3600 + m * 60 + s\n'
            '\n'
            'ДАТЫ\n'
            '\n'
            'Считывание, такое же, как во времени\n'
            '\n'
            'Первод в дни:\n'
            'days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] # можно сделать префиксные суммы\n'
            'd = sum(days[mm - 2]) + dd # может возникнуть проблема с месяцем (если введён первый месяц)\n'
            '\n'
            'Перевод из дней в месяц:\n'
            'i = 0\n'
            'while x > 0:\n'
            '    if x <= days[i]:\n'
            '         print(i + 1)\n'
            '         break\n'
            '    else:\n'
            '         x -= days[i]\n'
            '         i += 1\n'
            '\n'
            'Полный код переводов в C/C++ (високосный год не учитывается):)\n'
            '\ufeff#include <iostream>\n'
            'using namespace std;\n'
            'int prefDays[12];\n'
            'int days[12] = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n'
            'int dateToDays(int m, int d) {\n'
            '\tint ans = 0;\n'
            '\tif (m > 1) {\n'
            '\t\tint ans = prefDays[m - 2];\n'
            '\t}\n'
            '\tans += d;\n'
            '\t/*for (int i = 0; i <= m - 2; ++i) {\n'
            '\t\tans += days[i];*/\n'
            '\treturn ans;\n'
            '}\n'
            'pair <int, int> daysToDate(int x) {\n'
            '\tint m = 1, d = 0;\n'
            '\tfor (int i = 0; i < 12; ++i) {\n'
            '\t\tif (x <= days[i]) {\n'
            '\t\t\td = x;\n'
            '\t\t\treturn {m, x};\n'
            '\t\t}\n'
            '\t\telse {\n'
            '\t\t\tm++;\n'
            '\t\t\tx -= days[i];\n'
            '\t\t}\n'
            '\t}\n'
            '}\n'
            'int main() {\n'
            '\tprefDays[0] = days[0];\n'
            '\tfor (int i = 1; i < 12; ++i) {\n'
            '\t\tprefDays[i] = prefDays[i - 1] + days[i];\n'
            '\t}\n'
            '}\n'
            '\n'
            'Проверка на високосность года:\n'
            'if year % 400 == 0 or (year % 4 == 0 and year % 100 != 0):\n'
            '    print(\'Yes\')\n'
            'else:\n'
            '    print(\'No\')\n'
            '\n'
            'Посчитать кол-во високосных лет с одного заданного года до другого можно так:\n'
            '(year1 - year2) // 4 - (year1 - year2) // 100 + (year1 - year2) // 400\n'
            '\n'
            'Определение дня недели по номеру дня в году (n - номер дня, ng - день недели 1 января)\n'
            'dn = (ng - 2 + n) % 7 + 1\n')


def combinations_enumeration():
    return ('Один из способов перевода - битовые маски\n'
            'Следующий код выводит все сочетания из 0 и 1 длиной n\n'
            '\n'
            '\ufeff#include <iostream>\n'
            '\n'
            'using namespace std;\n'
            '\n'
            'int main() {\n'
            '\tint n;\n'
            '\tcin >> n;\n'
            '\tfor (int i = 0; i < (1 << n); ++i) {\n'
            '\t\tfor (int q = 0; q < n; ++q) {\n'
            '\t\t\tif (i & (1 << q)) {\n'
            '\t\t\t\tcout << 1;\n'
            '\t\t\t}\n'
            '\t\t\telse {\n'
            '\t\t\t\tcout << 0;\n'
            '\t\t\t}\n'
            '\t\t}\n'
            '\t\tcout << endl;\n'
            '\t}\n'
            '}\n'
            '\n'
            'Следующий код свыводит все сочетания чисел от start до end длиной n в лексикографическом порядке\n'
            'Python:\n'
            'def gen(left, cur):\n'
            '    if left == 0:\n'
            '        print(*cur)\n'
            '        return\n'
            '    for i in range(start, end + 1):\n'
            '        gen(left - 1, cur + [i])\n'
            '\n'
            '\n'
            'n, start, end = map(int, input().split())\n'
            'gen(n, [])\n'
            '\n'
            'C++:\n'
            '\ufeff#include <iostream>\n'
            '#include <vector>\n'
            '\n'
            'using namespace std;\n'
            '\n'
            'int n, start, end_;\n'
            '\n'
            'void gen(int left, vector<int> cur) {\n'
            '\tif (left == 0) {\n'
            '\t\tfor (int i : cur) {\n'
            '\t\t\tcout << i << \' \';\n'
            '\t\t}\n'
            '\t\tcout << endl;\n'
            '\t\treturn;\n'
            '\t}\n'
            '\tfor (int i = start; i <= end_; ++i) {\n'
            '\t\tcur.push_back(i);\n'
            '\t\tgen(left - 1, cur);\n'
            '\t\tcur.pop_back();\n'
            '\t}\n'
            '}\n'
            '\n'
            'int main() {\n'
            '\tcin >> n >> start >> end_;\n'
            '\tgen(n, vector<int>{});\n'
            '}\n'
            '\n'
            'Следующий код имеет функцию gen, которая делает то же самое, что и предыдущий код (только без повторений чисел)\n'
            'Также код имеет функию n_permutation (аналог встроенной next_permutation), которая выводит следующую последовательность из цифр в лексикографическом порядке\n'
            '\n'
            '\ufeff#include <iostream>\n'
            '#include <vector>\n'
            '#include <algorithm>\n'
            '\n'
            'using namespace std;\n'
            '\n'
            'int n;\n'
            '\n'
            'void gen(int left, vector<int> cur, vector<int> been) {\n'
            '\tif (left == 0) {\n'
            '\t\tfor (int i : cur) {\n'
            '\t\t\tcout << i << \' \';\t\t\t\n'
            '\t\t}\n'
            '\t\tcout << endl;\n'
            '\t\treturn;\n'
            '\t}\n'
            '\tfor (int i = 0; i < n; ++i) {\n'
            '\t\tif (!been[i]) {\n'
            '\t\t\tbeen[i] = 1;\n'
            '\t\t\tcur.push_back(i + 1);\n'
            '\t\t\tgen(left - 1, cur, been);\n'
            '\t\t\tcur.pop_back();\n'
            '\t\t\tbeen[i] = 0;\n'
            '\t\t}\n'
            '\t}\n'
            '}\n'
            '\n'
            'void n_permutation(vector<int>& p) {\n'
            '\tint n = p.size();\n'
            '\tfor (int i = n - 1; i > 0; --i) {\n'
            '\t\tif (p[i] > p[i - 1]) {\n'
            '\t\t\tint pos;\n'
            '\t\t\tfor (int j = n - 1; j >= i; --j) {\n'
            '\t\t\t\tif (p[j] > p[i - 1]) {\n'
            '\t\t\t\t\tpos = j;\n'
            '\t\t\t\t\tbreak;\n'
            '\t\t\t\t}\n'
            '\t\t\t}\n'
            '\t\t\tswap(p[pos], p[i - 1]);\n'
            '\t\t\tsort(p.begin() + i, p.end());\n'
            '\t\t\tbreak;\n'
            '\t\t}\n'
            '\t}\n'
            '}\n'
            '\n'
            'int main() {\n'
            '\tcin >> n;\n'
            '\tgen(n, vector<int>{}, vector<int>(n, 0));\n'
            '\t/*vector<int> a = { 3, 1, 5, 2, 7, 6, 4 };\n'
            '\tn_permutation(a);\n'
            '\tfor (int i : a) {\n'
            '\t\tcout << i << \' \';\n'
            '\t}*/\n'
            '}\n')


def binsearch():
    return ('Бинпоиск\n'
            '\n'
            'Смысл бинпоиска - поиск элемента в отсортированном массиве путём деления массива на две части\n'
            'Поэтому сложность бинпоиска - log2(n)\n'
            '\n'
            'Код бинпоиска:\n'
            'l = 0\n'
            'r = 10 ** 100\n'
            'while r - l > 1:\n'
            '    m = (l + r) // 2\n'
            '    if f(m) >= x:\n'
            '        r = m\n'
            '    else:\n'
            '        l = m\n'
            'print(r)\n'
            '\n'
            'f - какая-то функция, x - заданное число\n'
            '\n'
            'При вещественном бинпоиске (с нецелыми числами, заданная точность) можно заменить while на for\n'
            'for будет выполняться math.ceil(math.log2((r - l) * 10000000000))\n'
            'кол-во нулей в последнем числе - точность ответа\n'
            '\n'
            'Всторенный бинпоиск\n'
            'Python:\n'
            'from bisect import bisect_right, bisect_left\n'
            '\n'
            'a = [1, 2, 4, 5, 6, 6, 7, 9]\n'
            'ind = bisect_left(a, 5)\n'
            'ind1 = bisect_right(a, 6)\n'
            'print(ind, ind1)\n'
            ''
            'C++:\n'
            '\ufeff#include <iostream>\n'
            '#include <algorithm>\n'
            '#include <vector>\n'
            '\n'
            'using namespace std;\n'
            '\n'
            'int main() {\n'
            '\tvector<int> a {1, 2, 4, 5, 6, 6, 7, 9};\n'
            '\tint b[7] = { 2, 4, 4, 6, 8, 8, 9 };\n'
            '\tauto it = lower_bound(a.begin(), a.end(), 5);\n'
            '\tcout << *it << \' \' << it - a.begin() << endl;\n'
            '\tauto it1 = upper_bound(b, b + 7, 6);\n'
            '\tcout << *it1 << \' \' << it1 - b << endl;\n'
            '}\n'
            '\n'
            'bisect_left и lower_bound ищут первый элемент >= заданного\n'
            'bisect_right и upper_bound ищут первый элемент > заданного\n')


def two_pointers():
    return ('Метод двух указателей\n'
            '\n'
            'Смысл метода заключается в закреплении одного элемента отсортированного массива и передвижения второго\n'
            'Стандартный код метода двух указателей:\n'
            'for (int first_point = 0; first_point < len_array; first_point++) {\n'
            '    while (second_point < len_array && <условие>) {\n'
            '        second_point++;\n'
            '    }\n'
            '}\n'
            '\n'
            'Указатели могут относится к разным массивам\n'
            'Указателей может быть больше двух, тогда добавляются циклы while в цикле for (один указателб - один цикл while)\n')


def testing():
    return ('Тестирование\n'
            '\n'
            'В основном, тестирование - это генерация тестов\n'
            'В Python за генерацию отвечает модуль random\n'
            'Основные функции:\n'
            'randint(start, end)      # случайное целое число от start до end включительно\n'
            'choice(l)                # случайный элемент списка l\n'
            'normalvariate(mu, sigma) # нормальное распределение\n'
            'random()                 # случайное число от 0 до 1\n'
            '\n'
            'Некоторые генерации:\n'
            '1. Правильная скобочная последовательность\n'
            'n = int(input())\n'
            'l = 0\n'
            'bal = 0\n'
            's = \'\'\n'
            'for i in range(n):\n'
            '    if not bal:\n'
            '        s += \'(\'\n'
            '        l += 1\n'
            '        bal += 1\n'
            '    elif bal + 1 > n - l - 1:\n'
            '        s += \')\'\n'
            '        l += 1\n'
            '        bal -= 1\n'
            '    else:\n'
            '        par = randint(0, 1)\n'
            '        if not par:\n'
            '            s += \'(\'\n'
            '            l += 1\n'
            '            bal += 1\n'
            '        else:\n'
            '            s += \')\'\n'
            '            l += 1\n'
            '            bal -= 1\n'
            'print(s)\n'
            '\n'
            '2. Массив заданной длины и суммы элементов\n'
            'n = int(input())\n'
            's = int(input())\n'
            'border = []\n'
            'for i in range(n - 1):\n'
            '    border.append(randint(0, s))\n'
            'border.sort()\n'
            'border = [0] + border + [s]\n'
            'a = []\n'
            'for i in range(1, n + 1):\n'
            '    a.append(border[i] - border[i - 1])\n'
            'print(a)\n'
            '\n'
            '3. Массив заданной длины из чисел от 1 до k без повторений\n'
            'n = int(input())\n'
            'k = int(input())\n'
            'if k < 5 * n:\n'
            '    a = list(range(1, k + 1))\n'
            '    shuffle(a)\n'
            '    a = a[:n]\n'
            '    print(a)\n'
            'else:\n'
            '    s = set()\n'
            '    while len(s) < n:\n'
            '        s.add(randint(1, k))\n'
            '    l = list(s)\n'
            '    shuffle(l)\n'
            '    print(l)\n'
            '\n'
            'ТЕСТИРОВНИЕ НЕПРАВИЛЬНОГО РЕШЕНИЯ ПРИ НАЛИЧИИ МЕДЛЕННОГО ПРАВИЛЬНОГО\n'
            'Правильное, но медленное решение - slow.py. Неработающее решение - testme.py\n'
            '\n'
            'Для начала пишем генератор для программ в отдельном файле (например, gen3.py)\n'
            '\n'
            'Теперь нужно написать программу, котрая свяжет всё (генератор, два решения и проверку правильности ответа)\n'
            'Например, run.py\n'
            'Тогда программа run.py будет выглядеть так:\n'
            'import os\n'
            '\n'
            'test = 1\n'
            'while True:\n'
            '    os.system(\'python gen3.py > input\')\n'
            '    os.system(\'python testme.py < input > output\')\n'
            '    os.system(\'python slow.py < input > correct\')\n'
            '    output = [i.strip() for i in open(\'output\').readlines()]\n'
            '    correct = [i.strip() for i in open(\'correct\').readlines()]\n'
            '    if output != correct:\n'
            '        print(\'Error at test\', test)\n'
            '        break\n'
            '    print(\'Test\', test, \'is OK\')\n'
            '    print(\'--------------------\')\n'
            '    test += 1\n'
            '\n'
            '< и > перенаправляют вывод в файл\n'
            'Тест, неправильный и правильный ответ можно будет посмотреть после тестирования в файлах input, output и correct\n')


def hashes():
    return ('Хэши\n'
            '\n'
            'Идеальный хэш - это тот хэш, который удовлетворяет равенствам:\n'
            'x = y => H(x) = H(y)\n'
            'x ≠ y => H(x) ≠ H(y)\n'
            'Но представленный ниже алгоритм - это неидеальный хэш\n'
            '\n'
            'Один из алгоритмов хэширования:\n'
            'Присутствуют два параметра: p и mod\n'
            'p <= 300\n'
            'mod ** 2 должен влезать в long long и желательно быть простым числом\n'
            'популярные mod: 10 ** 9 + 7; 10 ** 9 + 9; 2 * 10 ** 9 + 11\n'
            'но популярные mod лучше не использовать\n'
            'Также лучше в начале программы выбирать параметры из списка, используя random\n'
            '\n'
            'Номер каждого элемента в ASCII умножается на соответствующую степень числа p, затем произведения складываются, и находится остаток от деления на mod\n'
            'Example:\n'
            'H(\'abac\') = (ord(\'a\') * p ** 3 + ord(\'b\') * p ** 2 + ord(\'a\') * p ** 1 + ord(\'c\')) % mod\n'
            '\n'
            'Но, т.к. данный хэш неидеален, можно делать двойной, тройной и т.д. хэш (деать к одной строке несколько хэшей с разными p и mod)\n'
            '\n'
            'Код такого хэширования на C++:\n'
            'long long getHash(const string& s, int p, long long mod) {\n'
            '    long long H = 0;\n'
            '    for (auto& c : s) {\n'
            '        H = (H * p + c) % mod;\n'
            '    }\n'
            '    return H;\n'
            '}\n'
            '\n'
            'Гораздо полезнее хранить хэши префиксов строки. Код на C++:\n'
            'vector <long long> getHash(const string& s, int p, long long mod) {\n'
            '\tvector<long long> ans(s.size());\n'
            '\tans[0] = s[0];\n'
            '\tfor (size_t i = 1; i < s.size(); ++i) {\n'
            '\t\tans[i] = (ans[i - 1] * p + s[i]) % mod;\n'
            '\t}\n'
            '\treturn ans;\n'
            '}\n'
            '\n'
            'Благодаря нахождению хэшей префиксов, можно искать хэши подстрок\n'
            'Код:\n'
            'long long subHash(int l, int r, long long mod) {\n'
            '\tlong long big = H[r];\n'
            '\tlong long small = 0;\n'
            '\tif (l != 0) {\n'
            '\t\tsmall = (H[l - 1] * st[r - l + 1]) % mod;\n'
            '\t}\n'
            '\treturn (big - small + mod) % mod;\n'
            '}\n'
            'st - список степеней p, H - список хэшей префиксов\n'
            '\n'
            'Что можно делать с хэшами:\n'
            '# Можно найти подстроку в строке (найти её хэш и посмотреть все хэши подстрок такой же длины)\n'
            '\n'
            '# Найти циклический сдвиг\n'
            '  Дано две строки. Вторая - циклический сдвиг первой\n'
            '  n - длина строки, k - сдвиг\n'
            '  Можно умножить первую строку на две, тогда она будет выглядеть так:\n'
            '  n - k   k   n - k   k\n'
            '  Вторая строка выглядит так:\n'
            '  k   n - k\n'
            '  Теперь можно найти вхождение второй строки в первую\n'
            '\n'
            '# Проверка подстроки на палиндром\n'
            '  Для этого нужно найти хэш подмтроки и её обратный хэш (хэш перевёрнутой строки)\n'
            '  После этого проверить равенство хэшей\n'
            '\n'
            '# Проверка на период (можно ли разбить на одинаковые блоки длиной k)\n'
            '  Сначала нужно проверить, делится ли длина строки на k\n'
            '  Далбше нужно сравнить хэши строк от второго до последнего блока и от первого до предпоследнего\n'
            '  s[:n - k] и s[k + 1:]\n'
            '\n'
            '# Минимальный период строки\n'
            '  Нужно разложить длину строки на множители и увеличивать значение, пока строка яаляется периодом (делить на всё большее значение)\n'
            '\n'
            '# Сравнение строк\n'
            '  Нужно найти самый большой общий префикс, а потом сравнить символы после него\n'
            '  Длину префикса можно найти бинпоиском\n'
            '\n'
            '# Поиск подпалиндромов\n'
            '  Палиндром может быть нечётной длины (центр - символ) и чётной (центр между символами)\n'
            '  Можно пройти по строке, смотря на символы и промежутки между символами. Таким образом мы перебираем центр палиндрома\n'
            '  От каждого центра мы будем расширять строку, пока эта строка является палиндромом (проверка делается хэшами)\n'
            '\n'
            '  Но поиск палиндромов можно осуществить быстрее, проще и без хэшей с использованием Алгоритма Манакера\n'
            '  (раздел Manacher)\n'
            '\n'
            '# z-функция\n'
            '  z-функция - это поиск максимального числа l, такого, что подстрока, начинающаяся в i и длиной l, равна префиксу длины l\n'
            '  l можно искать бинпоиском, а сравнивать строки - хэшами\n'
            '\n'
            '  Но z-функцию можно написать проще и без хэшей\n'
            '  (раздел z_function)\n')


def z_function():
    return ('Z-функция\n'
            '\n'
            'Z-функция для индекса i ищет максимальное число l, такое, что подстрока, начинающаяся в i и длиной l, равна префиксу длины l\n'
            '\n'
            'Z-функция может быть использована для проверки вхождения подстроки в строку (нужно дописать к меньшей строке символ, которого нет в обоих строках, и большую строку)\n'
            'тогда, посчитав z-функцию от получившейся строки можно будет найти все вхождения первой строки во вторую\n'
            '\n'
            'Z-функция может быть реализована по-разному\n'
            'Основные способы:\n'
            '1. Хэши (описано в hashes)\n'
            '2. Алгоритм, вычисляющий следующие значения, используя уже вычисленные значения\n'
            '\n'
            'Рассмотрим второй алгоритм\n'
            '\n'
            'Следующие значения вычисляются на основе предыдущих\n'
            'Хранятся границы такого z-блока, правая граница которого максимальна\n'
            '(z-блок - подстрока с началом в i и максимальной длиной l (значение z-функции для i))\n'
            '\n'
            'Есть два случая:\n'
            '1. i не лежит в сохранённом блоке (тогда нужно наивно пройти по строке и сравнить)\n'
            '2. i лежит в сохранённом блоке (тогда есть два случая)\n'
            '   2.1 z[i - left] + i > right (тогда нужно наивно пройти по строке от r и сравнить)\n'
            '   2.2. z[i - left] + i <= right (тогда уже известно значение, оно равно z[i - left])\n'
            '\n'
            'Реализация такого алгоритма:\n'
            'C++:\n'
            'vector<int> z_f(string s) {\n'
            '\ts += \'$\';\n'
            '\tint l = 0;\n'
            '\tint r = 0;\n'
            '\tvector <int>z(s.size(), 0);\n'
            '\tfor (int i = 1; i < s.size(); ++i) {\n'
            '\t\tz[i] = max(0, min(z[i - l], r - i));\n'
            '\t\twhile (s[z[i]] == s[i + z[i]]) {\n'
            '\t\t\tz[i]++;\n'
            '\t\t}\n'
            '\t\tif (z[i] + i > r) {\n'
            '\t\t\tl = i;\n'
            '\t\t\tr = z[i] + i;\n'
            '\t\t}\n'
            '\t}\n'
            '\tz.pop_back();\n'
            '\treturn z;\n'
            '}\n'
            '\n'
            'Python:\n'
            'def z_f(s):\n'
            '    s += \'$\'\n'
            '    l, r = 0, 0\n'
            '    z = [0] * len(s)\n'
            '    for i in range(1, len(s)):\n'
            '        z[i] = max(0, min(z[i - l], r - i))\n'
            '        while s[z[i]] == s[i + z[i]]:\n'
            '            z[i] += 1\n'
            '        if i + z[i] > r:\n'
            '            l, r = i, i + z[i]\n'
            '    return z[:-1]\n')


def Manacher():
    return ('Алгоритм Манакера\n'
            '\n'
            'Алгоритм Манакера позволяет находить для каждого элемента строки максимальную длину подстроки-палиндрома с центром в этом элементе\n'
            '\n'
            'Алгоритм возвращает два массива половин длин палиндромов (для чётных и нечётных палиндромов)\n'
            'Благодаря этому можно легко найти общее кол-во палиндромов в строке, сложив все значения двух массивов\n'
            '\n'
            'Реализация Алгоритма Манакера схожа с реализацией оптимального алгоритма нахождения z-функции\n'
            'Следующие значения вычисляются на основе предыдущих и хранятся границы палиндрома, правая граница которого максимальна\n'
            '\n'
            'Есть 2 случая:\n'
            '1. Следующий элемент лежит в сохранённом палиндроме (тогда находится зеркальное значение и выполняется наивный алгоритм)\n'
            '2. Слудующий элемент не лежит в сохранённом палиндроме (наивный алгоритм)\n'
            '\n'
            'Реализация на C++:\n'
            'vector<int> one(string s) {\n'
            '\tint n = s.length();\n'
            '\tvector<int> d1(n);\n'
            '\tfor (int i = 0, l = 0, r = -1; i < n; i++) {\n'
            '\t\tint k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\n'
            '\t\twhile (0 <= i - k && i + k < n && s[i - k] == s[i + k]) {\n'
            '\t\t\tk++;\n'
            '\t\t}\n'
            '\t\td1[i] = k--;\n'
            '\t\tif (i + k > r) {\n'
            '\t\t\tl = i - k;\n'
            '\t\t\tr = i + k;\n'
            '\t\t}\n'
            '\t}\n'
            '\treturn d1;\n'
            '}\n'
            '\n'
            'vector<int> two(string s) {\n'
            '\tint n = s.length();\n'
            '\tvector<int> d2(n);\n'
            '\tfor (int i = 0, l = 0, r = -1; i < n; i++) {\n'
            '\t\tint k = (i > r) ? 0 : min(d2[l + r - i + 1], r - i + 1);\n'
            '\t\twhile (0 <= i - k - 1 && i + k < n && s[i - k - 1] == s[i + k]) {\n'
            '\t\t\tk++;\n'
            '\t\t}\n'
            '\t\td2[i] = k--;\n'
            '\t\tif (i + k > r) {\n'
            '\t\t\tl = i - k - 1;\n'
            '\t\t\tr = i + k;\n'
            '\t\t}\n'
            '\t}\n'
            '\treturn d2;\n'
            '}\n'
            '\n')


def no(a):
    global list_com
    list_com = ['all', 'date_time', 'combinations_enumeration', 'binsearch', 'two_pointers', 'testing', 'hashes', 'z_function',
                'Manacher']
    if a not in list_com:
        return False
    else:
        return True


def all():
    for i in range(len(list_com)):
        if i != len(list_com) - 1:
            print(list_com[i], end='\n')
        else:
            print(list_com[i])
    return ''


a = '1'
while a != 'exit':
    a = input(colored('>>>', 'green'))
    if a == 'exit':
        sys.exit('Завершение работы...')
    else:
        if not no(a):
            print('Такого раздела не существует!')
        else:
            a += '()'
            print(eval(a))