# -*-coding: utf-8-*-
import sys


def date_time():
    return ('Задачи на дату/время\n'
            '\n'
            'ВРЕМЯ\n'
            '\n'
            'Считывание при вводе:\n'
            'P: h, m, s = [int(i) for i in input().split(\':\')]\n'
            'C: scanf("%d:%d:%d", &h, &m, &s)\n'
            '\n'
            'Проще перевести всё в секунды: sec = h * 3600 + m * 60 + s\n'
            '\n'
            'ДАТЫ\n'
            '\n'
            'Считывание, такое же, как во времени\n'
            '\n'
            'Перевод в дни:\n'
            'days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] # можно сделать префиксные суммы\n'
            'd = sum(days[mm - 2]) + dd # может возникнуть проблема с месяцем (если введён первый месяц)\n'
            '\n'
            'Перевод из дней в месяц:\n'
            'i = 0\n'
            'while x > 0:\n'
            '    if x <= days[i]:\n'
            '         print(i + 1)\n'
            '         break\n'
            '    else:\n'
            '         x -= days[i]\n'
            '         i += 1\n'
            '\n'
            'Полный код переводов в C/C++ (високосный год не учитывается):\n'
            '#include <iostream>\n'
            'using namespace std;\n'
            'int prefDays[12];\n'
            'int days[12] = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n'
            'int dateToDays(int m, int d) {\n'
            '\tint ans = 0;\n'
            '\tif (m > 1) {\n'
            '\t\tint ans = prefDays[m - 2];\n'
            '\t}\n'
            '\tans += d;\n'
            '\t/*for (int i = 0; i <= m - 2; ++i) {\n'
            '\t\tans += days[i];*/\n'
            '\treturn ans;\n'
            '}\n'
            'pair <int, int> daysToDate(int x) {\n'
            '\tint m = 1, d = 0;\n'
            '\tfor (int i = 0; i < 12; ++i) {\n'
            '\t\tif (x <= days[i]) {\n'
            '\t\t\td = x;\n'
            '\t\t\treturn {m, x};\n'
            '\t\t}\n'
            '\t\telse {\n'
            '\t\t\tm++;\n'
            '\t\t\tx -= days[i];\n'
            '\t\t}\n'
            '\t}\n'
            '}\n'
            'int main() {\n'
            '\tprefDays[0] = days[0];\n'
            '\tfor (int i = 1; i < 12; ++i) {\n'
            '\t\tprefDays[i] = prefDays[i - 1] + days[i];\n'
            '\t}\n'
            '}\n'
            '\n'
            'Проверка на високосность года:\n'
            'if year % 400 == 0 or (year % 4 == 0 and year % 100 != 0):\n'
            '    print(\'Yes\')\n'
            'else:\n'
            '    print(\'No\')\n'
            '\n'
            'Посчитать кол-во високосных лет с одного заданного года до другого можно так:\n'
            '(year1 - year2) // 4 - (year1 - year2) // 100 + (year1 - year2) // 400\n'
            '\n'
            'Определение дня недели по номеру дня в году (n - номер дня, ng - день недели 1 января)\n'
            'dn = (ng - 2 + n) % 7 + 1\n')

def binsearch():
    return ('Бинпоиск\n'
            '\n'
            'Смысл бинпоиска - поиск элемента в отсортированном массиве путём деления массива на две части\n'
            'Поэтому сложность бинпоиска - log2(n)\n'
            '\n'
            'Код бинпоиска:\n'
            'l = 0\n'
            'r = 10 ** 100\n'
            'while r - l > 1:\n'
            '    m = (l + r) // 2\n'
            '    if f(m) >= x:\n'
            '        r = m\n'
            '    else:\n'
            '        l = m\n'
            'print(r)\n'
            '\n'
            'f - какая-то функция, x - заданное число\n'
            '\n'
            'При вещественном бинпоиске (с нецелыми числами, заданная точность) можно заменить while на for\n'
            'for будет выполняться math.ceil(math.log2((r - l) * 10000000000))\n'
            'кол-во нулей в последнем числе - точность ответа\n'
            '\n'
            'Встроенный бинпоиск\n'
            'Python:\n'
            'from bisect import bisect_right, bisect_left\n'
            '\n'
            'a = [1, 2, 4, 5, 6, 6, 7, 9]\n'
            'ind = bisect_left(a, 5)\n'
            'ind1 = bisect_right(a, 6)\n'
            'print(ind, ind1)\n'
            ''
            'C++:\n'
            '#include <iostream>\n'
            '#include <algorithm>\n'
            '#include <vector>\n'
            '\n'
            'using namespace std;\n'
            '\n'
            'int main() {\n'
            '\tvector<int> a {1, 2, 4, 5, 6, 6, 7, 9};\n'
            '\tint b[7] = { 2, 4, 4, 6, 8, 8, 9 };\n'
            '\tauto it = lower_bound(a.begin(), a.end(), 5);\n'
            '\tcout << *it << \' \' << it - a.begin() << endl;\n'
            '\tauto it1 = upper_bound(b, b + 7, 6);\n'
            '\tcout << *it1 << \' \' << it1 - b << endl;\n'
            '}\n'
            '\n'
            'bisect_left и lower_bound ищут первый элемент >= заданного\n'
            'bisect_right и upper_bound ищут первый элемент > заданного\n'
            '\n'
            'Бинпоиск по ответу\n'
            'Бинпоиск может быть по ответу\n'
            'Мы можем применить его, когда функция существования ответа монотонна\n'
            'Т.е. сначала все ответы не подходят, а потом начинают подходить или наоборот\n'
            'Возьмём очень маленький ответ. Если он подходит, то будем делать бинпоиск на полуинтервале [l, r), а r будет тем значением, которе не подходит\n'
            'Иначе бинпоиск на полуинтервале (l, r], l - значение, которое не подходит\n'
            'Если m подходит, то сдвигаем ту границу, которая включена в полуинтервал\n')


def two_pointers():
    return ('Метод двух указателей\n'
            '\n'
            'ВВЕДЕНИЕ\n'
            '\n'
            'Метод двух указателей - метод, позволяющий решать задачи на массивах за линейное время. Указатели - это позиции в массиве/нескольких массивах.\n'
            'Указатели всегда двигаются только вперёд, поэтому каждый из них может пройти значения 0 <= i <= n - 1 только один раз, что и даёт линейное время.\n'
            '\n'
            'Код для понимания (указатели на двух массивах):\n'
            'int i = 0;\n'
            'int j = 0;\n'
            'while (i < n && j < m) {\n'
            '    if (условие) {\n'
            '        i++;\n'
            '        // какой-то код\n'
            '    }\n'
            '    else {\n'
            '        j++;\n'
            '        // какой-то код\n'
            '    }\n'
            '    // какой-то код\n'
            '}\n'
            '\n'
            'Но проще использовать цикл for для одного из указателей (описано ниже). Также дальше будут рассмотрены несколько задач с применением метода двух указателей.\n'
            '\n'
            'СЛИЯНИЕ МАССИВОВ\n'
            '\n'
            'Для слияния двух отсортированных массивов будем поддерживать указатель на каждом массиве. Каждый раз будем сравнивать элементы на позициях указателей.\n'
            'Если элемент первого массива меньше, то добавляем его в новый массив и сдвигаем указатель.\n'
            'Иначе добавляем в новый массив элемент из второго массива и сдвигаем второй указатель.\n'
            '\n'
            'Такой алгоритм будет продолжаться, пока один из массивов не закончится.\n'
            'Если один из массивов закончился, то нужно просто добавить все оставшиеся элементы из второго массива.\n'
            '\n'
            'ЧИСЛО МЕНЬШИХ\n'
            '\n'
            'Есть массивы A и B. Для каждого B_j хотим узнать кол-во A_i, таких что A_i < B_j. Для начала отсортируем массивы.\n'
            'Теперь сделаем такое же слияние, только не будет строить новый массив (будет только менять указатели).\n'
            'Если при сравнении элемент из первого массива оказался меньше, то просто увеличим первый указатель.\n'
            'Иначе получаем ответ для позиции указателя второго массива (он равен значению первого указателя). После этого увеличиваем второй указатель.\n'
            '\n'
            'Можно не писать один while с несколькими условиями, а сделать for для первого указателя и while внутри для второго.\n'
            'Мы двигаем первый указатель и двигаем второй указатель, пока выполняется условие.\n'
            '\n'
            'int i = 0;\n'
            'for (int j = 0; j < n; j++) {\n'
            '    while (i < m && a[i] < b[j]) {\n'
            '        i++;\n'
            '    }\n'
            '    res[j] = i;\n'
            '}\n'
            '\n'
            '\n'
            'ОТРЕЗОК С НУЖНОЙ СУММОЙ\n'
            '\n'
            'Есть массив A и число S. Нужно найти максимальный по длине подмассив, такой что сумма элементов на нём не больше S и его длина максимальна.\n'
            '\n'
            'Сделаем два указателя на одном массиве.\n'
            'Первый указатель L будет отвечать за левую границу текущего подмассива, а второй указатель R - за правую границу подмассива.\n'
            '\n'
            'Сдвинем R вправо. Могло получиться два случая:\n'
            '1) Сумма на текущем подмассиве осталась не больше S. Тогда ничего больше делать не надо.\n'
            '2) Сумма стала больше S. Теперь нужно двигать указатель L вправо, пока сумма снова не станет не больше S.\n'
            '\n'
            'int L = 0;\n'
            'int x = 0; // сумма на текущем подмассиве\n'
            'for (int R = 0; R < n; R++) {\n'
            '    x += A[R];\n'
            '    while (x > S) {\n'
            '        x -= A[L];\n'
            '        L++;\n'
            '    }\n'
            '    res = max(res, R - L + 1);\n'
            '}\n'
            '\n'
            'Второй вариант этой задачи - найти подмассив минимальной длины, сумма элементов которого не меньше S.\n'
            '\n'
            'Решение очень похоже, только нужно изменить условие и добавить проверку, что для границы R существует ответ.\n'
            '\n'
            'int L = 0;\n'
            'int x = 0; // сумма на текущем подмассиве\n'
            'for (int R = 0; R < n; R++) {\n'
            '    x += A[R];\n'
            '    while (x - A[L] >= S) {\n'
            '        x -= A[L];\n'
            '        L++;\n'
            '    }\n'
            '    if (x >= S) {\n'
            '        res = min(res, R - L + 1);\n'
            '    }\n'
            '}\n'
            '\n'
            'Третий вариант задачи - нужно найти кол-во подмассивов, таких что сумма на каждом их них не больше S.\n'
            '\n'
            'Эта задача решается так же, как первый вариант, только мы теперь будем обновлять ответ не максимальной длиной, а суммой всех длин таких подмассивов.\n'
            'Почему так? Если мы нашли подмассив с суммой не больше S, то и все суффиксы этого подмассива тоже имеют сумму не больше S, а кол-во суффиксов равно длине подмассива.\n'
            '\n'
            'int L = 0;\n'
            'int x = 0; // сумма на текущем подмассиве\n'
            'for (int R = 0; R < n; R++) {\n'
            '    x += A[R];\n'
            '    while (x > S) {\n'
            '        x -= A[L];\n'
            '        L++;\n'
            '    }\n'
            '    res += R - L + 1;\n'
            '}\n'
            '\n'
            'УНИВЕРСАЛЬНОЕ РЕШЕНИЕ ДЛЯ ОТРЕЗКОВ\n'
            '\n'
            'Задачи с суммой - это лишь частный случай задач на отрезки.\n'
            'Классическая задача звучит так: нужно найти (максимальный по длине отрезок/минимальный по длине) хороший отрезок или кол-во хороших отрезков.\n'
            '\n'
            'Такую задачу можно решить методом двух указателей, если выполняются условия:\n'
            '1) Любой вложенный в хороший отрезок также является хорошим (тогда можно применить алгоритм, как в первой задаче).\n'
            'Либо любой отрезок, содержащий хороший отрезок, тоже должен быть хорошим (тогда можно применять алгоритм из второй задачи)\n'
            '2) Можно как-то пересчитывать функцию для отрезка при движении указателей\n'
            '\n'
            'Если условия выполняются, то задачу можно решить двумя указателями. Для этого нужны реализации функций add, remove и good.\n'
            '\n'
            'add() добавляет элемент в конец текущего отрезка и пересчитывает функцию.\n'
            '\n'
            'remove() удаляет элемент из начала текущего отрезка и пересчитывает функцию.\n'
            '\n'
            'good() проверяет, является ли текущий отрезок хорошим.\n'
            '\n'
            'Тогда код будет выглядеть так (для решения первой задачи):\n'
            '\n'
            'int L = 0;\n'
            'for (int R = 0; R < n; R++) {\n'
            '    add(A[R]);\n'
            '    while (!good()) {\n'
            '        remove(A[L]);\n'
            '        L++;\n'
            '    }\n'
            '    // пересчёт ответа\n'
            '}\n'
            '\n'
            'ОТРЕЗОК С НЕБОЛЬШИМ МНОЖЕСТВОМ\n'
            '\n'
            'Есть массив A и число K. Хотим найти наибольший по длине подмассив, на котором не более K различных чисел.\n'
            '\n'
            'Для решения заведём массив (или map, если числа большие) cnt, где cnt_i - сколько чисел равных i на текущем отрезке.\n'
            'Также будем хранить переменную num, которая будет хранить, сколько различных чисел на отрезке.\n'
            '\n'
            'Функция good пишется просто:\n'
            'bool good() {\n'
            '    return num <= k;\n'
            '}\n'
            '\n'
            'Когда мы добавляем новый элемент x в отрезок, то мы должны увеличить cnt для этого элемента.\n'
            'Если cnt_x был до этого равен 0, то кол-во различных чисел увеличилось, поэтому нужно увеличить num.\n'
            'void add(int x) {\n'
            '    if (cnt[x] == 0) {\n'
            '        num++;\n'
            '    }\n'
            '    cnt[x]++;\n'
            '}\n'
            '\n'
            'То же самое с remove\n'
            'void remove(int x) {\n'
            '    cnt[x]--;\n'
            '    if (cnt[x] == 0) {\n'
            '        num--;\n'
            '    }\n'
            '}\n'
            '\n'
            'ОТРЕЗОК С НЕБОЛЬШИМ РАЗБРОСОМ\n'
            '\n'
            'Хотим найти максимальный по длине подмассив, на котором X_max - X_min <= K.\n'
            '\n'
            'Для решения этой задачи понадобится очередь на двух стеках, чтобы корректно пересчитывать значения минимума и максимума при удалении и добавлении элементов в текущий отрезок.\n'
            '\n'
            'У нас будет два стека s_1 и s_2, которые будут ориентированы в разные стороны.\n'
            'Может получиться, что мы удалили весь стек s_1, тогда мы можем переложить все элементы из s_2 в s_1.\n'
            '\n'
            'Нам нужно поддерживать минимум и максимум на двух стеках. Для этого для каждого стека понадобятся ещё два стека: стек минимумов и стека максимумов.\n'
            'Например, стек s_1 = [3, 5, 2, 6], тогда стек минимумов такой: s_1min = [3, 3, 2, 2], стек максимумов такой: s_1max = [3, 5, 5, 6].\n'
            '\n'
            'С таким стеком легко можно делать требуемые операции.\n'
            'Мы можем узнать текущий максимум и минимум, посмотрев на верхние значения стека максимумов и стека минимумов.\n'
            'Можем добавить число x, добавив в основной стек само число, в стек минимумов min(s_min.top(), x), в стек максимумов max(s_max.top(), x).\n'
            'Можем удалить число, просто удалив верхнее значение во всех трёх стеках.\n'
            '\n'
            'Полное решение этой задачи:\n'
            '#include <bits/stdc++.h>\n'
            'using namespace std;\n'
            '\n'
            '#define ll long long\n'
            '#define el \'\\n\'\n'
            'template <class T> istream& operator >>(istream& in, vector<T>& arr) {for (T& i: arr) in >> i; return in;}\n'
            '\n'
            'struct Stack {\n'
            '\n'
            '    vector<ll> s, smin, smax;\n'
            '\n'
            '    void push(ll x) {\n'
            '        s.push_back(x);\n'
            '        if (smin.empty()) {\n'
            '            smin.push_back(x);\n'
            '        }\n'
            '        else {\n'
            '            smin.push_back(::min(x, smin.back()));\n'
            '        }\n'
            '\n'
            '        if (smax.empty()) {\n'
            '            smax.push_back(x);\n'
            '        }\n'
            '        else {\n'
            '            smax.push_back(::max(x, smax.back()));\n'
            '        }\n'
            '    }\n'
            '\n'
            '    ll pop() {\n'
            '        ll res = s.back();\n'
            '        s.pop_back();\n'
            '        smin.pop_back();\n'
            '        smax.pop_back();\n'
            '        return res;\n'
            '    }\n'
            '\n'
            '    bool empty() {\n'
            '        return s.empty();\n'
            '    }\n'
            '\n'
            '    ll min() {\n'
            '        if (smin.empty()) {\n'
            '            return LONG_LONG_MAX;\n'
            '        }\n'
            '        return smin.back();\n'
            '    }\n'
            '\n'
            '    ll max() {\n'
            '        if (smax.empty()) {\n'
            '            return LONG_LONG_MIN;\n'
            '        }\n'
            '        return smax.back();\n'
            '    }\n'
            '};\n'
            '\n'
            'Stack s1, s2;\n'
            'll K;\n'
            '\n'
            'void add(ll x) {\n'
            '    s2.push(x);\n'
            '}\n'
            '\n'
            'void remove() {\n'
            '    if (s1.empty()) {\n'
            '        while (!s2.empty()) {\n'
            '            s1.push(s2.pop());\n'
            '        }\n'
            '    }\n'
            '    s1.pop();\n'
            '}\n'
            '\n'
            'bool good() {\n'
            '    ll Max = max(s1.max(), s2.max());\n'
            '    ll Min = min(s1.min(), s2.min());\n'
            '    return Max - Min <= K;\n'
            '}\n'
            '\n'
            'void solve() {\n'
            '    int n;\n'
            '    cin >> n >> K;\n'
            '    vector<ll> a(n);\n'
            '    cin >> a;\n'
            '\n'
            '    int L = 0;\n'
            '    ll res = 0;\n'
            '    for (int R = 0; R < n; R++) {\n'
            '        add(a[R]);\n'
            '        while (!good()) {\n'
            '            remove();\n'
            '            L++;\n'
            '        }\n'
            '        res += R - L + 1;\n'
            '    }\n'
            '    cout << res << el;\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    solve();\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Указателей может быть больше двух, тогда добавляются циклы while в цикле for (один указатель - один цикл while)\n')


def testing():
    return ('Тестирование\n'
            '\n'
            'В основном, тестирование - это генерация тестов\n'
            'В Python за генерацию отвечает модуль random\n'
            'Основные функции:\n'
            'randint(start, end)      # случайное целое число от start до end включительно\n'
            'choice(l)                # случайный элемент списка l\n'
            'normalvariate(mu, sigma) # нормальное распределение\n'
            'random()                 # случайное число от 0 до 1\n'
            '\n'
            'Некоторые генерации:\n'
            '1. Правильная скобочная последовательность\n'
            'n = int(input())\n'
            'l = 0\n'
            'bal = 0\n'
            's = \'\'\n'
            'for i in range(n):\n'
            '    if not bal:\n'
            '        s += \'(\'\n'
            '        l += 1\n'
            '        bal += 1\n'
            '    elif bal + 1 > n - l - 1:\n'
            '        s += \')\'\n'
            '        l += 1\n'
            '        bal -= 1\n'
            '    else:\n'
            '        par = randint(0, 1)\n'
            '        if not par:\n'
            '            s += \'(\'\n'
            '            l += 1\n'
            '            bal += 1\n'
            '        else:\n'
            '            s += \')\'\n'
            '            l += 1\n'
            '            bal -= 1\n'
            'print(s)\n'
            '\n'
            '2. Массив заданной длины и суммы элементов\n'
            'n = int(input())\n'
            's = int(input())\n'
            'border = []\n'
            'for i in range(n - 1):\n'
            '    border.append(randint(0, s))\n'
            'border.sort()\n'
            'border = [0] + border + [s]\n'
            'a = []\n'
            'for i in range(1, n + 1):\n'
            '    a.append(border[i] - border[i - 1])\n'
            'print(a)\n'
            '\n'
            '3. Массив заданной длины из чисел от 1 до k без повторений\n'
            'n = int(input())\n'
            'k = int(input())\n'
            'if k < 5 * n:\n'
            '    a = list(range(1, k + 1))\n'
            '    shuffle(a)\n'
            '    a = a[:n]\n'
            '    print(a)\n'
            'else:\n'
            '    s = set()\n'
            '    while len(s) < n:\n'
            '        s.add(randint(1, k))\n'
            '    l = list(s)\n'
            '    shuffle(l)\n'
            '    print(l)\n'
            '\n'
            'ТЕСТИРОВНИЕ НЕПРАВИЛЬНОГО РЕШЕНИЯ ПРИ НАЛИЧИИ МЕДЛЕННОГО ПРАВИЛЬНОГО\n'
            'Правильное, но медленное решение - slow.py. Неработающее решение - testme.py\n'
            '\n'
            'Для начала пишем генератор для программ в отдельном файле (например, gen3.py)\n'
            '\n'
            'Теперь нужно написать программу, которая свяжет всё (генератор, два решения и проверку правильности ответа)\n'
            'Например, run.py\n'
            'Тогда программа run.py будет выглядеть так:\n'
            'import os\n'
            '\n'
            'test = 1\n'
            'while True:\n'
            '    os.system(\'python gen3.py > input\')\n'
            '    os.system(\'python testme.py < input > output\')\n'
            '    os.system(\'python slow.py < input > correct\')\n'
            '    output = [i.strip() for i in open(\'output\').readlines()]\n'
            '    correct = [i.strip() for i in open(\'correct\').readlines()]\n'
            '    if output != correct:\n'
            '        print(\'Error at test\', test)\n'
            '        break\n'
            '    print(\'Test\', test, \'is OK\')\n'
            '    print(\'--------------------\')\n'
            '    test += 1\n'
            '\n'
            '< и > перенаправляют вывод в файл\n'
            'Тест, неправильный и правильный ответ можно будет посмотреть после тестирования в файлах input, output и correct\n')


def hashes():
    return ('Хэши\n'
            '\n'
            'Идеальный хеш - это тот хеш, который удовлетворяет равенствам:\n'
            'x = y => H(x) = H(y)\n'
            'x ≠ y => H(x) ≠ H(y)\n'
            'Но представленный ниже алгоритм - это неидеальный хеш\n'
            '\n'
            'Один из алгоритмов хеширования:\n'
            'Присутствуют два параметра: p и mod\n'
            'p <= 300\n'
            'mod ** 2 должен влезать в long long и желательно быть простым числом\n'
            'популярные mod: 10 ** 9 + 7; 10 ** 9 + 9; 2 * 10 ** 9 + 11\n'
            'но популярные mod лучше не использовать\n'
            'Также лучше в начале программы выбирать параметры из списка, используя random\n'
            '\n'
            'Номер каждого элемента в ASCII умножается на соответствующую степень числа p, затем произведения складываются, и находится остаток от деления на mod\n'
            'Example:\n'
            'H(\'abac\') = (ord(\'a\') * p ** 3 + ord(\'b\') * p ** 2 + ord(\'a\') * p ** 1 + ord(\'c\')) % mod\n'
            '\n'
            'Но, т.к. данный хеш неидеален, можно делать двойной, тройной и т.д. хеш (делать к одной строке несколько хешей с разными p и mod)\n'
            '\n'
            'Код такого хеширования на C++:\n'
            'long long getHash(const string& s, int p, long long mod) {\n'
            '    long long H = 0;\n'
            '    for (auto& c : s) {\n'
            '        H = (H * p + c) % mod;\n'
            '    }\n'
            '    return H;\n'
            '}\n'
            '\n'
            'Гораздо полезнее хранить хеши префиксов строки. Код на C++:\n'
            'vector <long long> getHash(const string& s, int p, long long mod) {\n'
            '\tvector<long long> ans(s.size());\n'
            '\tans[0] = s[0];\n'
            '\tfor (size_t i = 1; i < s.size(); ++i) {\n'
            '\t\tans[i] = (ans[i - 1] * p + s[i]) % mod;\n'
            '\t}\n'
            '\treturn ans;\n'
            '}\n'
            '\n'
            'Благодаря нахождению хешей префиксов, можно искать хеши подстрок\n'
            'Код:\n'
            'long long subHash(int l, int r, long long mod) {\n'
            '\tlong long big = H[r];\n'
            '\tlong long small = 0;\n'
            '\tif (l != 0) {\n'
            '\t\tsmall = (H[l - 1] * st[r - l + 1]) % mod;\n'
            '\t}\n'
            '\treturn (big - small + mod) % mod;\n'
            '}\n'
            'st - список степеней p, H - список хешей префиксов\n'
            '\n'
            'Про двойное хеширование:\n'
            'Двойной хеш - это пара двух значений хеша с разными p и mod (список пар)\n'
            'Все действия производятся не с числами, а с парами\n'
            'Пример двойного хеширования:\n'
            'const ll p1 = 179, Mod1 = 556556107;\n'
            'const ll p2 = 139, Mod2 = 2e9 + 11;\n'
            'vector<ll> powers1;\n'
            'vector<ll> powers2;\n'
            '\n'
            'vector<pair<ll, ll>> getHash(const string& s) {\n'
            '    vector<pair<ll, ll>> h(s.size());\n'
            '    h[0].first = s[0];\n'
            '    h[0].second = s[0];\n'
            '    for (int i = 1; i < s.size(); i++) {\n'
            '        h[i].first = (h[i - 1].first * p1 + s[i]) % Mod1;\n'
            '        h[i].second = (h[i - 1].second * p2 + s[i]) % Mod2;\n'
            '    }\n'
            '    return h;\n'
            '}\n'
            '\n'
            'pair<ll, ll> subHash(int l, int r, const vector<pair<ll, ll>>& h) {\n'
            '    pair<ll, ll> big = h[r];\n'
            '    pair<ll, ll> small = {0, 0};\n'
            '    if (l > 0) {\n'
            '        small.first = (h[l - 1].first * powers1[r - l + 1]) % Mod1;\n'
            '        small.second = (h[l - 1].second * powers2[r -l + 1]) % Mod2;\n'
            '    }\n'
            '    pair<ll, ll> res;\n'
            '    res.first = (big.first - small.first + Mod1) % Mod1;\n'
            '    res.second = (big.second - small.second + Mod2) % Mod2;\n'
            '    return res;\n'
            '}\n'
            '\n'
            'Также хеширование обобщается на бОльшие размерности\n'
            'Например, можно считать хеши подпрямоугольников\n'
            'Для этого нужен свой p для каждого измерения\n'
            'При переходе от одного столбца к другому умножаем на один p, при переходе по строкам - на другой\n'
            '\n'
            'Код:\n'
            'p_n = 179\n'
            'p_m = 227\n'
            'mod = int(1e9 + 7)\n'
            '\n'
            'def get_hash(s):\n'
            '    n = len(s)\n'
            '    m = len(s[0])\n'
            '    h = [[0] * m for i in range(n)]\n'
            '    h[0][0] = ord(s[0][0])\n'
            '    for i in range(1, n):\n'
            '        h[i][0] = (h[i - 1][0] * p_n + ord(s[i][0])) % mod\n'
            '    for j in range(1, m):\n'
            '        h[0][j] = (h[0][j - 1] * p_m + ord(s[0][j])) % mod\n'
            '    for i in range(1, n):\n'
            '        for j in range(1, m):\n'
            '            h[i][j] = ((h[i - 1][j] * p_n) % mod + (h[i][j - 1] * p_m) % mod + ord(s[i][j]) - (p_n * p_m * h[i - 1][j - 1]) % mod + mod) % mod\n'
            '    return h\n'
            '\n'
            'def sub_hash(h, x1, y1, x2, y2): # (x1, y1) - левый верхний, (x2, y2) - правый нижний\n'
            '    res = h[x2][y2]\n'
            '    if x1 > 0:\n'
            '        res -= (h[x1 - 1][y2] * pows_n[x2 - x1 + 1]) % mod\n'
            '    if y1 > 0:\n'
            '        res -= (h[x2][y1 - 1] * pows_m[y2 - y1 + 1]) % mod\n'
            '    if x1 > 0 and y1 > 0:\n'
            '        res += (h[x1 - 1][y1 - 1] * pows_n[x2 - x1 + 1] * pows_m[y2 - y1 + 1]) % mod\n'
            '    return (res + 2 * mod) % mod\n'
            '\n'
            'n, m = [int(i) for i in input().split()]\n'
            's = [\'\'] * n\n'
            'for i in range(n):\n'
            '    s[i] = input()\n'
            'pows_n = [0] * (n + 1)\n'
            'pows_m = [0] * (m + 1)\n'
            'pows_n[0] = 1\n'
            'pows_m[0] = 1\n'
            'for i in range(1, n):\n'
            '    pows_n[i] = (pows_n[i - 1] * p_n) % mod\n'
            'for i in range(1, m):\n'
            '    pows_m[i] = (pows_m[i - 1] * p_m) % mod\n'
            'h = get_hash(s)\n'
            '\n'
            'Что можно делать с хешами:\n'
            '# Можно найти подстроку в строке (найти её хеш и посмотреть все хеши подстрок такой же длины)\n'
            '\n'
            '# Найти циклический сдвиг\n'
            '  Дано две строки. Вторая - циклический сдвиг первой\n'
            '  n - длина строки, k - сдвиг\n'
            '  Можно умножить первую строку на две, тогда она будет выглядеть так:\n'
            '  n - k   k   n - k   k\n'
            '  Вторая строка выглядит так:\n'
            '  k   n - k\n'
            '  Теперь можно найти вхождение второй строки в первую\n'
            '\n'
            '# Проверка подстроки на палиндром\n'
            '  Для этого нужно найти хеш подстроки и её обратный хеш (хеш перевёрнутой строки)\n'
            '  После этого проверить равенство хешей\n'
            '\n'
            '# Проверка на период (можно ли разбить на одинаковые блоки длиной k)\n'
            '  Сначала нужно проверить, делится ли длина строки на k\n'
            '  Дальше нужно сравнить хеши строк от второго до последнего блока и от первого до предпоследнего\n'
            '  s[:n - k] и s[k + 1:]\n'
            '\n'
            '# Минимальный период строки\n'
            '  Нужно разложить длину строки на множители и увеличивать значение, пока строка является периодом (делить на всё большее значение)\n'
            '\n'
            '# Сравнение строк\n'
            '  Нужно найти самый большой общий префикс, а потом сравнить символы после него\n'
            '  Длину префикса можно найти бинпоиском\n'
            '\n'
            '# Поиск подпалиндромов\n'
            '  Палиндром может быть нечётной длины (центр - символ) и чётной (центр между символами)\n'
            '  Можно пройти по строке, смотря на символы и промежутки между символами. Таким образом мы перебираем центр палиндрома\n'
            '  От каждого центра мы будем расширять строку, пока эта строка является палиндромом (проверка делается хешами)\n'
            '\n'
            '  Но поиск палиндромов можно осуществить быстрее, проще и без хешей с использованием Алгоритма Манакера\n'
            '  (раздел Manacher)\n'
            '\n'
            '# Поиск наибольшей общей подстроки\n'
            '  Посчитаем хеши двух строк\n'
            '  Теперь сделаем бинпоиск по длине общей подстроки\n'
            '  Для каждого значения m бинпоиска пройдём сначала по первой строке и положим все хеши подстрок длины m в map\n'
            '  Теперь пройдём по хешам подстрок длины m второй строки и посмотрим, есть ли какие-то из них в map\n'
            '\n'
            '# z-функция\n'
            '  z-функция - это поиск максимального числа l, такого, что подстрока, начинающаяся в i и длиной l, равна префиксу длины l\n'
            '  l можно искать бинпоиском, а сравнивать строки - хешами\n'
            '\n'
            '  Но z-функцию можно написать проще и без хешей\n'
            '  (раздел z_function)\n'
            '\n'
            '# По строке можно построить дерево хешей (описано в segment_tree)\n'
            '  Такое дерево позволяет делать операции с хешами и изменять элементы строки\n')


def z_function():
    return ('Z-функция\n'
            '\n'
            'Z-функция для индекса i ищет максимальное число l, такое, что подстрока, начинающаяся в i и длиной l, равна префиксу длины l\n'
            '\n'
            'Z-функция может быть использована для проверки вхождения подстроки в строку (нужно дописать к меньшей строке символ, которого нет в обоих строках, и большую строку)\n'
            'тогда, посчитав z-функцию от получившейся строки можно будет найти все вхождения первой строки во вторую\n'
            '\n'
            'Z-функция может быть реализована по-разному\n'
            'Основные способы:\n'
            '1. Хэши (описано в hashes)\n'
            '2. Алгоритм, вычисляющий следующие значения, используя уже вычисленные значения\n'
            '\n'
            'Рассмотрим второй алгоритм\n'
            '\n'
            'Следующие значения вычисляются на основе предыдущих\n'
            'Хранятся границы такого z-блока, правая граница которого максимальна\n'
            '(z-блок - подстрока с началом в i и максимальной длиной l (значение z-функции для i))\n'
            '\n'
            'Есть два случая:\n'
            '1. i не лежит в сохранённом блоке (тогда нужно наивно пройти по строке и сравнить)\n'
            '2. i лежит в сохранённом блоке (тогда есть два случая)\n'
            '   2.1 z[i - left] + i > right (тогда нужно наивно пройти по строке от r и сравнить)\n'
            '   2.2. z[i - left] + i <= right (тогда уже известно значение, оно равно z[i - left])\n'
            '\n'
            'Реализация такого алгоритма (l, r на полуинтервалах):\n'
            'int n = s.size();\n'
            'vector<int> z(n);\n'
            'z[0] = n;\n'
            'int l = 0, r = 1;\n'
            'for (int i = 1; i < n; i++) {\n'
            '    z[i] = max(0, min(z[i - l], r - i));\n'
            '    while (z[i] + i < n && s[z[i]] == s[z[i] + i]) {\n'
            '        z[i]++;\n'
            '    }\n'
            '    if (z[i] + i > r) {\n'
            '        r = z[i] + i;\n'
            '        l = i;\n'
            '    }\n'
            '}\n'
            '\n'
            'Применения:\n'
            '# Поиск подстроки в строке\n'
            '  Запишем две строки через спец. символ (сначала строка, которую мы ищем) и посчитаем z-функцию\n'
            '  Позиция, где z-функция равна длине искомой строки - начало вхождения подстроки\n'
            '\n'
            '# Период строки (требуется найти минимальную по длине строку t такую, что строку s можно представить в виде конкатенации нескольких строк t)\n'
            '  Посчитаем z-функцию\n'
            '  Теперь пройдём по массиву z и найдём первую позицию i такую, что i + z[i] == n && n % i == 0 (1-индексация)\n'
            '  Тогда ответ i\n'
            '  Если такой позиции нет, ответ - n\n')


def Manacher():
    return ('Алгоритм Манакера\n'
            '\n'
            'Алгоритм Манакера позволяет находить для каждого элемента строки максимальную длину подстроки-палиндрома с центром в этом элементе\n'
            '\n'
            'Алгоритм возвращает два массива половин длин палиндромов (для чётных и нечётных палиндромов)\n'
            'Благодаря этому можно легко найти общее кол-во палиндромов в строке, сложив все значения двух массивов\n'
            '\n'
            'Реализация Алгоритма Манакера схожа с реализацией оптимального алгоритма нахождения z-функции\n'
            'Следующие значения вычисляются на основе предыдущих и хранятся границы палиндрома, правая граница которого максимальна\n'
            '\n'
            'Есть 2 случая:\n'
            '1. Следующий элемент лежит в сохранённом палиндроме (тогда находится зеркальное значение и выполняется наивный алгоритм)\n'
            '2. Следующий элемент не лежит в сохранённом палиндроме (наивный алгоритм)\n'
            '\n'
            'Реализация на C++:\n'
            '#define F first\n'
            '#define S second\n'
            'int n;\n'
            'string s;\n'
            'int increase(int middle_index, int size) {\n'
            '    while (middle_index - size >= 0 &&\n'
            '           middle_index + size < n  &&\n'
            '           s[middle_index + size] == s[middle_index - size]) {\n'
            '        size++;\n'
            '    }\n'
            '    return size - 1;\n'
            '}\n'
            'int main() {\n'
            '    string input;\n'
            '    cin >> input;\n'
            '    n = 2 * input.size() - 1;\n'
            '    for (int i = 0; i < n; ++i) {  //aboba -> a#b#o#b#a\n'
            '        if (i % 2 == 0) {\n'
            '            s += input[i / 2];\n'
            '        } else {\n'
            '            s += \'#\';\n'
            '        }\n'
            '    }\n'
            '    vector<int> dp(n, 0);\n'
            '    pair<int, int> big_pal = make_pair(0, 0);\n'
            '    vector<int> odd(n / 2), even((n + 1) / 2);\n'
            '    for (int mid_index = 0; mid_index < n; ++mid_index) {\n'
            '        int pal_length;\n'
            '        if (mid_index > big_pal.S) {  //первый случай\n'
            '            pal_length = increase(mid_index, 0);\n'
            '        }\n'
            '        else {  //второй случай\n'
            '            pal_length = dp[(big_pal.S + big_pal.F) - mid_index];\n'
            '            if (mid_index + pal_length >= big_pal.S) {\n'
            '                pal_length = increase(mid_index, big_pal.S - mid_index);\n'
            '            }\n'
            '        }\n'
            '        dp[mid_index] = pal_length;  //обновление всего\n'
            '        if (mid_index + pal_length > big_pal.S) {\n'
            '            big_pal = make_pair(mid_index - pal_length,\n'
            '                                mid_index + pal_length);\n'
            '        }\n'
            '        if (mid_index % 2 == 0) {  //заполнение массивов с ответами, неочевидно, где округление сверху и снизу\n'
            '            even[mid_index / 2] = (pal_length / 2) + 1;\n'
            '        } else {\n'
            '            odd[mid_index / 2] =  (pal_length + 1) / 2;\n'
            '        }\n'
            '    }\n'
            '    for (int i: even) {\n'
            '        cout << i << \' \';\n'
            '    }\n'
            '    cout << endl;\n'
            '    for (int i: odd) {\n'
            '        cout << i << \' \';\n'
            '    }\n'
            '    cout << endl;\n'
            '}\n')


def bit_operations():
    return ('Битовые операции\n'
            '\b'
            'битовые операции значительно упрощают и ускоряют написание и работу некоторых алгоритмов, функций\n'
            '\n'
            '| - or\n'
            '& - and\n'
            '~ - not\n'
            '^ - xor\n'
            '>>, << - битовые сдвиги\n'
            'в основном биты считаются справа налево\n'
            '\n'
            '1 << c                  # 2 в степени c\n'
            'x | (1 << n)            # установление n-ого бита в 1\n'
            'x & ~(1 << n)           # установление n-ого бита в 0\n'
            'x ^ (1 << n)            # инвертирование n-ого бита\n'
            'n << 1                  # умножение на 2\n'
            'n >> 1                  # целая часть от деления на 2\n'
            'n << m                  # умножение на 2^m\n'
            'n >> m                  # целая часть от деления на 2^m\n'
            '(a ^ b) == 0            # проверка на равенство\n'
            '(n & 1) == 1            # проверка на чётность\n'
            'int(bool(x & (1 << n))) # определение n-ого бита\n'
            '(x + y) >> 1            # среднее арифметическое (целое)\n')


def f_Euler():
    return ('Функция Эйлера\n'
            '\n'
            'Функция Эйлера вычисляет кол-во чисел от 1 до n, взаимно простых с n\n'
            '\n'
            'def fi(n):\n'
            '    ans = n\n'
            '    i = 2\n'
            '    while i * i <= n:\n'
            '        if n % i == 0:\n'
            '            while n % i == 0:\n'
            '                n //= i\n'
            '            ans -= ans // i\n'
            '        i += 1\n'
            '    if n > 1:\n'
            '        ans -= ans // n\n'
            '    print(ans)\n'
            '\n'
            'Асимптотика - O(sqrt(n))\n')


def quick_pow():
    return ('Быстрое возведение в степень\n'
            '\n'
            'def quick_pow(x, y):\n'
            '    if not y:\n'
            '        return 1\n'
            '    if not y % 2:\n'
            '        ans = quick_pow(x, y // 2)\n'
            '        return ans * ans\n'
            '    return quick_pow(x, y - 1) * x\n'
            '\n'
            'Асимптотика - O(log n)\n')


def eratosthenes_sieve():
    return ('N = int(input())                           # До какого числа мы ищем простые числа\n'
            'isPrime = [True] * (N + 1)                 # Создание списка из True\n'
            'Primes = []                                # Список, в котором будут простые числа\n'
            'for d in range(2, N + 1):\n'
            '    if isPrime[d]:\n'
            '        Primes.append(d)\n'
            '        for i in range(d ** 2, N + 1, 2): # Убираем лишние числа\n'
            '            isPrime[i] = False\n'
            'print(Primes)\n'
            '\n'
            'Алгоритм выше работает за O(n log log n)\n'
            'Существует алгоритм решета, работающий за O(n):\n'
            'vector<int> lp(N + 1, 0), pr;  // lp[i] - минимальный простой делитель числа i; pr - список простых чисел\n'
            'for (int i = 2; i <= N; i++) {\n'
            '    if (!lp[i]) {              // простое число или нет\n'
            '        lp[i] = i;\n'
            '        pr.push_back(i);\n'
            '    }\n'
            '    for (int j = 0; j < pr.size() && pr[j] * i <= N && pr[j] <= lp[i]; j++)\n'
            '        lp[pr[j] * i] = pr[j];\n'
            '}\n'
            '\n'
            'С помощью второго алгоритма можно выполнить факторизацию числа\n'
            'vector<int> factorize(int n, const vector<int>& lp) {\n'
            '    vector<int> ans;\n'
            '    while (n > 1) {\n'
            '        ans.push_back(lp[n]);\n'
            '        n /= lp[n];\n'
            '    }\n'
            '    return ans;\n'
            '}\n')


def check_for_simplicity():
    return ('z = False\n'
            'x = int(input())\n'
            'if x % 2 == 0 and x != 2:                    # Проверка, является ли число 2, и делится ли оно на два\n'
            '    print(\'NO\')\n'
            'else:\n'
            '    for i in range(3, int(x ** 0.5) + 1, 2):\n'
            '        if x % i == 0:\n'
            '            z = True\n'
            '            break                            # Если находится хотя бы один делитель, то число уже не является простым\n'
            '    if z:\n'
            '        print(\'NO\')\n'
            '    else:\n'
            '        print(\'YES\')')

def Dijkstra():
    return ('Алгоритм Дейкстры\n'
            '\n'
            'Алгоритм Дейкстры - это алгоритм поиска кратчайших путей от начальной вершины до всех остальных во взвешенном графе\n'
            '\n'
            'Описание:\n'
            'Ответы для всех вершин будем хранить в массиве d\n'
            'Сначала все элементы d заполнены INF (большое число), кроме стартовой (s), d[s] = 0\n'
            'Каждую итерацию мы ищем непосещённую вершину с минимальным d[j] (v)\n'
            'После этого мы пытаемся обновить ответы для всех смежных вершин (минимум из d[смежная_вершина] и d[v] + длина_ребра)\n'
            '\n'
            'Также можно восстановить пути до вершин\n'
            'Для этого при обновлении ответов для смежных вершин будем присваивать p[смежная_вершина] = v\n'
            'После нужно будет пройтись от конечной вершины по предкам до начальной и развернуть полученный путь\n'
            '\n'
            'Можно не перебирать каждый раз вершину с наименьшим расстоянием, а использовать структуру, которая делает это автоматически - set\n'
            'Такой способ будет работать быстрее (кроме случая с полными графами - в полных графах лучше просто циклом искать вершину)\n'
            'int n, start, finish;\n'
            'cin >> n >> start >> finish;\n'
            'start--;\n'
            'finish--;\n'
            'vector<vector<pair<int, int>>> g(n);\n'
            'vector<int> p(n, -1);\n'
            '// Ввод графа (первое значение в паре - вершина, второе - вес)\n'
            'vector<int> d(n, INF);\n'
            'd[start] = 0;\n'
            'set<pair<int, int>> s;\n'
            's.insert({0, start});\n'
            'while (!s.empty()) {\n'
            '    int v = s.begin()->second;\n'
            '    s.erase(s.begin());\n'
            '    for (auto i: g[v]) {\n'
            '        int u = i.first;\n'
            '        int w = i.second;\n'
            '        if (d[u] > d[v] + w) {\n'
            '            s.erase({d[u], u});\n'
            '            d[u] = d[v] + w;\n'
            '            p[u] = v;\n'
            '            s.insert({d[u], u});\n'
            '        }\n'
            '    }\n'
            '}\n'
            'if (d[finish] == INF) {\n'
            '    cout << "-1\\n";\n'
            '    return 0;\n'
            '}\n'
            'cout << d[finish] << el;\n'
            'vector<int> path;\n'
            'for (int v = finish; v != start; v = p[v])\n'
            '    path.push_back(v + 1);\n'
            'path.push_back(s + 1);\n'
            'reverse(path.begin(), path.end());\n'
            'cout << path << el;\n')


def gcdex():
    return ('Расширенный алгоритм Евклида\n'
            '\n'
            'Алгоритм позволяет искать решения уравнения ax + by = c\n'
            '\n'
            'int gcd(int a, int b, int& x, int& y) {\n'
            '    if (a == 0) {\n'
            '        x = 0;\n'
            '        y = 1;\n'
            '        return b;\n'
            '    }\n'
            '    int x1, y1;\n'
            '    int g = gcd(b % a, a, x1, y1);\n'
            '    x = y1 - (b / a) * x1;\n'
            '    y = x1;\n'
            '    return g;\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int a, b, c, x, y;\n'
            '    cin >> a >> b >> c;\n'
            '    int signa = 1, signb = 1;\n'
            '    if (a < 0) {\n'
            '        a *= -1;\n'
            '        signa = -1;\n'
            '    }\n'
            '    if (b < 0) {\n'
            '        b *= -1;\n'
            '        signb = -1;\n'
            '    }\n'
            '    int g = gcd(a, b, x, y);\n'
            '    if (c % g != 0) {\n'
            '        cout << "Impossible" << endl;\n'
            '        return 0;\n'
            '    }\n'
            '    x *= (c / g) * signa;\n'
            '    y *= (c / g) * signb;\n'
            '    cout << \' \' << x << \' \' << y << endl;\n'
            '    return 0;\n'
            '}\n')


def sorts():
    return ('Сортировки\n'
            '\n'
            '1. Сортировка слиянием (mergesort):\n'
            'vector<int> tmp;\n'
            'void mergesort(vector<int>& a, int l, int r) {\n'
            '    if (l == r - 1)\n'
            '        return;\n'
            '    int m = (l + r) / 2;\n'
            '    mergesort(a, l, m);\n'
            '    mergesort(a, m, r);\n'
            '    merge(a.begin() + l, a.begin() + m, a.begin() + m, a.begin() + r, tmp.begin() + l);\n'
            '    copy(tmp.begin() + l, tmp.begin() + r, a.begin() + l);\n'
            '}\n'
            'Из основной программы запускается с l = 0 и r = n\n'
            '\n'
            'Если написать свой merge, то можно считать кол-во инверсий в массиве\n'
            'vector<int> tmp;\n'
            'll ans = 0;\n'
            'void mergesort(vector<int>& a, int l, int r) {\n'
            '    if (l == r - 1)\n'
            '        return;\n'
            '    int m = (l + r) / 2;\n'
            '    mergesort(a, l, m);\n'
            '    mergesort(a, m, r);\n'
            '    int it1 = l, it2 = m, pos = l;\n'
            '    while(it1 < m || it2 < r) {\n'
            '        if (it1 == m) {\n'
            '            tmp[pos] = a[it2];\n'
            '            ++it2;\n'
            '        }\n'
            '        else if (it2 == r) {\n'
            '            tmp[pos] = a[it1];\n'
            '            ++it1;\n'
            '        }\n'
            '        else if (a[it1] <= a[it2]){\n'
            '            tmp[pos] = a[it1];\n'
            '            ++it1;\n'
            '        }\n'
            '        else {\n'
            '            tmp[pos] = a[it2];\n'
            '            ++it2;\n'
            '            ans += (m - it1);\n'
            '        }\n'
            '        ++pos;\n'
            '    }\n'
            '    copy(tmp.begin() + l, tmp.begin() + r, a.begin() + l);\n'
            '}\n'
            '\n'
            '2. Пузырьковая сортировка (bubble sort):\n'
            'int n;\n'
            'cin >> n;\n'
            'vector<int> a(n);\n'
            'cin >> a;\n'
            'for (int i = 0; i < n - 1; i++) {\n'
            '    for (int j = 0; j < n - 1; j++) {\n'
            '        if (a[j] > a [j + 1])\n'
            '            swap(a[j], a[j + 1]);\n'
            '    }\n'
            '}\n'
            '\n'
            '3. Сортировка выбором минимума/максимума:\n'
            'int n;\n'
            'cin >> n;\n'
            'vector<int> a(n);\n'
            'cin >> a;\n'
            'for (int i = 0; i < n; i++) {\n'
            '    int pos = min_element(a.begin() + i, a.end()) - a.begin();\n'
            '    swap(a[i], a[pos]);\n'
            '}\n'
            'cout << a << el;\n'
            '\n'
            '4. Быстрая сортировка (quick sort)\n'
            'Каждый раз берём какой-то элемент x и разделяем массив на две части: все числа < x и все числа >= x\n'
            'После этого запускаем сортировку для этих двух массивов\n'
            '\n'
            '# Возвращает конец левого массива и начало правого (указатели l, r)\n'
            'def partition(a, l, r, pivot):\n'
            '    while l <= r:\n'
            '        if a[l] < pivot:\n'
            '            l += 1\n'
            '        else:\n'
            '            if a[r] > pivot:\n'
            '                r -= 1\n'
            '            else:\n'
            '                a[l], a[r] = a[r], a[l]\n'
            '                l += 1\n'
            '                r -= 1\n'
            '    return l, r\n'
            '\n'
            'def quick_sort(a, l, r):\n'
            '    if r > l:\n'
            '        borders = partition(a, l, r, a[(l + r) // 2])\n'
            '        quick_sort(a, l, borders[1])\n'
            '        quick_sort(a, borders[0], r)\n'
            '\n'
            'Из основной программы вызывается quick_sort(a, 0, n - 1)\n'
            '\n'
            '5. Поразрядная сортировка (radix sort)\n'
            'Подходит для случаев, когда кол-во разрядов в числах меньше, чем logn (но сортировка может сортировать и не числа)\n'
            'Сначала все числа сортируются по последней цифре, потом по предпоследней и т.д. Каждый шаг является модификацией сортировки подсчётом\n'
            'Для удобства числа вводятся в виде строк, и к ним приписываются 0, чтобы длина всех чисел была одинакова\n'
            '\n'
            'n = int(input())\n'
            'max_len = 0\n'
            'a = input().split()\n'
            'for i in range(n):\n'
            '    max_len = max(max_len, len(a[i]))\n'
            'for i in range(n):\n'
            '    a[i] = \'0\' * (max_len - len(a[i])) + a[i]\n'
            'buckets = [[] for i in range(10)]\n'
            'for cur_digit in range(max_len - 1, -1, -1):\n'
            '    for i in range(n):\n'
            '        digit = int(a[i][cur_digit])\n'
            '        buckets[digit].append(a[i])\n'
            '    a.clear()\n'
            '    for b in range(10):\n'
            '        for num in buckets[b]:\n'
            '            a.append(num)\n'
            '        buckets[b].clear()\n'
            'print(*a)\n')


def factorize():
    return ('Факторизация\n'
            '\n'
            'Факторизация числа - это разложение числа на простые множители\n'
            'int n;\n'
            'cin >> n;\n'
            'vector<int> ans;\n'
            'int n1 = n;\n'
            'for (int i = 2; i * i <= n1; i++) {\n'
            '    while (n % i == 0) {\n'
            '        ans.push_back(i);\n'
            '        n /= i;\n'
            '    }\n'
            '}\n'
            'if (n > 1)\n'
            '    ans.push_back(n);\n'
            'cout << ans << endl;\n'
            '\n'
            'Также факторизацию можно выполнить при помощи быстрого решета Эратосфена (см. eratosthenes_sieve)\n')


def gcd_lcm():
    return ('НОД и НОК\n'
            '\n'
            'НОД - наибольший общий делитель\n'
            'int a, b;\n'
            'cin >> a >> b;\n'
            'while (a != 0) {\n'
            '    b %= a;\n'
            '    swap(a, b);\n'
            '}\n'
            'cout << b << endl;\n'
            '\n'
            'НОК - наименьшее общее кратное\n'
            'НОК(a, b) = (a * b) / НОД(a, b)\n')


def LCS():
    return ('Наибольшая общая подпоследовательность\n'
            '\n'
            'Заведём массив dp, где dp[i][j] - НОП для префикса i первой последовательности и префикса j второй последовательности\n'
            'Будем идти по увеличению i и j\n'
            '\n'
            'Если a[i] == b[j], то можно взять ответ для префиксов i - 1, j - 1 и добавить этот новый элемент\n'
            'Если a[i] != b[j], то dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n'
            'Т.к. клетка (i, j) является максимумом из прямоугольника, нам не нужно искать максимум на всём прямоугольнике\n'
            'Мы можем взять максимум из клеток (i - 1, j) и (i, j - 1), т.к. они покрывают весь прямоугольник\n'
            '\n'
            'Для восстановления ответа, нужно знать, откуда мы пришли\n'
            'Функция get нужна для того, чтобы не писать if для обработки клеток на границе таблицы\n'
            '\n'
            'int get(int i, int j, const vector<vector<int>>& dp) {\n'
            '    if (i < 0 || j < 0)\n'
            '        return 0;\n'
            '    return dp[i][j];\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n, m;\n'
            '    cin >> n;\n'
            '    vector<int> a(n);\n'
            '    cin >> a >> m;\n'
            '    vector<int> b(m);\n'
            '    cin >> b;\n'
            '    vector<vector<int>> dp(n, vector<int>(m));\n'
            '    vector<vector<int>> p(n, vector<int>(m, -1));\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        for (int j = 0; j < m; j++) {\n'
            '            if (a[i] == b[j]) {\n'
            '                dp[i][j] = get(i - 1, j - 1, dp) + 1;\n'
            '                p[i][j] = 1;\n'
            '            }\n'
            '            else {\n'
            '                if (get(i - 1, j, dp) < get(i, j - 1, dp)) {\n'
            '                    dp[i][j] = get(i, j - 1, dp);\n'
            '                    p[i][j] = 2;\n'
            '                }\n'
            '                else {\n'
            '                    dp[i][j] = get(i - 1, j, dp);\n'
            '                    p[i][j] = 3;\n'
            '                }\n'
            '            }\n'
            '        }\n'
            '    }\n'
            '    // make answer\n'
            '    vector<int> ans;\n'
            '    int curi = n - 1, curj = m - 1;\n'
            '    while (curi >= 0 && curj >= 0) {\n'
            '        if (p[curi][curj] == 1) {\n'
            '            ans.push_back(a[curi]);\n'
            '            curi--;\n'
            '            curj--;\n'
            '        }\n'
            '        else if (p[curi][curj] == 2) {\n'
            '            curj--;\n'
            '        }\n'
            '        else {\n'
            '            curi--;\n'
            '        }\n'
            '    }\n'
            '    reverse(ans.begin(), ans.end());\n'
            '    cout << ans << el;\n'
            '    return 0;\n'
            '}\n')


def LIS():
    return ('Наибольшая возрастающая подпоследовательность\n'
            '\n'
            'НВП - это подпоследовательность массива, элементы которой возрастают\n'
            '\n'
            'Искать НВП можно при помощи дп\n'
            'Первое решение работает за O(n^2)\n'
            'В dp[i] будем хранить длину НВП, заканчивающейся в этом элементе\n'
            'Тогда пересчёт простой: пройдём по всем j < i, если a[j] < a[i], то обновим ответ через dp[j]\n'
            'Из всех таких ответов возьмём максимальный\n'
            '\n'
            'int n;\n'
            'cin >> n;\n'
            'vector<int> a(n);\n'
            'cin >> a;\n'
            'vector<int> dp(n, 1);\n'
            'vector<int> p(n, -1);\n'
            'for (int i = 0; i < n; i++) {\n'
            '    for (int j = 0; j < i; j++) {\n'
            '        if (a[i] > a[j] && dp[j] + 1 > dp[i]) {\n'
            '            dp[i] = dp[j] + 1;\n'
            '            p[i] = j;\n'
            '        }\n'
            '    }\n'
            '}\n'
            '// make answer\n'
            'int cur = max_element(dp.begin(), dp.end()) - dp.begin();\n'
            'vector<int> ans;\n'
            'while (cur != -1) {\n'
            '    ans.push_back(a[cur]);\n'
            '    cur = p[cur];\n'
            '}\n'
            'reverse(ans.begin(), ans.end());\n'
            'cout << ans << el;\n'
            '\n'
            'Но задачу можно решить за O(nlogn)\n'
            'Изменим значение, которое хранит дп\n'
            'Теперь dp[i] - наименьший элемент, на который заканчивается возрастающая последовательность длины i\n'
            'Что это даёт? Последний элемент текущей НВП говорит нам о том, какой элемент можно поставить следующим\n'
            'Чем меньше последний элемент, тем больше элементов мы сможем поставить дальше\n'
            'Изначально dp[0] = -INF, потому что после -INF можно поставить любой элемент\n'
            'НВП длины > 0 у нас пока нет, поэтому все остальные элементы равны INF (после INF нельзя ничего поставить)\n'
            '\n'
            'Чтобы понять алгоритм, можно рассмотреть пример:\n'
            'a = [2, 3, 1, 4, 2, 6, 6, 9, 5]\n'
            'Изначально dp = [-INF, INF, INF, INF, INF, INF, INF, INF, INF, INF]\n'
            '1. Мы рассмотрели a[0] = 2, у нас появилась последовательность длины 1\n'
            'dp = [-INF, 2, INF, INF, INF, INF, INF, INF, INF, INF]\n'
            '2. Рассмотрели a[1] = 3, появилась ВП длины 2 - [2, 3]\n'
            'dp = [-INF, 2, 3, INF, INF, INF, INF, INF, INF, INF]\n'
            '3. Рассмотрели a[2] = 1, обновилось значение dp[1]\n'
            'dp = [-INF, 1, 3, INF, INF, INF, INF, INF, INF, INF]\n'
            '4. Рассмотрели a[3] = 4\n'
            'dp = [-INF, 1, 3, 4, INF, INF, INF, INF, INF, INF]\n'
            '5. Рассмотрели a[4] = 2\n'
            'dp = [-INF, 1, 2, 4, INF, INF, INF, INF, INF, INF]\n'
            '6. Рассмотрели a[5] = 6\n'
            'dp = [-INF, 1, 2, 4, 6, INF, INF, INF, INF, INF]\n'
            '7. Рассмотрели a[6] = 6\n'
            'dp = [-INF, 1, 2, 4, 6, INF, INF, INF, INF, INF]\n'
            '8. Рассмотрели a[7] = 9\n'
            'dp = [-INF, 1, 2, 4, 6, 9, INF, INF, INF, INF]\n'
            '9. Рассмотрели a[8] = 5\n'
            'dp = [-INF, 1, 2, 4, 5, 9, INF, INF, INF, INF]\n'
            '\n'
            'Заметим, что при появлении нового числа в dp меняется не больше 1 значения (либо мы обновляем dp[1], либо добавляем новое число в конец какой-то подпоследовательности)\n'
            'Второе важное свойство - в dp все значения всегда возрастают (потому что нельзя сделать бОльшую последовательность с меньшим последним элементом)\n'
            'При каждой итерации хотим найти наибольшую последовательность, куда мы можем поставить новый элемент\n'
            'Это делается при помощи бинпоиска\n'
            '\n'
            'Если хотим искать наибольшую неубывающую последовательность, то нужно изменить бинпоиск (искать последнее вхождение, т.е. upper_bound())\n'
            '\n'
            'Теперь нужно восстановить ответ\n'
            'Используем предков. Мы добавляем элемент после наибольшего элемента, который меньше нашего, поэтому предок и есть этот элемент\n'
            'Но в dp лежат числа, а мы хотим знать индексы, поэтому создадим массив index[i], параллельный dp\n'
            'Если в dp[i] лежит a[j], то в index[i] лежит j\n'
            '\n'
            'int INF = 1e9;\n'
            'int n;\n'
            'cin >> n;\n'
            'vector<int> a(n);\n'
            'cin >> a;\n'
            'vector<int>dp(n + 1, INF);\n'
            'vector<int>index(n + 1, -1);\n'
            'vector<int>p(n, -1);\n'
            'dp[0] = -INF;\n'
            'for (int i = 0; i < n; i++) {\n'
            '    int pos = lower_bound(dp.begin(), dp.end(), a[i]) - dp.begin();\n'
            '    p[i] = index[pos - 1];\n'
            '    dp[pos] = a[i];\n'
            '    index[pos] = i;\n'
            '}\n'
            '// make answer\n'
            'for (int i = n; i >= 0; --i) {\n'
            '    if (dp[i] != INF) {\n'
            '        int cur = index[i];\n'
            '        vector<int> ans;\n'
            '        while (cur != -1) {\n'
            '            ans.push_back(a[cur]);\n'
            '            cur = p[cur];\n'
            '        }\n'
            '        reverse(ans.begin(), ans.end());\n'
            '        cout << ans << el;\n'
            '        return 0;\n'
            '    }\n'
            '}\n')


def segment_tree():
    return ('Дерево отрезков\n'
            '\n'
            'Дерево отрезков - структура данных, хранящая значения функций для всех отрезков массива\n'
            'Листья - элементы массива, уровень выше - объединение листьев (непересекающиеся отрезки массива длины 2) и т.д.\n'
            'Дерево отрезков удобно хранить в массиве: сыновья вершины v - v * 2 + 1 и v * 2 + 2\n'
            '\n'
            'Все примеры кода используют дерево отрезков НА ПОЛУИНТЕРВАЛАХ'
            '\n'
            'Дерево для поиска позиции максимума на отрезке с изменением элементов\n'
            'В самом дереве хранится индекс, для поиска максимума сделана функция Max\n'
            'Для нейтрального элемента к массиву добавлено самое маленькое значение\n'
            '\n'
            'int n;\n'
            'vector<int> a, t;\n'
            '\n'
            'int Max(int i, int j) {\n'
            '    if (a[i] > a[j])\n'
            '        return i;\n'
            '    return j;\n'
            '}\n'
            '\n'
            'void build(int v, int l, int r) {\n'
            '    if (r - l == 1) {\n'
            '        t[v] = l;\n'
            '        return;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    build(v * 2 + 1, l, m);\n'
            '    build(v * 2 + 2, m, r);\n'
            '    t[v] = Max(t[v * 2 + 1], t[v * 2 + 2]);\n'
            '}\n'
            '\n'
            'int ask(int v, int l, int r, int askl, int askr) {\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return n; // neutral element\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        return t[v];\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    return Max(ask(2 * v + 1, l, m, askl, askr), ask(2 * v + 2, m, r, askl, askr));\n'
            '}\n'
            '\n'
            'void change(int v, int l, int r, int pos, int val) {\n'
            '    if (r - l == 1) {\n'
            '        a[l] = val;\n'
            '        t[v] = val;\n'
            '        return;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    if (pos < m) {\n'
            '        change(2 * v + 1, l, m, pos, val);\n'
            '    }\n'
            '    else {\n'
            '        change(2 * v + 2, m, r, pos, val);\n'
            '    }\n'
            '    t[v] = Max(t[v * 2 + 1], t[v * 2 + 2]);\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    cin >> n;\n'
            '    a.resize(n);\n'
            '    t.resize(4 * n);\n'
            '    cin >> a;\n'
            '    a.push_back(-INT_MAX);\n'
            '    build(0, 0, n);\n'
            '\n'
            '    int q;\n'
            '    cin >> q;\n'
            '    while (q--) {\n'
            '        int l, r;\n'
            '        cin >> l >> r;\n'
            '        int ind = ask(0, 0, n, l - 1, r);\n'
            '        cout << a[ind] << \' \' << ind + 1 << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Функция ask проверяет цвет вершины:\n'
            'жёлтая - пересечение с отрезком запроса\n'
            'зелёная - текущий отрезок входит в отрезок запроса\n'
            'красная - нет пересечения с отрезком запроса\n'
            '\n'
            'Из зелёной вершины всегда идут зелёные, из красной - красные\n'
            'Первый if - проверка на красную, второй - на зелёную\n'
            '\n'
            'При сумме нейтральный элемент - 0\n'
            '\n'
            'Универсальное дерево - это вершина Node() и функция unite()\n'
            'В универсальном дереве меняется только Node() и unite()\n'
            'Пример (кол-во максимумов на отрезке):\n'
            'struct Node {\n'
            '    int maxx, cnt;\n'
            '    Node(): maxx(-INT_MAX), cnt(0) {}\n'
            '};\n'
            '\n'
            'int n;\n'
            'vector<int> a;\n'
            'vector<Node> t;\n'
            '\n'
            'Node unite(const Node& a, const Node& b) {\n'
            '    Node res;\n'
            '    if (a.maxx > b.maxx) {\n'
            '        res = a;\n'
            '    }\n'
            '    else if (a.maxx < b.maxx) {\n'
            '        res = b;\n'
            '    }\n'
            '    else {\n'
            '        res.maxx = a.maxx;\n'
            '        res.cnt = a.cnt + b.cnt;\n'
            '    }\n'
            '    return res;\n'
            '}\n'
            '\n'
            'void build(int v, int l, int r) {\n'
            '    if (r - l == 1) {\n'
            '        t[v].maxx = a[l];\n'
            '        t[v].cnt = 1;\n'
            '        return;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    build(v * 2 + 1, l, m);\n'
            '    build(v * 2 + 2, m, r);\n'
            '    t[v] = unite(t[v * 2 + 1], t[v * 2 + 2]);\n'
            '}\n'
            '\n'
            'Node ask(int v, int l, int r, int askl, int askr) {\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return Node();\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        return t[v];\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    return unite(ask(2 * v + 1, l, m, askl, askr), ask(2 * v + 2, m, r, askl, askr));\n'
            '}\n'
            '\n'
            'void change(int v, int l, int r, int pos, int val) {\n'
            '    if (r - l == 1) {\n'
            '        t[v].maxx = val;\n'
            '        t[v].cnt = 1;\n'
            '        return;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    if (pos < m) {\n'
            '        change(2 * v + 1, l, m, pos, val);\n'
            '    }\n'
            '    else {\n'
            '        change(2 * v + 2, m, r, pos, val);\n'
            '    }\n'
            '    t[v] = unite(t[v * 2 + 1], t[v * 2 + 2]);\n'
            '}\n'
            '\n'
            'Node и unite для поиска наибольшей суммы подотрезка на отрезке:\n'
            'Node unite(const Node& a, const Node& b) {\n'
            '    Node res;\n'
            '    res.summ = a.summ + b.summ;\n'
            '    res.maxpref = max(a.maxpref, a.summ + b.maxpref);\n'
            '    res.maxsuff = max(b.maxsuff, b.summ + a.maxsuff);\n'
            '    res.maxsum = max({a.maxsum, b.maxsum, a.maxsuff + b.maxpref});\n'
            '    return res;\n'
            '}\n'
            'struct Node {\n'
            '    int maxsum, maxpref, maxsuff, summ;\n'
            '    Node(): maxsum(0), maxpref(0), maxsuff(0), summ(0) {}\n'
            '    Node(int x): maxsum(x), maxpref(x), maxsuff(x), summ(x) {}\n'
            '\n'
            '};\n'
            '\n'
            'МАССОВЫЕ ОПЕРАЦИИ\n'
            'Массовые операции - операции прибавления и присвоения на отрезке\n'
            'Для массовых операций используются отложенные операции (выполняем операцию, когда понадобится соответствующий отрезок)\n'
            'Реализация прибавления и присвоения различны\n'
            '\n'
            'Массовое прибавление (для суммы):\n'
            'void push(int v) {\n'
            '    c[v * 2 + 1] += c[v];\n'
            '    c[v * 2 + 2] += c[v];\n'
            '    c[v] = 0;\n'
            '}\n'
            'int ask(int v, int l, int r, int askl, int askr) {\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return 0;\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        return t[v] + c[v] * (r - l);\n'
            '        // for min: return t[v] + c[v];\n'
            '    }\n'
            '    push(v);\n'
            '    int m = (l + r) / 2;\n'
            '    int x = ask(2 * v + 1, l, m, askl, askr);\n'
            '    int y = ask(2 * v + 2, m, r, askl, askr);\n'
            '    t[v] = t[v * 2 + 1] + t[v * 2 + 2] + c[v * 2 + 1] * (m - l) + c[v * 2 + 2] * (r - m);\n'
            '    return x + y;\n'
            '}\n'
            'void change(int v, int l, int r, int askl, int askr, int val) {\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return;\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        c[v] += val;\n'
            '        return;\n'
            '    }\n'
            '    push(v);\n'
            '    int m = (l + r) / 2;\n'
            '    change(v * 2 + 1, l, m, askl, askr, val);\n'
            '    change(v * 2 + 2, m, r, askl, askr, val);\n'
            '    t[v] = t[v * 2 + 1] + t[v * 2 + 2] + c[v * 2 + 1] * (m - l) + c[v * 2 + 2] * (r - m);\n'
            '    // for min: t[v] = min(t[v * 2 + 1] + c[v * 2 + 1], t[v * 2 + 2] + c[v * 2 + 2]);\n'
            '}\n'
            '\n'
            'Для этой операции понадобится массив c (размер 4*n), в котором будут храниться значения, которые нужно прибавить\n'
            'Также используется операция проталкивания (push), которая заносит прибавление в вершине в её сыновей\n'
            'build не меняется\n'
            '\n'
            'Массовое присвоение (для суммы):\n'
            'void push(int v) {\n'
            '    if (isch[v]) {\n'
            '        c[v * 2 + 1] = c[v];\n'
            '        c[v * 2 + 2] = c[v];\n'
            '        isch[v * 2 + 1] = true;\n'
            '        isch[v * 2 + 2] = true;\n'
            '        isch[v] = false;\n'
            '    }\n'
            '}\n'
            'int ask(int v, int l, int r, int askl, int askr) {\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return 0;\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        return (isch[v] ? c[v] * (r - l) : t[v]);\n'
            '    }\n'
            '    push(v);\n'
            '    int m = (l + r) / 2;\n'
            '    int x = ask(2 * v + 1, l, m, askl, askr);\n'
            '    int y = ask(2 * v + 2, m, r, askl, askr);\n'
            '    t[v] = t[v * 2 + 1] + t[v * 2 + 2] + c[v * 2 + 1] * (m - l) + c[v * 2 + 2] * (r - m);\n'
            '    return x + y;\n'
            '}\n'
            'void change(int v, int l, int r, int askl, int askr, int val) {\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return;\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        c[v] = val;\n'
            '        isch[v] = true;\n'
            '        return;\n'
            '    }\n'
            '    push(v);\n'
            '    int m = (l + r) / 2;\n'
            '    change(v * 2 + 1, l, m, askl, askr, val);\n'
            '    change(v * 2 + 2, m, r, askl, askr, val);\n'
            '    t[v] = (isch[v * 2 + 1] ? c[v * 2 + 1] * (m - l) : t[v * 2 + 1]) + (isch[v * 2 + 2] ? c[v * 2 + 2] * (r - m) : t[v * 2 + 2]);\n'
            '    // for min: min((isch[v * 2 + 1] ? c[v * 2 + 1] : t[v * 2 + 1]), (isch[v * 2 + 2] ? c[v * 2 + 2] : t[v * 2 + 2]));\n'
            '}\n'
            '\n'
            'Для присвоения добавляется массив bool isch, который хранит true, если было изменение в данной вершине\n'
            '\n'
            'Используя дерево отрезков, можно построить дерево хешей и делать операции с хешами, имея возможность изменять элементы строки\n'
            'Получение хеша подстроки с изменением элемента (в коде в функции передаются дерево и строка, потому что часто строк несколько, нужны обратные хеши и т.д., поэтому нужны несколько деревьев):\n'
            'll unite(ll h1, ll h2, int len2) {\n'
            '    return (h1 * powers[len2] + h2) % MOD;\n'
            '}\n'
            'void build(vector<ll>& tree, const string& str, int v, int l, int r) {\n'
            '    if (r - l == 1) {\n'
            '        tree[v] = str[l];\n'
            '        return;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    build(tree, str, v * 2 + 1, l, m);\n'
            '    build(tree, str, v * 2 + 2, m, r);\n'
            '    tree[v] = unite(tree[v * 2 + 1], tree[v * 2 + 2], r - m);\n'
            '}\n'
            'void change(vector<ll>& tree, int v, int l, int r, int pos, char val) {\n'
            '    if (r - l == 1) {\n'
            '        tree[v] = val;\n'
            '        return;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    if (pos < m) {\n'
            '        change(tree, v * 2 + 1, l, m, pos, val);\n'
            '    }\n'
            '    else {\n'
            '        change(tree, v * 2 + 2, m, r, pos, val);\n'
            '    }\n'
            '    tree[v] = unite(tree[v * 2 + 1], tree[v * 2 + 2], r - m);\n'
            '}\n'
            'void ask(const vector<ll>& tree, vector<pair<ll, int>>& Nodes, int v, int l, int r, int askl, int askr) {\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return;\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        Nodes.push_back({tree[v], r - l});\n'
            '        return;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    ask(tree, Nodes, v * 2 + 1, l, m, askl, askr);\n'
            '    ask(tree, Nodes, v * 2 + 2, m, r, askl, askr);\n'
            '}\n'
            'ask не возвращает хеш, а складывает ответ в массив\n'
            'Это нужно, чтобы получить конечный ответ\n'
            'Получить его можно, просто сделав несколько unite по массиву Nodes (ведь дерево отрезков положит хеши в массив в правильном порядке)\n')


def ternary_search():
    return ('Тернарный/троичный поиск\n'
            '\n'
            'Тернарный поиск применяется для функций с одним экстремумом\n'
            'Тернарный поиск ищет этот экстремум\n'
            'Для этого отрезок делится на 3 части (m1 и m2)\n'
            '\n'
            '// f(m1) < f(m2) => r = m2\n'
            '// f(m1) > f(m2) => l = m1\n'
            '// f(m1) = f(m2) => l = m1 and r = m2\n'
            'double l = -100, r = 100;\n'
            'for (int it = 0; it <= 10; it++) {\n'
            '    double m1 = l + (r - l) / 3;\n'
            '    double m2 = m1 + (r - l) / 3;\n'
            '    if (f(m1) < f(m2)) // если выгнуто вниз, то <, иначе >\n'
            '        r = m2;\n'
            '    else\n'
            '        l = m1;\n'
            '}\n'
            '\n'
            'Целочисленный тернарный поиск\n'
            'Если мы ищем на целых числах, то может быть проблема с условием в while\n'
            'Если мы оставляем условие (r - l > 1), то код может зациклиться\n'
            'Ведь если r - l == 2, то после итерации r и l останутся такими же, либо алгоритм проскочит разницу (l станет больше r)\n'
            'Мы считаем, что граница r не включается\n'
            'Тогда сделаем условие while (l < r - 2)\n'
            '\n'
            'В конце у нас два возможных значения: l и l + 1\n'
            'Просто выберем одно из них:\n'
            'if (f(l) > f(l + 1)) {\n'
            '    l++;\n'
            '}\n')


def pref_sum():
    return ('Префиксные суммы\n'
            '\n'
            'Префиксные суммы позволяют считать сумму (и не только) на всех отрезках (и не только)\n'
            '\n'
            'Создаётся массив, в котором записаны суммы на всех префиксах (по увеличению длины)\n'
            'Если поступает запрос на отрезок с l по r (0-индексация), то\n'
            'if (l == 0) {\n'
            '    ans = pref[r];\n'
            '}\n'
            'else {\n'
            '    ans = pref[r] - pref[l - 1];\n'
            '}\n'
            '\n'
            'Префиксные суммы могут быть n-мерными\n'
            'Двумерные префиксные суммы:\n'
            'vector<vector<ll>> pref(n, vector<ll>(m));\n'
            'for (int i = 0; i < n; i++) {\n'
            '    for (int j = 0; j < m; j++) {\n'
            '        pref[i][j] = a[i][j];\n'
            '        if (i > 0) {\n'
            '            pref[i][j] += pref[i - 1][j];\n'
            '        }\n'
            '        if (j > 0) {\n'
            '            pref[i][j] += pref[i][j - 1];\n'
            '        }\n'
            '        if (i > 0 && j > 0) {\n'
            '            pref[i][j] -= pref[i - 1][j - 1];\n'
            '        }\n'
            '    }\n'
            '}\n'
            'int l1, r1, l2, r2;\n'
            'cin >> l1 >> r1 >> l2 >> r2;\n'
            'll ans = pref[r1][r2];\n'
            'if (l1 > 0) {\n'
            '    ans -= pref[l1 - 1][r2];\n'
            '}\n'
            'if (l2 > 0) {\n'
            '    ans -= pref[r1][l2 - 1];\n'
            '}\n'
            'if (l1 > 0 && l2 > 0) {\n'
            '    ans += pref[l1 - 1][l2 - 1];\n'
            '}\n')


def sparse_table():
    return ('Sparse table (разреженная таблица)\n'
            '\n'
            'Sparse table - структура, позволяющая хранить и получать нужную информацию о всех отрезках массива\n'
            'Эта структура - двумерный массив, который хранит информацию о всех отрезках, длины которых равны степеням двойки\n'
            '\n'
            'таблица выглядит так:\n'
            '       степени\n'
            '    |0 1 2 3 4 5\n'
            '-----------------\n'
            'и 0 |             \n'
            'н 1 |  ч           \n'
            'д 2 |    и         \n'
            'е 3 |      с       \n'
            'к 4 |        л     \n'
            'с 5 |          а   \n'
            '\n'
            'Сверху - степени двойки, слева - индекс начала отрезка (индекс первого элемента отрезка)\n'
            '\n'
            'Функции, значения которых может хранить Sparse table должны обладать свойством идемпотентности: f(a, a) = a\n'
            'Типичная такая функция - min\n'
            'Сумма не является идемпотентной функцией\n'
            '\n'
            'int n;\n'
            'cin >> n;\n'
            'vector<int> a(n);\n'
            'cin >> a;\n'
            'vector<int> logs(n + 1);\n'
            'logs[1] = 0;\n'
            'for (int i = 2; i <= n; i++) {\n'
            '    logs[i] = logs[i / 2] + 1;\n'
            '}\n'
            'vector<vector<int>> sparse(logs[n] + 1, vector<int>(n));\n'
            'for (int i = 0; i < n; i++) {\n'
            '    sparse[0][i] = a[i];\n'
            '}\n'
            'for (int level = 1; (1 << level) <= n; level++) {\n'
            '    for (int i = 0; i + (1 << level) <= n; i++) {\n'
            '        sparse[level][i] = min(sparse[level - 1][i], sparse[level - 1][i + (1 << (level - 1))]);\n'
            '    }\n'
            '}\n'
            'int l, r;\n'
            'cin >> l >> r;\n'
            'l--;\n'
            'r--;\n'
            'int len = r - l + 1;\n'
            'int level = logs[len];\n'
            'int ans = min(sparse[level][l], sparse[level][r - (1 << level) + 1]);\n'
            'cout << ans << el;\n'
            '\n'
            'Sparse table - неизменяемая структура (для изменения элементов нужно перестраивать всю таблицу)\n')


def sqrt_decomposition():
    return ('Корневая декомпозиция\n'
            '\n'
            'Смысл декомпозиции - разбиение отрезка на блоки\n'
            'Тогда, когда мы получаем запрос, мы можем посчитать значения в блоках, которые полностью входят в отрезок, а на частичных блоках посчитать, просто пройдя по эти частям\n'
            'Блоки равны корню из длины массива\n'
            '\n'
            'Также корневая декомпозиция поддерживает изменения элементов\n'
            'Для этого используются отложенные изменения\n'
            '\n'
            'Минимум на [l, r]:\n'
            'struct Block {\n'
            '    vector<int> arr;\n'
            '    int minElement;\n'
            '    int len;\n'
            '    void build() {\n'
            '        len = arr.size();\n'
            '        minElement = arr[0];\n'
            '        for (int i = 1; i < len; i++) {\n'
            '            minElement = min(arr[i], minElement);\n'
            '        }\n'
            '    }\n'
            '    int fullQuery() {\n'
            '        return minElement;\n'
            '    }\n'
            '    int partQuery(int l, int r) {\n'
            '        int ans = arr[l];\n'
            '        for (int i = l + 1; i <= r; i++) {\n'
            '            ans = min(ans, arr[i]);\n'
            '        }\n'
            '        return ans;\n'
            '    }\n'
            '    void change(int i, int val) {\n'
            '        arr[i] = val;\n'
            '        build();\n'
            '    }\n'
            '};\n'
            'struct SQRT {\n'
            '    vector<Block> bl;\n'
            '    int bSize, len;\n'
            '    SQRT(const vector<int>& a) {\n'
            '        int n = a.size();\n'
            '        bSize = (int)sqrt(n);\n'
            '        len = 0;\n'
            '        for (int i = 0; i < n; i++) {\n'
            '            int b = i / bSize;\n'
            '            if (b == len) {\n'
            '                bl.push_back(Block());\n'
            '                len++;\n'
            '            }\n'
            '            bl[b].arr.push_back(a[i]);\n'
            '        }\n'
            '        for (int i = 0; i < len; i++) {\n'
            '            bl[i].build();\n'
            '        }\n'
            '    }\n'
            '    int ask(int l, int r) {\n'
            '        int posl = l / bSize, posr = r / bSize;\n'
            '        int posinl = l % bSize, posinr = r % bSize;\n'
            '        if (posl == posr) {\n'
            '            return bl[posl].partQuery(posinl, posinr);\n'
            '        }\n'
            '        int ans = INT_MAX;\n'
            '        if (posinl != 0) {\n'
            '            ans = min(ans, bl[posl].partQuery(posinl, bl[posl].len - 1));\n'
            '            posl++;\n'
            '        }\n'
            '        if (posinr != bl[posr].len - 1) {\n'
            '            ans = min(ans, bl[posr].partQuery(0, posinr));\n'
            '            posr--;\n'
            '        }\n'
            '        for (int i = posl; i <= posr; i++) {\n'
            '            ans = min(ans, bl[i].fullQuery());\n'
            '        }\n'
            '        return ans;\n'
            '    }\n'
            '    void change(int i, int val) {\n'
            '        int pos = i / bSize;\n'
            '        int posin = i % bSize;\n'
            '        //int posin = i - pos * bSize;\n'
            '        bl[pos].change(posin, val);\n'
            '    }\n'
            '};\n'
            '\n'
            'Сумма на [l, r] + изменения на [l1, r1]:\n'
            'struct Block {\n'
            '    vector<int> arr;\n'
            '    int summ;\n'
            '    bool has_set;\n'
            '    int set;\n'
            '    int len;\n'
            '    void build() {\n'
            '        len = arr.size();\n'
            '        has_set = false;\n'
            '        set = 0;\n'
            '        summ = 0;\n'
            '        for (int i: arr) {\n'
            '            summ += i;\n'
            '        }\n'
            '    }\n'
            '    void push() {\n'
            '        if (!has_set)\n'
            '            return;\n'
            '        for (int i = 0; i < len; i++) {\n'
            '            arr[i] = set;\n'
            '        }\n'
            '        has_set = false;\n'
            '        summ = len * set;\n'
            '        set = 0;\n'
            '    }\n'
            '    int partQuery(int l, int r) {\n'
            '        push();\n'
            '        int ans = 0;\n'
            '        for (int i = l; i <= r; i++) {\n'
            '            ans += arr[i];\n'
            '        }\n'
            '        return ans;\n'
            '    }\n'
            '    int fullQuery(int l, int r) {\n'
            '        if (has_set)\n'
            '            return len * set;\n'
            '        else\n'
            '            return summ;\n'
            '    }\n'
            '    void partSet(int l, int r, int val) {\n'
            '        push();\n'
            '        for (int i = l ; i < r; i++) {\n'
            '            summ -= arr[i];\n'
            '            arr[i] = val;\n'
            '            summ += val;\n'
            '        }\n'
            '    }\n'
            '    void fullSet(int val) {\n'
            '        has_set = true;\n'
            '        set = val;\n'
            '    }\n'
            '};\n'
            'struct SQRT {\n'
            '    vector<Block> bl;\n'
            '    int bSize, len;\n'
            '    SQRT(const vector<int>& a) {\n'
            '        int n = a.size();\n'
            '        bSize = (int)sqrt(n);\n'
            '        len = 0;\n'
            '        for (int i = 0; i < n; i++) {\n'
            '            int b = i / bSize;\n'
            '            if (b == len) {\n'
            '                bl.push_back(Block());\n'
            '                len++;\n'
            '            }\n'
            '            bl[b].arr.push_back(a[i]);\n'
            '        }\n'
            '        for (int i = 0; i < len; i++) {\n'
            '            bl[i].build();\n'
            '        }\n'
            '    }\n'
            '    int ask(int l, int r) {\n'
            '        int posl = l / bSize, posr = r / bSize;\n'
            '        int posinl = l % bSize, posinr = r % bSize;\n'
            '        if (posl == posr) {\n'
            '            return bl[posl].partQuery(posinl, posinr);\n'
            '        }\n'
            '        int ans = 0;\n'
            '        if (posinl != 0) {\n'
            '            ans += bl[posl].partQuery(posinl, bl[posl].len - 1);\n'
            '            posl++;\n'
            '        }\n'
            '        if (posinr != bl[posr].len - 1) {\n'
            '            ans += bl[posr].partQuery(0, posinr);\n'
            '            posr--;\n'
            '        }\n'
            '        for (int i = posl; i <= posr; i++) {\n'
            '            ans += bl[i].fullQuery();\n'
            '        }\n'
            '        return ans;\n'
            '    }\n'
            '    void change(int l, int r, int val) {\n'
            '        int posl = l / bSize, posr = r / bSize;\n'
            '        int posinl = l % bSize, posinr = r % bSize;\n'
            '        if (posl == posr) {\n'
            '            bl[posl].partSet(posinl, posinr, val);\n'
            '            return;\n'
            '        }\n'
            '        int ans = 0;\n'
            '        if (posinl != 0) {\n'
            '            bl[posl].partSet(posinl, bl[posl].len - 1, val);\n'
            '            posl++;\n'
            '        }\n'
            '        if (posinr != bl[posr].len - 1) {\n'
            '            bl[posr].partSet(0, posinr, val);\n'
            '            posr--;\n'
            '        }\n'
            '        for (int i = posl; i <= posr; i++) {\n'
            '            bl[i].fullSet(val);\n'
            '        }\n'
            '    }\n'
            '};\n'
            '\n'
            'Сколько на отрезке чисел из заданного диапазона + прибавление на отрезке:\n'
            'Для этого требуется хранить в каждом блоке отсортированный блок\n'
            'struct Block {\n'
            '    vector<int> arr, srt;\n'
            '    int add;\n'
            '    int len;\n'
            '    void build() {\n'
            '        len = arr.size();\n'
            '        add = 0;\n'
            '        srt = arr;\n'
            '        sort(srt.begin(), srt.end());\n'
            '    }\n'
            '    void push() {\n'
            '        for (int i = 0; i < len; i++) {\n'
            '            arr[i] += add;\n'
            '            srt[i] += add;\n'
            '        }\n'
            '        add = 0;\n'
            '    }\n'
            '    int partQuery(int l, int r, int numl, int numr) {\n'
            '        push();\n'
            '        int ans = 0;\n'
            '        for (int i = l; i <= r; i++) {\n'
            '            if (arr[i] >= numl && arr[i] <= numr) {\n'
            '                ans++;\n'
            '            }\n'
            '        }\n'
            '        return ans;\n'
            '    }\n'
            '    int fullQuery(int numl, int numr) {\n'
            '        return upper_bound(srt.begin(), srt.end(), numr) - lower_bound(srt.begin(), srt.end(), numl);\n'
            '    }\n'
            '    void partAdd(int l, int r, int val) {\n'
            '        push();\n'
            '        for (int i = l; i <= r; i++) {\n'
            '            arr[i] += val;\n'
            '        }\n'
            '        srt = arr;\n'
            '        sort(srt.begin(), srt.end());\n'
            '    }\n'
            '    void fullAdd(int val) {\n'
            '        add += val;\n'
            '    }\n'
            '};\n'
            'struct SQRT {\n'
            '    vector<Block> bl;\n'
            '    int bSize, len;\n'
            '    SQRT(const vector<int>& a) {\n'
            '        int n = a.size();\n'
            '        bSize = (int)sqrt(n);\n'
            '        len = 0;\n'
            '        for (int i = 0; i < n; i++) {\n'
            '            int b = i / bSize;\n'
            '            if (b == len) {\n'
            '                bl.push_back(Block());\n'
            '                len++;\n'
            '            }\n'
            '            bl[b].arr.push_back(a[i]);\n'
            '        }\n'
            '        for (int i = 0; i < len; i++) {\n'
            '            bl[i].build();\n'
            '        }\n'
            '    }\n'
            '    int ask(int l, int r, int numl, int numr) {\n'
            '        int posl = l / bSize, posr = r / bSize;\n'
            '        int posinl = l % bSize, posinr = r % bSize;\n'
            '        if (posl == posr) {\n'
            '            return bl[posl].partQuery(posinl, posinr, numl, numr);\n'
            '        }\n'
            '        int ans = 0;\n'
            '        if (posinl != 0) {\n'
            '            ans += bl[posl].partQuery(posinl, bl[posl].len - 1, numl, numr);\n'
            '            posl++;\n'
            '        }\n'
            '        if (posinr != bl[posr].len - 1) {\n'
            '            ans += bl[posr].partQuery(0, posinr, numl, numr);\n'
            '            posr--;\n'
            '        }\n'
            '        for (int i = posl; i <= posr; i++) {\n'
            '            ans += bl[i].fullQuery(numl, numr);\n'
            '        }\n'
            '        return ans;\n'
            '    }\n'
            '    void change(int l, int r, int val) {\n'
            '        int posl = l / bSize, posr = r / bSize;\n'
            '        int posinl = l % bSize, posinr = r % bSize;\n'
            '        if (posl == posr) {\n'
            '            bl[posl].partAdd(posinl, posinr, val);\n'
            '            return;\n'
            '        }\n'
            '        int ans = 0;\n'
            '        if (posinl != 0) {\n'
            '            bl[posl].partAdd(posinl, bl[posl].len - 1, val);\n'
            '            posl++;\n'
            '        }\n'
            '        if (posinr != bl[posr].len - 1) {\n'
            '            bl[posr].partAdd(0, posinr, val);\n'
            '            posr--;\n'
            '        }\n'
            '        for (int i = posl; i <= posr; i++) {\n'
            '            bl[i].fullAdd(val);\n'
            '        }\n'
            '    }\n'
            '};\n'
            '\n'
            'Может быть такая задача: посчитать какую-нибудь функцию на отрезке и добавить число на какую-либо позицию\n'
            'Первая часть решается просто\n'
            'Вторую часть можно решить, перебирая блоки по порядку, куда должен встать новый элемент\n'
            'Это делается за O(sqrt(N))\n'
            'Однако есть проблема "раздувания" блока\n'
            'Для этого можно разбивать блок, когда его длина становится 2 * sqrt(N)\n'
            'То же самое с удалением чисел (сливать, когда длина 0.5 * sqrt(N))\n'
            'Но для этого требуется хранить структуру в двусвязном списке, что не очень приятно\n'
            'Второе решение: перестраивать всю структуру каждые sqrt(N) запросов добавления элементов\n'
            '\n'
            'Задача: есть множество, поступают два вида запросов:\n'
            '1) Добавить число\n'
            '2) Найти кол-во чисел l <= a <= r\n'
            'При запросе 1 будем кидать число в какую-либо структуру (можно использовать обычный массив)\n'
            'Когда длина этой структуры становится больше sqrt(N) (N - сколько всего чисел добавится), то мы сортируем структуру и сливаем с множеством (merge)\n'
            'Саму структуру обнуляем и делаем дальше всё то же самое\n'
            'На второй запрос ответить просто - два бинпоиска\n'
            '\n'
            'Корневая оптимизация может применяться в графах\n'
            'Задача: дан граф, поступают два вида запросов:\n'
            '1) += x в вершине\n'
            '2) Посчитать сумму для всех соседей u\n'
            'Главная идея - разбить все вершины на тяжёлые и лёгкие\n'
            'Тяжёлая вершина - вершина, у которой степень >= sqrt(M)\n'
            'Лёгкая вершина - вершина, у которой степень < sqrt(N)\n'
            'Для запроса 1 делаем прибавление в вершине и проходим по всем тяжёлым соседям вершины u\n'
            'Для них мы обновляем ответ, для лёгких ответ не меняем\n'
            'Запрос 2:\n'
            'Если вершина лёгкая, то просто пройдём по вем соседям и посчитаем сумму\n'
            'Если вершина тяжёлая, то ответ для неё уже посчитан\n'
            '\n'
            'Задача: найти кол-во треугольников в неориентированном графе (циклов длины 3)\n'
            'Разобьём все вершины на тяжёлые и лёгкие (описано выше)\n'
            'Будем перебирать рёбра (у нас 3 вида рёбер: L - L, H - L, H - H)\n'
            'У нас есть 4 варианта треугольника:\n'
            '1) L - L - L\n'
            'Для этого случая переберём рёбра и для каждого ребра L(v) - L(v) пройдём по всем соседям v и соседям u\n'
            'Найдём кол-во всех общих соседей, которые L, и прибавим его к ответу\n'
            'В конце кол-во треугольников L - L - L нужно будет поделить на 3\n'
            '2) L - L - H\n'
            'То же самое (перебираем ребро L - L), только в конце не нужно делить\n'
            '3) L - H - H\n'
            'Будем перебирать ребро L - H\n'
            'Для вершины L переберём всех соседей\n'
            'Если сосед H, то нужно проверить, является ли он соседом для второго конца ребра\n'
            'Это можно сделать, храня матрицу смежности для всех H вершин (их не более sqrt(M), поэтому матрица не будет большой)\n'
            'В конце поделить на 2\n'
            '4) H - H - H\n'
            'Просто сделаем три вложенных цикла (проверять, соседи ли две H вершины, мы умеем)\n'
            'В конце поделить на 3\n')


def Mo():
    return ('Алгоритм Мо\n'
            '\n'
            'Смысл алгоритма состоит в заранее отсортированном списке запросов (поэтому только offline)\n'
            'От одного запроса алгоритм перетекает к другому прибавлениями и удалениями элементов на концах текущего отрезка\n'
            'Массив разделён на блоки (корень из длины массива)\n'
            '\n'
            'Мо для суммы на отрезке чисел, которые встречаются хотя бы 3 раза:\n'
            'struct Magic {\n'
            '    unordered_map<int, int> cnt;\n'
            '    int summ;\n'
            '    Magic(): summ(0) {}\n'
            '    int f() {\n'
            '        return summ;\n'
            '    }\n'
            '    void add(int x) {\n'
            '        cnt[x]++;\n'
            '        if (cnt[x] == 3)\n'
            '            summ += x;\n'
            '    }\n'
            '    void del(int x) {\n'
            '        cnt[x]--;\n'
            '        if (cnt[x] == 2)\n'
            '            summ -= x;\n'
            '    }\n'
            '};\n'
            '\n'
            'struct query {\n'
            '    int l, r, num;\n'
            '    query() {}\n'
            '    query(int l, int r, int num): l(l), r(r), num(num) {}\n'
            '};\n'
            '\n'
            'int K;\n'
            '\n'
            'bool operator <(const query& a, const query& b) {\n'
            '    if (a.l / K != b.l / K)\n'
            '        return a.l / K < b.l / K;\n'
            '    if ((a.l / K) % 2 == 0)\n'
            '        return a.r < b.r;\n'
            '    return a.r > b.r;\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    fastIO;\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    vector<int> a(n);\n'
            '    cin >> a;\n'
            '    K = (int)sqrt(n);\n'
            '    int Q;\n'
            '    cin >> Q;\n'
            '    vector<query> qr;\n'
            '    for (int i = 0; i < Q; i++) {\n'
            '        int l, r;\n'
            '        cin >> l >> r;\n'
            '        qr.emplace_back(l - 1, r - 1, i);\n'
            '    }\n'
            '    sort(qr.begin(), qr.end());\n'
            '    Magic m;\n'
            '    int l = 0, r = -1;\n'
            '    vector<int> ans(Q);\n'
            '    for (auto& q: qr) {\n'
            '        while (r < q.r) {\n'
            '            m.add(a[r + 1]);\n'
            '            r++;\n'
            '        }\n'
            '        while (l > q.l) {\n'
            '            m.add(a[l - 1]);\n'
            '            l--;\n'
            '        }\n'
            '        while (r > q.r) {\n'
            '            m.del(a[r]);\n'
            '            r--;\n'
            '        }\n'
            '        while (l < q.l) {\n'
            '            m.del(a[l]);\n'
            '            l++;\n'
            '        }\n'
            '        ans[q.num] = m.f();\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Мо для кол-во различных чисел на отрезке:\n'
            'template <class T> void uniq(vector<T>& a) {sort(a.begin(), a.end()); a.resize(unique(a.begin(), a.end()) - a.begin());}\n'
            '\n'
            'int block_size;\n'
            '\n'
            'struct query {\n'
            '    int l, r, num;\n'
            '    query() {}\n'
            '    query(int l_, int r_, int num_) {\n'
            '        l = l_;\n'
            '        r = r_;\n'
            '        num = num_;\n'
            '    }\n'
            '};\n'
            '\n'
            'bool operator<(const query& a, const query& b) {\n'
            '    if (a.l / block_size != b.l / block_size) {\n'
            '        return a.l / block_size < b.l / block_size;\n'
            '    }\n'
            '    if ((a.l / block_size) % 2 == 0) {\n'
            '        return a.r < b.r;\n'
            '    }\n'
            '    return a.r > b.r;\n'
            '}\n'
            '\n'
            'struct Mo {\n'
            '    int cnt[300000];\n'
            '    int res;\n'
            '    Mo() {\n'
            '        fill(cnt, cnt + 300000, 0);\n'
            '        res = 0;\n'
            '    }\n'
            '    int get_res() {\n'
            '        return res;\n'
            '    }\n'
            '    void add(int x) {\n'
            '        cnt[x]++;\n'
            '        if (cnt[x] == 1) {\n'
            '            res++;\n'
            '        }\n'
            '    }\n'
            '    void del(int x) {\n'
            '        cnt[x]--;\n'
            '        if (cnt[x] == 0) {\n'
            '            res--;\n'
            '        }\n'
            '    }\n'
            '};\n'
            '\n'
            'signed main() {\n'
            '    fastIO;\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    vector<int> a(n), v(n);\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        cin >> a[i];\n'
            '        v[i] = a[i];\n'
            '    }\n'
            '    uniq(v);\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        a[i] = (int)(lower_bound(all(v), a[i]) - v.begin());\n'
            '    }\n'
            '    int q;\n'
            '    cin >> q;\n'
            '    vector<int> ans(q);\n'
            '    vector<query> Q(q);\n'
            '    for (int i = 0; i < q; i++) {\n'
            '        int l, r;\n'
            '        cin >> l >> r;\n'
            '        Q[i] = query(l - 1, r - 1, i);\n'
            '    }\n'
            '    block_size = (int)sqrt(n);\n'
            '    Mo m;\n'
            '    stable_sort(all(Q));\n'
            '    int l = 0, r = -1;\n'
            '    for (int i = 0; i < q; i++) {\n'
            '        int to_l = Q[i].l;\n'
            '        int to_r = Q[i].r;\n'
            '        while (r < to_r) {\n'
            '            m.add(a[r + 1]);\n'
            '            r++;\n'
            '        }\n'
            '        while (l > to_l) {\n'
            '            m.add(a[l - 1]);\n'
            '            l--;\n'
            '        }\n'
            '        while (r > to_r) {\n'
            '            m.del(a[r]);\n'
            '            r--;\n'
            '        }\n'
            '        while (l < to_l) {\n'
            '            m.del(a[l]);\n'
            '            l++;\n'
            '        }\n'
            '        ans[Q[i].num] = m.get_res();\n'
            '    }\n'
            '    for (int& i: ans) {\n'
            '        cout << i << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n')


def Huffman():
    return ('Кодирование Хаффмана\n'
            '\n'
            'Код Хаффмана - алгоритм оптимального префиксного кодирования\n'
            '\n'
            'struct Node {\n'
            '    Node *l, *r;\n'
            '    bool is_leaf;\n'
            '    char c;\n'
            '    Node(): l(nullptr), r(nullptr), is_leaf(false) {}\n'
            '};\n'
            '\n'
            'void dfs(Node* v, unordered_map<char, string>& codes, string cur_code = "") {\n'
            '    if (v->is_leaf) {\n'
            '        codes[v->c] = cur_code;\n'
            '        return;\n'
            '    }\n'
            '    dfs(v->l, codes, cur_code + \'0\');\n'
            '    dfs(v->r, codes, cur_code + \'1\');\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    vector<int> freq(n);\n'
            '    vector<char> let(n);\n'
            '    cin >> freq;\n'
            '    cin >> let;\n'
            '    set<pair<int, Node*>> s;\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        Node* v = new Node();\n'
            '        v->is_leaf = true;\n'
            '        v->c = let[i];\n'
            '        s.insert({freq[i], v});\n'
            '    }\n'
            '    while (s.size() > 1) {\n'
            '        auto fi = *s.begin();\n'
            '        s.erase(s.begin());\n'
            '        auto se = *s.begin();\n'
            '        s.erase(s.begin());\n'
            '        Node* cur = new Node();\n'
            '        cur->l = fi.second;\n'
            '        cur->r = se.second;\n'
            '        s.insert({fi.first + se.first, cur});\n'
            '    }\n'
            '    Node* tree = s.begin()->second;\n'
            '    unordered_map<char, string> codes;\n'
            '    dfs(tree, codes);\n'
            '    for (auto& i: codes) {\n'
            '        cout << i.first << \' \' << i.second << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n')


def trie():
    return ('Бор (trie)\n'
            '\n'
            'Бор - это префиксное дерево, хранящее все префиксы нескольких слов\n'
            'Можно добавлять, удалять и искать строки\n'
            '\n'
            'Код:\n'
            'struct Node {\n'
            '    int cnt;\n'
            '    int sum;\n'
            '    vector<Node*> kids;\n'
            '    Node() {\n'
            '        cnt = 0;\n'
            '        sum = 0;\n'
            '        kids.resize(26, nullptr);\n'
            '    }\n'
            '};\n'
            'void add(Node* v, const string& s, int pos) {\n'
            '    if (pos == s.size()) {\n'
            '        v->cnt++;\n'
            '        v->sum++;\n'
            '        return;\n'
            '    }\n'
            '    v->sum++;\n'
            '    int kid = s[pos] - \'a\';\n'
            '    if (v->kids[kid] == nullptr) {\n'
            '        v->kids[kid] = new Node();\n'
            '    }\n'
            '    add(v->kids[kid], s, pos + 1);\n'
            '}\n'
            'bool del(Node* v, const string& s, int pos) {\n'
            '    if (pos == s.size()) {\n'
            '        if (v->cnt == 0) {\n'
            '            return false;\n'
            '        }\n'
            '        v->cnt--;\n'
            '        v->sum--;\n'
            '        return true;\n'
            '    }\n'
            '    int kid = s[pos] - \'a\';\n'
            '    if (v->kids[kid] == nullptr) {\n'
            '        return false;\n'
            '    }\n'
            '    bool res = del(v->kids[kid], s, pos + 1);\n'
            '    if (res) {\n'
            '         v->sum--;\n'
            '    }\n'
            '    if (v->kids[kid]->sum == 0) {\n'
            '        delete v->kids[kid];\n'
            '        v->kids[kid] = nullptr;\n'
            '    }\n'
            '    return res;\n'
            '}\n'
            'bool find(Node* v, const string& s, int pos) {\n'
            '    if (pos == s.size()) {\n'
            '        return v->cnt > 0;\n'
            '    }\n'
            '    int kid = s[pos] - \'a\';\n'
            '    if (v->kids[kid] == nullptr) {\n'
            '        return false;\n'
            '    }\n'
            '    return find(v->kids[kid], s, pos + 1);\n'
            '}\n'
            'signed main() {\n'
            '    Node* root = new Node();\n'
            '    string s;\n'
            '    cin >> s;\n'
            '    add(root, s, 0);\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'cnt - кол-во строк, заканчивающихся в вершине\n'
            'sum - размер поддерева вершины\n'
            '\n'
            'Существует битовый бор (вместо символов биты чисел)\n'
            'Он позволяет искать mex множества, осуществлять операции xor\n'
            'Для битового бора необходимо, чтобы все числа имели одинаковую длину (нужно дополнять их ведущими нулями до определённой длины)\n'
            'Битовым бором можно сравнивать числа (если где-то первое число пошло налево, а второе направо, то первое число меньше)\n'
            'Можно искать кол-во чисел меньше k. Для этого нужно посчитать сумму поддеревьев левых переходов (число k идёт направо => прибавим к ответу сумму левого перехода)\n'
            '\n'
            'Бором можно посчитать кол-во различных подстрок строки\n'
            'Для этого нужно положить в бор все суффиксы строки\n'
            'Ответ - кол-во вершин в боре\n')


def geometry():
    return ('Геометрия\n'
            '\n'
            'ТОЧКИ, ВЕКТОРА, ОТРЕЗКИ\n'
            'Точку проще всего хранить в структуре\n'
            'struct Point {\n'
            '    int x, y;\n'
            '    Point() {}\n'
            '    Point(int x_, int y_): x(x_), y(y_) {}\n'
            '};\n'
            '\n'
            'Вектор - это сдвиг по двум координатам, поэтому его можно хранить в той же структуре\n'
            'Для того, чтобы создать вектор, можно переопределить оператор -\n'
            'Point operator-(const Point& a, const Point& b) {\n'
            '    return Point(a.x - b.x, a.y - b.y);\n'
            '}\n'
            '\n'
            'Скалярное произведение\n'
            'Скалярное произведение: a.x * b.x + a.y * b.y = |a| * |b| * cos(a^b)\n'
            'int dP(const Point& a, const Point& b) { // скалярное\n'
            '    return a.x * b.x + a.y * b.y;\n'
            '}\n'
            '\n'
            'Векторное произведение\n'
            'Векторное произведение: a.x * b.y - a.y * b.x = |a| * |b| * sin(a^b)\n'
            'int cP(const Point& a, const Point& b) { // векторное\n'
            '    return a.x * b.y - a.y * b.x;\n'
            '}\n'
            '\n'
            'Нахождение угла:\n'
            'double angle(const Point& a, const Point& b) {\n'
            '    return atan2(cP(a, b), dP(a, b));\n'
            '}\n'
            '\n'
            'Сравнивать double - плохо, поэтому надо использовать функцию сравнения\n'
            'const double eps = 1e-6;\n'
            'bool equal(double a, double b) {\n'
            '    return abs(a - b) < eps;\n'
            '}\n'
            '\n'
            'Проверка, лежит ли точка внутри угла\n'
            'bool pointInAngle(const Point& a, const Point& o, const Point& b, const Point& p) {\n'
            '    double aop = abs(angle(a - o, p - o));\n'
            '    double pob = abs(angle(p - o, b - o));\n'
            '    double aob = abs(angle(a - o, b - o));\n'
            '    return equal(aop + pob, aob) || (o.x == p.x && o.y == p.y);\n'
            '}\n'
            '\n'
            'Длина вектора\n'
            'double len(const Point& a) {\n'
            '    return hypot(a.x, a.y);\n'
            '}\n'
            '\n'
            'Проверка, пересекаются ли два отрезка\n'
            'int dP(const Point& a, const Point& b) { // скалярное\n'
            '    return a.x * b.x + a.y * b.y;\n'
            '}\n'
            'int cP(const Point& a, const Point& b) { // векторное\n'
            '    return a.x * b.y - a.y * b.x;\n'
            '}\n'
            'bool inter(int a, int b, int c, int d) {\n'
            '    if (a > b) {\n'
            '        swap(a, b);\n'
            '    }\n'
            '    if (c > d) {\n'
            '        swap(c, d);\n'
            '    }\n'
            '    return max(a, c) <= min(b, d);\n'
            '}\n'
            'istream& operator>>(istream& in, Point& p) {\n'
            '    in >> p.x >> p.y;\n'
            '    return in;\n'
            '}\n'
            'signed main() {\n'
            '    Point a, b, c, d;\n'
            '    cin >> a >> b >> c >> d;\n'
            '    if (cP(b - a, c - a) * cP(b - a, d - a) <= 0 && cP(d - c, a - c) * cP(d - c, b - c) <= 0 && inter(a.x, b.x, c.x, d.x) && inter(a.y, b.y, c.y, d.y)) {\n'
            '        Yes;\n'
            '    }\n'
            '    else {\n'
            '        No;\n'
            '    }\n'
            '    return 0;\n'
            '}\n')


def convex_hull():
    # TODO: write convex_hull
    return


def treap():
    return ('Декартово дерево (treap, cartesian tree, дуча, дерамида, курево, пиво...)\n'
            '\n'
            'ДД - сбалансированное дерево поиска\n'
            'В каждой вершине ДД хранятся значения key и prior\n'
            'key - ключи (значения, по которым строится ДД)\n'
            'prior - приоритеты (значения, выбираемые случайно)\n'
            'По значениям key ДД - бинарное дерево поиска (l_key < m_key < r_key)\n'
            'По значениям prior ДД - бинарная куча (l_prior < m_prior > r_prior)\n'
            '\n'
            'ДД будет строиться на указателях, поэтому нужна структура вершины Node\n'
            '\n'
            'ДД может выполнять операции:\n'
            '* find(x)   - проверка, есть ли x в дереве\n'
            '* add(x)    - добавление элемента x в дерево\n'
            '* remove(x) - удаление элемента x из дерева\n'
            '* next(x)   - наименьшей элемент, который >x\n'
            '* prev(x)   - наибольший элемент, который <x\n'
            '* kth(k)    - k-ый по величине элемент (для этого потребуется хранение размеров поддеревьев - см. далее)\n'
            '... (другие операции, например, RSQ/RMQ)\n'
            '\n'
            'Но все операции будут основываться на двух: merge и split\n'
            'merge сливает два ДД в одно (предполагается, что их можно слить - есть такой ключ, что левое дерево меньше этого ключа, а правое больше)\n'
            'split(key) делит ДД на два по ключу\n'
            '\n'
            'Реализация ДД (явный ключ):\n'
            'static random_device rd;\n'
            'static mt19937 rng{rd()};\n'
            '\n'
            'int get_rand() {\n'
            '    static uniform_int_distribution<int> uid(0, 2e9 + 7);\n'
            '    return uid(rng);\n'
            '}\n'
            '\n'
            'struct Node {\n'
            '    int key;\n'
            '    int prior;\n'
            '    Node* l;\n'
            '    Node* r;\n'
            '    Node() {\n'
            '        l = nullptr;\n'
            '        r = nullptr;\n'
            '    }\n'
            '    Node(int key_) {\n'
            '        key = key_;\n'
            '        prior = get_rand();\n'
            '        l = nullptr;\n'
            '        r = nullptr;\n'
            '    }\n'
            '};\n'
            '\n'
            'pair<Node*, Node*> split(Node* v, int x) {\n'
            '    if (v == nullptr) {\n'
            '        return {nullptr, nullptr};\n'
            '    }\n'
            '    if (v->key < x) {\n'
            '        pair<Node*, Node*> p = split(v->r, x);\n'
            '        v->r = p.first;\n'
            '        return {v, p.second};\n'
            '    }\n'
            '    pair<Node*, Node*> p = split(v->l, x);\n'
            '    v->l = p.second;\n'
            '    return {p.first, v};\n'
            '}\n'
            '\n'
            'Node* merge(Node* v1, Node* v2) {\n'
            '    if (v1 == nullptr) {\n'
            '        return v2;\n'
            '    }\n'
            '    if (v2 == nullptr) {\n'
            '        return v1;\n'
            '    }\n'
            '    if (v1->prior > v2->prior) {\n'
            '        v1->r = merge(v1->r, v2);\n'
            '        return v1;\n'
            '    }\n'
            '    v2->l = merge(v1, v2->l);\n'
            '    return v2;\n'
            '}\n'
            '\n'
            'Node* find(Node* v, int x) {\n'
            '    if (v == nullptr || v->key == x) {\n'
            '        return v;\n'
            '    }\n'
            '    if (x < v->key) {\n'
            '        return find(v->l, x);\n'
            '    }\n'
            '    return find(v->r, x);\n'
            '}\n'
            '\n'
            'Node* add(Node* v, Node* x) {\n'
            '    if (v == nullptr) {\n'
            '        v = x;\n'
            '        return v;\n'
            '    }\n'
            '    if (x->prior > v->prior) {\n'
            '        pair<Node*, Node*> p = split(v, x->key);\n'
            '        x->l = p.first;\n'
            '        x->r = p.second;\n'
            '        return x;\n'
            '    }\n'
            '    if (x->key < v->key) {\n'
            '        v->l = add(v->l, x);\n'
            '    }\n'
            '    else {\n'
            '        v->r = add(v->r, x);\n'
            '    }\n'
            '    return v;\n'
            '}\n'
            '\n'
            'Node* remove(Node* v, int x) {\n'
            '    if (v == nullptr) {\n'
            '        return v;\n'
            '    }\n'
            '    if (v->key == x) {\n'
            '        return merge(v->l, v->r);\n'
            '    }\n'
            '    if (x < v->key) {\n'
            '        v->l = remove(v->l, x);\n'
            '    }\n'
            '    else {\n'
            '        v->r = remove(v->r, x);\n'
            '    }\n'
            '    return v;\n'
            '}\n'
            '\n'
            'Node* prev(Node* v, int x) {\n'
            '    Node* cur = v;\n'
            '    Node* succ = nullptr;\n'
            '    while (cur != nullptr) {\n'
            '        if (cur->key < x) {\n'
            '            succ = cur;\n'
            '            cur = cur->r;\n'
            '        }\n'
            '        else {\n'
            '            cur = cur->l;\n'
            '        }\n'
            '    }\n'
            '    return succ;\n'
            '}\n'
            '\n'
            'Node* next(Node* v, int x) {\n'
            '    Node* cur = v;\n'
            '    Node* succ = nullptr;\n'
            '    while (cur != nullptr) {\n'
            '        if (cur->key > x) {\n'
            '            succ = cur;\n'
            '            cur = cur->l;\n'
            '        }\n'
            '        else {\n'
            '            cur = cur->r;\n'
            '        }\n'
            '    }\n'
            '    return succ;\n'
            '}\n'
            '\n'
            'В основной части программы сначала нужно сделать Node* root = nullptr\n'
            '\n'
            'Строить ДД можно просто последовательным добавлением элементов\n'
            'Но если все ключи известны в начале, то можно построить ДД за O(n)\n'
            'Для этого можно отсортировать все ключи. Тогда следующий элемент будет либо добавлен в конец самой правой ветви, либо разделит её на две части (это делается при помощи stack)\n'
            'void build(vector<Node*>& a) {\n'
            '    Node* root = a[0];\n'
            '    int n = a.size();\n'
            '    stack<Node*> s;\n'
            '    s.push(root);\n'
            '    for (int i = 1; i < n; i++) {\n'
            '        Node* v = a[i];\n'
            '        while (!s.empty() && s.top()->prior > v->prior) {\n'
            '            s.pop();\n'
            '        }\n'
            '        if (s.empty()) {\n'
            '            v->l = root;\n'
            '            root = v;\n'
            '            s.push(root);\n'
            '        }\n'
            '        else {\n'
            '            Node* top = s.top();\n'
            '            v->l = top->r;\n'
            '            top->r = v;\n'
            '            s.push(top);\n'
            '            s.push(v);\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'В основном, запросы выполняются по следующему принципу:\n'
            '1. Разбить дерево по правой границе\n'
            '2. Разбить первую часть по левой границе запроса\n'
            '3. Найти ответ на средней части\n'
            '4. Слить всё обратно\n'
            '\n'
            'Пример для RSQ(x, y) - сумма чисел в диапазоне от x до y (конечно, на отсортированном массиве):\n'
            'll RSQ(Node* v, int l, int r) {\n'
            '    pair<Node*, Node*> p1 = split(v, l);\n'
            '    pair<Node*, Node*> p2 = split(p1.second, r + 1);\n'
            '    ll res = get_sum(p2.first);\n'
            '    p1.second = merge(p2.first, p2.second);\n'
            '    merge(p1.first, p1.second);\n'
            '    return res;\n'
            '}\n'
            '\n'
            'Хранение размеров поддеревьев добавляет возможность поиска k по величине элемента (и множество возможностей для ДД по неявному ключу)\n'
            'Для этого нужны функции update и get_sz\n'
            'update нужно вызывать после каждого изменения вершины\n'
            'int get_sz(Node* v) {\n'
            '    if (v == nullptr) {\n'
            '        return 0;\n'
            '    }\n'
            '    return v->sz;\n'
            '}\n'
            '\n'
            'void update(Node* v) {\n'
            '    if (v != nullptr) {\n'
            '        v->sz = get_sz(v->l) + get_sz(v->r) + 1;\n'
            '    }\n'
            '}\n'
            '\n'
            '// 1-индексация\n'
            'Node* kth(Node* v, int k) {\n'
            '    if (v == nullptr) {\n'
            '        return nullptr;\n'
            '    }\n'
            '    if (get_sz(v->l) + 1 == k) {\n'
            '        return v;\n'
            '    }\n'
            '    if (get_sz(v->l) + 1 > k) {\n'
            '        return kth(v->l, k);\n'
            '    }\n'
            '    return kth(v->r, k - get_sz(v->l) - 1);\n'
            '}\n'
            '\n'
            '// поиск индекса элемента по его ключу\n'
            'int find_index(Node* v, int x, int ind) {\n'
            '    if (v == nullptr) {\n'
            '        return -1;\n'
            '    }\n'
            '    if (v->key == x) {\n'
            '        return ind + get_sz(v->l);\n'
            '    }\n'
            '    if (x < v->key) {\n'
            '        return find_index(v->l, x, ind);\n'
            '    }\n'
            '    return find_index(v->r, x, ind + get_sz(v->l) + 1);\n'
            '}\n'
            '\n'
            'Главное: если мы идём в левого сына, k остаётся прежним\n'
            '         если мы идём в правого сына, то из k вычитается get_sz(v->l) + 1 (величина левого сына + текущая вершина)\n'
            '\n'
            'ДД по неявному ключу см. в implicit_treap\n')


def implicit_treap():
    return ('Декартово дерево по неявному ключу\n'
            '\n'
            'Смысл ДД по неявному ключу - отсутствие ключей в вершинах\n'
            'Для получения значений используются размеры поддеревьев\n'
            '\n'
            'Такая структура позволяет хранить любой массив (не только отсортированный, как ДД по явному ключу)\n'
            '\n'
            'split теперь будет отрезать первые k элементов\n'
            'merge не изменится, т.к. в его коде никак не участвуют ключи\n'
            '\n'
            'Теперь можно считать все функции, которые считает ДО (RSQ, RMQ...)\n'
            'Считать можно двумя способами:\n'
            '1. Разрезать, найти, склеить - простой способ, но может работать дольше, чем 2 способ\n'
            '2. Запрос ДО (можно написать такой же запрос, как для ДО)\n'
            'Отличие от ДО во втором способе - значения в ДД не только в листьях, но и в узлах, поэтому нужно добавлять значение в узле в ответ\n'
            '\n'
            'Код предполагает, что для 1 способа в функцию передаются исходные значения l и r ([l, r], l и r в 1-индексации)\n'
            'Во втором способе предполагается, что в функцию передаётся полуинтервал ([l, r), l и r в 0-индексации)\n'
            '\n'
            'Для примера реализация RMQ с добавлением элемента в массив после элемента k:\n'
            'static random_device rd;\n'
            'static mt19937 rng{rd()};\n'
            '\n'
            'int get_rand() {\n'
            '    static uniform_int_distribution<int> uid(0, 2e9 + 7);\n'
            '    return uid(rng);\n'
            '}\n'
            '\n'
            'struct Node {\n'
            '    int val;\n'
            '    int prior;\n'
            '    int sz;\n'
            '    int min;\n'
            '    Node* l;\n'
            '    Node* r;\n'
            '    Node() {\n'
            '        sz = 0;\n'
            '        min = 2e9;\n'
            '        l = nullptr;\n'
            '        r = nullptr;\n'
            '    }\n'
            '    Node(int val_) {\n'
            '        val = val_;\n'
            '        prior = get_rand();\n'
            '        sz = 1;\n'
            '        min = val_;\n'
            '        l = nullptr;\n'
            '        r = nullptr;\n'
            '    }\n'
            '};\n'
            '\n'
            'int get_sz(Node* v) {\n'
            '    if (v == nullptr) {\n'
            '        return 0;\n'
            '    }\n'
            '    return v->sz;\n'
            '}\n'
            '\n'
            'int get_min(Node* v) {\n'
            '    if (v == nullptr) {\n'
            '        return 2e9;\n'
            '    }\n'
            '    return v->min;\n'
            '}\n'
            '\n'
            'void update(Node* v) {\n'
            '    if (v != nullptr) {\n'
            '        v->sz = get_sz(v->l) + get_sz(v->r) + 1;\n'
            '        v->min = min({v->val, get_min(v->l), get_min(v->r)});\n'
            '    }\n'
            '}\n'
            '\n'
            'pair<Node*, Node*> split(Node* v, int k) {\n'
            '    if (v == nullptr) {\n'
            '        return {nullptr, nullptr};\n'
            '    }\n'
            '    if (k <= get_sz(v->l)) {\n'
            '        pair<Node*, Node*> p = split(v->l, k);\n'
            '        v->l = p.second;\n'
            '        update(v);\n'
            '        return {p.first, v};\n'
            '    }\n'
            '    pair<Node*, Node*> p = split(v->r, k - get_sz(v->l) - 1);\n'
            '    v->r = p.first;\n'
            '    update(v);\n'
            '    return {v, p.second};\n'
            '}\n'
            '\n'
            '// merge остаётся таким же\n'
            'Node* merge(Node* v1, Node* v2) {\n'
            '    if (v1 == nullptr) {\n'
            '        return v2;\n'
            '    }\n'
            '    if (v2 == nullptr) {\n'
            '        return v1;\n'
            '    }\n'
            '    if (v1->prior > v2->prior) {\n'
            '        v1->r = merge(v1->r, v2);\n'
            '        update(v1);\n'
            '        return v1;\n'
            '    }\n'
            '    v2->l = merge(v1, v2->l);\n'
            '    update(v2);\n'
            '    return v2;\n'
            '}\n'
            '\n'
            '// медленно\n'
            'int RMQ(Node* v, int l, int r) {\n'
            '    pair<Node*, Node*> p1 = split(v, r);\n'
            '    pair<Node*, Node*> p2 = split(p1.first, l - 1);\n'
            '    int res = p2.second->min;\n'
            '    p1.first = merge(p2.first, p2.second);\n'
            '    merge(p1.first, p1.second);\n'
            '    return res;\n'
            '}\n'
            '\n'
            '// быстрее\n'
            'int RMQ2(Node* v, int l, int r, int askl, int askr) {\n'
            '    if (v == nullptr) {\n'
            '        return 2e9;\n'
            '    }\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return 2e9;\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        return v->min;\n'
            '    }\n'
            '    int l_sz = get_sz(v->l);\n'
            '    int one = (l_sz + l >= askl && l + l_sz < askr ? v->val : 2e9);\n'
            '    return min({RMQ2(v->l, l, l + l_sz, askl, askr), RMQ2(v->r, l + l_sz + 1, r, askl, askr), one});\n'
            '}\n'
            '\n'
            'Node* add(Node* v, Node* x, int k) {\n'
            '    if (v == nullptr) {\n'
            '        v = x;\n'
            '        update(v);\n'
            '        return v;\n'
            '    }\n'
            '    if (x->prior > v->prior) {\n'
            '        pair<Node*, Node*> p = split(v, k);\n'
            '        x->l = p.first;\n'
            '        x->r = p.second;\n'
            '        update(x);\n'
            '        return x;\n'
            '    }\n'
            '    if (get_sz(v->l) < k) {\n'
            '        v->r = add(v->r, x, k - get_sz(v->l) - 1);\n'
            '    }\n'
            '    else {\n'
            '        v->l = add(v->l, x, k);\n'
            '    }\n'
            '    update(v);\n'
            '    return v;\n'
            '}\n'
            '\n'
            'Node* remove(Node* v, int k) {\n'
            '    if (v == nullptr) {\n'
            '        return v;\n'
            '    }\n'
            '    if (k == get_sz(v->l)) {\n'
            '        return merge(v->l, v->r);\n'
            '    }\n'
            '    if (get_sz(v->l) < k) {\n'
            '        v->r = remove(v->r, k - get_sz(v->l) - 1);\n'
            '    }\n'
            '    else {\n'
            '        v->l = remove(v->l, k);\n'
            '    }\n'
            '    update(v);\n'
            '    return v;\n'
            '}\n'
            '\n'
            'ДД поддерживает и отложенные операции (массовые операции)\n'
            'Для примера код задачи о перевороте отрезка и поиска минимума на отрезке:\n'
            'static random_device rd;\n'
            'static mt19937 rng{rd()};\n'
            '\n'
            'int get_rand() {\n'
            '    static uniform_int_distribution<int> uid(0, 2e9 + 7);\n'
            '    return uid(rng);\n'
            '}\n'
            '\n'
            'struct Node {\n'
            '    int val;\n'
            '    int min;\n'
            '    bool rev;\n'
            '    int prior;\n'
            '    int sz;\n'
            '    Node* l;\n'
            '    Node* r;\n'
            '    Node(int val_) {\n'
            '        val = val_;\n'
            '        prior = get_rand();\n'
            '        sz = 1;\n'
            '        rev = false;\n'
            '        min = val_;\n'
            '        l = nullptr;\n'
            '        r = nullptr;\n'
            '    }\n'
            '};\n'
            '\n'
            'int get_sz(Node* v) {\n'
            '    if (v == nullptr) {\n'
            '        return 0;\n'
            '    }\n'
            '    return v->sz;\n'
            '}\n'
            '\n'
            'int get_min(Node* v) {\n'
            '    if (v == nullptr) {\n'
            '        return 2e9;\n'
            '    }\n'
            '    return v->min;\n'
            '}\n'
            '\n'
            'void update(Node* v) {\n'
            '    if (v != nullptr) {\n'
            '        v->sz = get_sz(v->l) + get_sz(v->r) + 1;\n'
            '        v->min = min({v->val, get_min(v->l), get_min(v->r)});\n'
            '    }\n'
            '}\n'
            '\n'
            'void push(Node* v) {\n'
            '    if (v == nullptr || !v->rev) {\n'
            '        return;\n'
            '    }\n'
            '    swap(v->l, v->r);\n'
            '    v->rev = false;\n'
            '    if (v->l != nullptr) {\n'
            '        v->l->rev ^= true;\n'
            '    }\n'
            '    if (v->r != nullptr) {\n'
            '        v->r->rev ^= true;\n'
            '    }\n'
            '}\n'
            '\n'
            'pair<Node*, Node*> split(Node* v, int k) {\n'
            '    push(v);\n'
            '    if (v == nullptr) {\n'
            '        return {nullptr, nullptr};\n'
            '    }\n'
            '    if (get_sz(v->l) < k) {\n'
            '        pair<Node*, Node*> p = split(v->r, k - get_sz(v->l) - 1);\n'
            '        v->r = p.first;\n'
            '        update(v);\n'
            '        return {v, p.second};\n'
            '    }\n'
            '    pair<Node*, Node*> p = split(v->l, k);\n'
            '    v->l = p.second;\n'
            '    update(v);\n'
            '    return {p.first, v};\n'
            '}\n'
            '\n'
            'Node* merge(Node* v1, Node* v2) {\n'
            '    push(v1);\n'
            '    push(v2);\n'
            '    if (v1 == nullptr) {\n'
            '        return v2;\n'
            '    }\n'
            '    if (v2 == nullptr) {\n'
            '        return v1;\n'
            '    }\n'
            '    if (v1->prior > v2->prior) {\n'
            '        v1->r = merge(v1->r, v2);\n'
            '        update(v1);\n'
            '        return v1;\n'
            '    }\n'
            '    v2->l = merge(v1, v2->l);\n'
            '    update(v2);\n'
            '    return v2;\n'
            '}\n'
            '\n'
            'Node* add(Node* v, Node* x, int k) {\n'
            '    if (v == nullptr) {\n'
            '        v = x;\n'
            '        update(v);\n'
            '        return v;\n'
            '    }\n'
            '    if (x->prior > v->prior) {\n'
            '        pair<Node*, Node*> p = split(v, k);\n'
            '        x->l = p.first;\n'
            '        x->r = p.second;\n'
            '        update(x);\n'
            '        return x;\n'
            '    }\n'
            '    if (get_sz(v->l) < k) {\n'
            '        v->r = add(v->r, x, k - get_sz(v->l) - 1);\n'
            '    }\n'
            '    else {\n'
            '        v->l = add(v->l, x, k);\n'
            '    }\n'
            '    update(v);\n'
            '    return v;\n'
            '}\n'
            '\n'
            'void reverse(Node* v, int l, int r) {\n'
            '    pair<Node*, Node*> p1 = split(v, r);\n'
            '    pair<Node*, Node*> p2 = split(p1.first, l - 1);\n'
            '    p2.second->rev ^= true;\n'
            '    p1.first = merge(p2.first, p2.second);\n'
            '    merge(p1.first, p1.second);\n'
            '}\n'
            '\n'
            'int RMQ(Node* v, int l, int r) {\n'
            '    pair<Node*, Node*> p1 = split(v, r);\n'
            '    pair<Node*, Node*> p2 = split(p1.first, l - 1);\n'
            '    int res = p2.second->min;\n'
            '    p1.first = merge(p2.first, p2.second);\n'
            '    merge(p1.first, p1.second);\n'
            '    return res;\n'
            '}\n')


def mergesort_tree():
    return ('Дерево mergesort\n'
            '\n'
            'Дерево mergesort - ДО, в каждой вершине которого хранится отсортированный подмассив\n'
            '\n'
            'Такая структура позволяет решать задачу о нахождении кол-ва чисел в диапазоне [x, y] на отрезке [l, r]\n'
            'Если есть отсортированный массив, то такая задача решается двумя бинпоисками\n'
            '\n'
            'Вершины дерева сливаются, как в сортировке слиянием\n'
            '\n'
            'Код:\n'
            'struct Node {\n'
            '    vector<int> a;\n'
            '    Node() {}\n'
            '};\n'
            '\n'
            'vector<Node> t;\n'
            'vector<int> in;\n'
            '\n'
            'void build(int v, int l, int r) {\n'
            '    if (r - l == 1) {\n'
            '        t[v].a.push_back(in[l]);\n'
            '        return;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    build(v * 2 + 1, l, m);\n'
            '    build(v * 2 + 2, m, r);\n'
            '    t[v].a.resize(t[v * 2 + 1].a.size() + t[v * 2 + 2].a.size());\n'
            '    merge(t[v * 2 + 1].a.begin(), t[v * 2 + 1].a.end(), t[v * 2 + 2].a.begin(), t[v * 2 + 2].a.end(), t[v].a.begin());\n'
            '}\n'
            '\n'
            'int ask(int v, int l, int r, int askl, int askr, int x, int y) {\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return 0;\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        int first = lower_bound(t[v].a.begin(), t[v].a.end(), x) - t[v].a.begin();\n'
            '        int last = upper_bound(t[v].a.begin(), t[v].a.end(), y) - t[v].a.begin();\n'
            '        return last - first;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    return ask(v * 2 + 1, l, m, askl, askr, x, y) + ask(v * 2 + 2, m, r, askl, askr, x, y);\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n, m;\n'
            '    cin >> n >> m;\n'
            '    in.resize(n);\n'
            '    t.resize(4 * n);\n'
            '    cin >> in;\n'
            '    build(0, 0, n);\n'
            '    REP(m) {\n'
            '        int l, r, x, y;\n'
            '        cin >> l >> r >> x >> y;\n'
            '        cout << ask(0, 0, n, l - 1, r, x, y) << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Если также поступают запросы об изменении элемента, то в каждой вершине нужно хранить не массив, а декартово дерево\n'
            'Это декартово дерево должно поддерживать split как по ключу, так и по кол-ву отрезаемых элементов (чтобы изменить значение одного элемента)\n'
            '\n'
            'При помощи дерева mergesort можно решить задачу о нахождении кол-ва различных чисел на отрезке массива\n'
            'Для этого сначала нужно создать массив Prev\n'
            'Prev[i] - такой индекс j, что i < j (j максимально), и a[i] == a[j] (если это первое вхождение, то Prev[i] = -1)\n'
            'Заметим, что кол-во различных чисел на отрезке будет равно кол-ву значений Prev[i] (l <= i <= r), которые меньше, чем l (до таких элементов в отрезке нет таких же)\n'
            'На такие запросы можно отвечать, построив дерево mergesort по массиву Prev\n'
            'struct Node {\n'
            '    vector<int> a;\n'
            '    Node() {}\n'
            '};\n'
            '\n'
            'vector<int> Prev;\n'
            'vector<Node> t;\n'
            '\n'
            'void build(int v, int l, int r) {\n'
            '    if (r - l == 1) {\n'
            '        t[v].a = {Prev[l]};\n'
            '        return;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    build(v * 2 + 1, l, m);\n'
            '    build(v * 2 + 2, m, r);\n'
            '    t[v].a.resize(t[v * 2 + 1].a.size() + t[v * 2 + 2].a.size());\n'
            '    merge(t[v * 2 + 1].a.begin(), t[v * 2 + 1].a.end(), t[v * 2 + 2].a.begin(), t[v * 2 + 2].a.end(), t[v].a.begin());\n'
            '}\n'
            '\n'
            'int ask(int v, int l, int r, int askl, int askr) {\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return 0;\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        int firstNo = lower_bound(t[v].a.begin(), t[v].a.end(), askl) - t[v].a.begin();\n'
            '        return firstNo;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    return ask(v * 2 + 1, l, m, askl, askr) + ask(v * 2 + 2, m, r, askl, askr);\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    fastIO;\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    vector<int> in(n);\n'
            '    t.resize(4 * n);\n'
            '    Prev.resize(n, -1);\n'
            '    cin >> in;\n'
            '    unordered_map<int, int> d;\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        if (d[in[i]] == 0) {\n'
            '            Prev[i] = -1;\n'
            '        }\n'
            '        else {\n'
            '            Prev[i] = d[in[i]] - 1;\n'
            '        }\n'
            '        d[in[i]] = i + 1;\n'
            '    }\n'
            '    build(0, 0, n);\n'
            '    int m;\n'
            '    cin >> m;\n'
            '    REP(m) {\n'
            '        int l, r;\n'
            '        cin >> l >> r;\n'
            '        cout << ask(0, 0, n, l - 1, r) << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Быстрее эта задача решается при помощи алгоритма Мо (см. Mo)\n')


def Fenwick():
    return ('Дерево Фенвика (Bit Indexed Tree)\n'
            '\n'
            'Дерево Фенвика - структура, которая позволяет решать задачу о сумме на отрезке с изменением элемента\n'
            'Дерево Фенвика пишется быстрее, чем ДО, и занимает меньше памяти\n'
            '\n'
            'Запрос суммы и запрос изменения работает за O(logn)\n'
            '\n'
            'Каждый элемент массива дерева хранит сумму на каком-то отрезке (этот отрезок заканчивается в этом элементе)\n'
            'Ответ на запрос получается из разности сумм на двух префиксах\n'
            'Сумма на префиксе получается из сумм на нескольких отрезках\n'
            '\n'
            'Переход от текущего конца отрезка к предыдущему - i & (i + 1) - 1\n'
            'Переход от текущего конца отрезка к следующему - i | (i + 1)\n'
            '\n'
            'Изменение элемента - это изменение всех отрезков, в которых лежит этот элемент\n'
            'Важно, что изменение - это не операция присваивания, а операция прибавления (можно прибавлять разность нового и старого значения)\n'
            '\n'
            'Дерево Фенвика можно строить за O(nlogn) (просто изменить каждый элемент) и за O(n)\n'
            'Для построения за O(n) нужно пройти по массиву с начала и прибавить к концам отрезков значения\n'
            '\n'
            'Код:\n'
            'int n;\n'
            'vector<ll> t;\n'
            '\n'
            'void change(int i, ll delta) {\n'
            '    for (int pos = i; pos < n; pos = pos | (pos + 1)) {\n'
            '        t[pos] += delta;\n'
            '    }\n'
            '}\n'
            '\n'
            'll ask(int i) {\n'
            '    ll res = 0;\n'
            '    for (int pos = i; pos >= 0; pos = (pos & (pos + 1)) - 1) {\n'
            '        res += t[pos];\n'
            '    }\n'
            '    return res;\n'
            '}\n'
            '\n'
            'll ask(int l, int r) {\n'
            '    return ask(r) - (l == 0 ? 0 : ask(l - 1));\n'
            '}\n'
            '\n'
            'void build(const vector<ll>& a) {\n'
            '    t = a;\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        int j = i | (i + 1);\n'
            '        if (j < n) {\n'
            '            t[j] += t[i];\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    cin >> n;\n'
            '    vector<ll> a(n);\n'
            '    cin >> a;\n'
            '    build(a);\n'
            '    int q;\n'
            '    cin >> q;\n'
            '    REP(q) {\n'
            '        char mode;\n'
            '        cin >> mode;\n'
            '        if (mode == \'s\') {\n'
            '            int l, r;\n'
            '            cin >> l >> r;\n'
            '            cout << ask(l - 1, r - 1) << \' \';\n'
            '        }\n'
            '        else {\n'
            '            int pos;\n'
            '            ll nval;\n'
            '            cin >> pos >> nval;\n'
            '            change(pos - 1, nval - a[pos - 1]);\n'
            '            a[pos - 1] = nval;\n'
            '        }\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Дерево Фенвика обобщается на многомерные случаи\n'
            'Двумерное дерево Фенвика (поиск суммы на прямоугольнике с изменением элемента):\n'
            'int n, m;\n'
            'vector<vector<ll>> t;\n'
            '\n'
            'll ask(int x, int y) {\n'
            '    ll res = 0;\n'
            '    for (int i = x; i >= 0; i = (i & (i + 1)) - 1) {\n'
            '        for (int j = y; j >= 0; j = (j & (j + 1)) - 1) {\n'
            '            res += t[i][j];\n'
            '        }\n'
            '    }\n'
            '    return res;\n'
            '}\n'
            '\n'
            'll ask(int x1, int y1, int x2, int y2) {\n'
            '    ll res = ask(x2, y2);\n'
            '    if (x1 > 0) {\n'
            '        res -= ask(x1 - 1, y2);\n'
            '    }\n'
            '    if (y1 > 0) {\n'
            '        res -= ask(x2, y1 - 1);\n'
            '    }\n'
            '    if (x1 > 0 && y1 > 0) {\n'
            '        res += ask(x1 - 1, y1 - 1);\n'
            '    }\n'
            '    return res;\n'
            '}\n'
            '\n'
            'void change(int x, int y, ll delta) {\n'
            '    for (int i = x; i < n; i = (i | (i + 1))) {\n'
            '        for (int j = y; j < m; j = (j | (j + 1))) {\n'
            '            t[i][j] += delta;\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'void build(const vector<vector<ll>>& a) {\n'
            '    t.resize(n, vector<ll>(m, 0));\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        for (int j = 0; j < m; j++) {\n'
            '            change(i, j, a[i][j]);\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    fastIO;\n'
            '    cin >> n >> m;\n'
            '    vector<vector<ll>> a(n, vector<ll>(m));\n'
            '    cin >> a;\n'
            '    build(a);\n'
            '    int q;\n'
            '    cin >> q;\n'
            '    REP(q) {\n'
            '        char mode;\n'
            '        cin >> mode;\n'
            '        if (mode == \'s\') {\n'
            '            int x1, y1, x2, y2;\n'
            '            cin >> x1 >> y1 >> x2 >> y2;\n'
            '            cout << ask(x1 - 1, y1 - 1, x2 - 1, y2 - 1) << el;\n'
            '        }\n'
            '        else {\n'
            '            int x, y;\n'
            '            ll nval;\n'
            '            cin >> x >> y >> nval;\n'
            '            change(x - 1, y - 1, nval - a[x - 1][y - 1]);\n'
            '            a[x - 1][y - 1] = nval;\n'
            '        }\n'
            '    }\n'
            '    return 0;\n'
            '}\n')


def segment_tree_2Dproblems():
    return ('Двумерные задачи на дерево отрезков\n'
            '\n'
            'Один из метод решения двумерных задач - сканлайн + ДО\n'
            'Сканлайн идёт по оси OX, а ДО по оси OY\n'
            '\n'
            'Пример задачи, решаемой таким способом - точка, покрытая максимальным кол-вом прямоугольников\n'
            'Есть несколько вариаций этой задачи. Код ниже решает задачу, в которой вводятся только прямоугольники\n'
            '\n'
            'template <class T> void uniq(vector<T>& a) {sort(a.begin(), a.end()); a.resize(unique(a.begin(), a.end()) - a.begin());}\n'
            '\n'
            'struct Val {\n'
            '    ll Max;\n'
            '    int index;\n'
            '    Val() {\n'
            '        Max = 0;\n'
            '        index = -1;\n'
            '    }\n'
            '    Val(ll Max_, int index_) {\n'
            '        Max = Max_;\n'
            '        index = index_;\n'
            '    }\n'
            '};\n'
            '\n'
            'Val unite(const Val a, const Val b) {\n'
            '    if (a.Max < b.Max) {\n'
            '        return b;\n'
            '    }\n'
            '    if (a.Max > b.Max) {\n'
            '        return a;\n'
            '    }\n'
            '    if (a.index < b.index) {\n'
            '        return b;\n'
            '    }\n'
            '    return a;\n'
            '}\n'
            '\n'
            'vector<Val> t;\n'
            'vector<ll> c;\n'
            '\n'
            'void push(int v) {\n'
            '    c[v * 2 + 1] += c[v];\n'
            '    c[v * 2 + 2] += c[v];\n'
            '    c[v] = 0;\n'
            '}\n'
            '\n'
            'Val add_c(Val a, ll add) {\n'
            '    a.Max += add;\n'
            '    return a;\n'
            '}\n'
            '\n'
            'void build(int v, int l, int r) {\n'
            '    if (r - l == 1) {\n'
            '        t[v] = Val(0, l);\n'
            '        return;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    build(v * 2 + 1, l, m);\n'
            '    build(v * 2 + 2, m, r);\n'
            '    t[v] = unite(t[v * 2 + 1], t[v * 2 + 2]);\n'
            '}\n'
            '\n'
            'void change(int v, int l, int r, int askl, int askr, int delta) {\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return;\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        c[v] += delta;\n'
            '        return;\n'
            '    }\n'
            '    push(v);\n'
            '    int m = (l + r) / 2;\n'
            '    change(v * 2 + 1, l, m, askl, askr, delta);\n'
            '    change(v * 2 + 2, m, r, askl, askr, delta);\n'
            '    t[v] = unite(add_c(t[v * 2 + 1], c[v * 2 + 1]), add_c(t[v * 2 + 2], c[v * 2 + 2]));\n'
            '}\n'
            '\n'
            'Val ask(int v, int l, int r, int askl, int askr) {\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return Val(-1e9, -1);\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        return add_c(t[v], c[v]);\n'
            '    }\n'
            '    push(v);\n'
            '    int m = (l + r) / 2;\n'
            '    Val x = ask(v * 2 + 1, l, m, askl, askr);\n'
            '    Val y = ask(v * 2 + 2, m, r, askl, askr);\n'
            '    t[v] = unite(add_c(t[v * 2 + 1], c[v * 2 + 1]), add_c(t[v * 2 + 2], c[v * 2 + 2]));\n'
            '    return unite(x, y);\n'
            '}\n'
            '\n'
            'struct Event {\n'
            '    int type;\n'
            '    int x;\n'
            '    int y_up;\n'
            '    int y_down;\n'
            '    Event() {}\n'
            '    Event(int type_, int x_, int y_up_, int y_down_) {\n'
            '        type = type_;\n'
            '        x = x_;\n'
            '        y_up = y_up_;\n'
            '        y_down = y_down_;\n'
            '    }\n'
            '};\n'
            '\n'
            'bool operator < (const Event& a, const Event& b) {\n'
            '    if (a.x == b.x) {\n'
            '        return a.type < b.type;\n'
            '    }\n'
            '    return a.x < b.x;\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    vector<Event> evs(n * 2);\n'
            '    vector<int> Y;\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        int x1, y1, x2, y2;\n'
            '        cin >> x1 >> y1 >> x2 >> y2;\n'
            '        Y.push_back(y1);\n'
            '        Y.push_back(y2);\n'
            '        evs[i * 2] = Event(0, x1, y1, y2);\n'
            '        evs[i * 2 + 1] = Event(1, x2, y1, y2);\n'
            '    }\n'
            '    uniq(Y);\n'
            '    sort(all(evs));\n'
            '    int nY = Y.size();\n'
            '    t.resize(4 * nY);\n'
            '    c.resize(4 * nY);\n'
            '    build(0, 0, nY);\n'
            '    ll ans = -1;\n'
            '    int x_ans = -1, y_ans = -1;\n'
            '    for (int i = 0; i < n * 2; i++) {\n'
            '        Event e = evs[i];\n'
            '        int y1 = lower_bound(all(Y), e.y_up) - Y.begin();\n'
            '        int y2 = lower_bound(all(Y), e.y_down) - Y.begin();\n'
            '        if (e.type == 0) {\n'
            '            change(0, 0, nY, y1, y2 + 1, 1);\n'
            '            Val res = ask(0, 0, nY, y1, y2 + 1);\n'
            '            if (res.Max > ans) {\n'
            '                ans = res.Max;\n'
            '                x_ans = e.x;\n'
            '                y_ans = Y[res.index];\n'
            '            }\n'
            '        }\n'
            '        else {\n'
            '            change(0, 0, nY, y1, y2 + 1, -1);\n'
            '        }\n'
            '    }\n'
            '    cout << ans << el << x_ans << \' \' << y_ans << el;\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Как работает этот код: когда открывается прямоугольник, в ДО на отрезке [Y_up, Y_down] прибавляется 1\n'
            'Когда прямоугольник закрывается, на отрезке происходит вычитание 1\n'
            'Чтобы найти ответ, можно после обработки события прибавления делать запрос максимума на отрезке, который только что был обработан\n'
            '(наверное, можно и лучше)\n'
            'В коде используется сжатие координат (хранятся только события x и y событий)\n'
            '\n'
            'ДВУМЕРНОЕ ДО\n'
            'ДО может быть многомерным\n'
            'Для этого в каждой вершине ДО нужно заводить ещё одно ДО\n'
            'Например, для двумерного случая внешнее ДО будет считать ответ по OX (вершина отвечает за несколько строк), а внутреннее ДО по OY (вершина отвечает за несколько столбцов)\n')


def lca():
    return ('LCA (Least Common Ancestor) - Наименьший Общий Предок\n'
            '\n'
            'Задача LCA - нахождение для вершин дерева v, u предка с наибольшей высотой (высота считается от корня дерева)\n'
            '\n'
            'Задача LCA решается несколькими способами:\n'
            '1. Двоичные подъёмы\n'
            '2. LCA -> RMQ\n'
            '3. Алгоритм Тарьяна\n'
            '\n'
            '1. ДВОИЧНЫЕ ПОДЪЁМЫ: O(nlogn) препроцессинга, O(logn) на запрос\n'
            'Будем хранить массив up, где up[v][k] - в какую вершину можно попасть из вершины v, поднявшись на 2^k вверх\n'
            'Массив up будет считаться в dfs, в котором также будут считаться времена входа и выхода из вершины\n'
            'up[v][k] = up[up[v][k - 1][k - 1] (делим отрезок на две части)\n'
            '\n'
            'Даются вершины v, u\n'
            'Сначала проверим, является ли какая-нибудь из них предком другой (для этого мы считали времена в dfs)\n'
            'Теперь будем подниматься из v по степеням двойки (массив up), следя за тем, чтобы v не стала предком u\n'
            'Ответ на задачу - up[v][0], т.е. непосредственный предок вершины v\n'
            '\n'
            'Код:\n'
            'vector<vector<int>> g;\n'
            'vector<int> tin, tout;\n'
            'vector<vector<int>> up;\n'
            'int Log;\n'
            'int timer;\n'
            '\n'
            'void dfs(int v, int p = 0) {\n'
            '    tin[v] = ++timer;\n'
            '    up[v][0] = p;\n'
            '    for (int i = 1; i <= Log; i++) {\n'
            '        up[v][i] = up[up[v][i - 1]][i - 1];\n'
            '    }\n'
            '    for (int to: g[v]) {\n'
            '        if (to != p) {\n'
            '            dfs(to, v);\n'
            '        }\n'
            '    }\n'
            '    tout[v] = ++timer;\n'
            '}\n'
            '\n'
            'bool is_parent(int v, int u) {\n'
            '    return tin[v] <= tin[u] && tout[v] >= tout[u];\n'
            '}\n'
            '\n'
            'int lca(int v, int u) {\n'
            '    if (is_parent(u, v)) {\n'
            '        return u;\n'
            '    }\n'
            '    if (is_parent(v, u)) {\n'
            '        return v;\n'
            '    }\n'
            '    for (int i = Log; i >= 0; i--) {\n'
            '        if (!is_parent(up[v][i], u)) {\n'
            '            v = up[v][i];\n'
            '        }\n'
            '    }\n'
            '    return up[v][0];\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    g.resize(n);\n'
            '    tin.resize(n);\n'
            '    tout.resize(n);\n'
            '    REP(n - 1) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        g[v].push_back(u);\n'
            '        g[u].push_back(v);\n'
            '    }\n'
            '    Log = 1;\n'
            '    timer = 0;\n'
            '    while ((1 << Log) <= n) {\n'
            '        Log++;\n'
            '    }\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        up[i].resize(Log + 1);\n'
            '    }\n'
            '    dfs(0);\n'
            '    int m;\n'
            '    cin >> m;\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        cout << lca(v, u) + 1 << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Чтобы найти длину пути между двумя вершинами в дереве, из высоты вершины v и высоты вершины u вычесть высоту их lca\n'
            '\n'
            'Метод двоичных подъёмов позволяет считать функции на пути из одной вершины до другой\n'
            'Например, можно найти минимальное ребро на пути между двумя вершинами\n'
            'Для этого нужно считать массив, похожий на массив up\n'
            'Код:\n'
            'vector<vector<int>> up, Min;\n'
            'vector<vector<pair<int, int>>> g;\n'
            'vector<int> tin, tout;\n'
            'int timer = 0;\n'
            'int Log;\n'
            '\n'
            'void dfs(int v, int p = 0, int M = 1e9) {\n'
            '    tin[v] = ++timer;\n'
            '    up[v][0] = p;\n'
            '    Min[v][0] = M;\n'
            '    for (int i = 1; i <= Log; i++) {\n'
            '        up[v][i] = up[up[v][i - 1]][i - 1];\n'
            '        Min[v][i] = min(Min[v][i - 1], Min[up[v][i - 1]][i - 1]);\n'
            '    }\n'
            '    for (auto pa: g[v]) {\n'
            '        int u = pa.first;\n'
            '        int w = pa.second;\n'
            '        if (u != p) {\n'
            '            dfs(u, v, w);\n'
            '        }\n'
            '    }\n'
            '    tout[v] = ++timer;\n'
            '}\n'
            '\n'
            'bool is_parent(int v, int u) {\n'
            '    return tin[v] <= tin[u] && tout[v] >= tout[u];\n'
            '}\n'
            '\n'
            'int get_min(int v, int u) {\n'
            '    int res = 1e9;\n'
            '    for (int i = Log; i >= 0; i--) {\n'
            '        if (!is_parent(up[v][i], u)) {\n'
            '            res = min(res, Min[v][i]);\n'
            '            v = up[v][i];\n'
            '        }\n'
            '    }\n'
            '    if (!is_parent(v, u)) {\n'
            '        res = min(res, Min[v][0]);\n'
            '    }\n'
            '    for (int i = Log; i >= 0; i--) {\n'
            '        if (!is_parent(up[u][i], v)) {\n'
            '            res = min(res, Min[u][i]);\n'
            '            u = up[u][i];\n'
            '        }\n'
            '    }\n'
            '    if (!is_parent(u, v)) {\n'
            '        res = min(res, Min[u][0]);\n'
            '    }\n'
            '    return res;\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    g.resize(n);\n'
            '    tin.resize(n);\n'
            '    tout.resize(n);\n'
            '    up.resize(n);\n'
            '    Min.resize(n);\n'
            '    // формат ввода - (предок вершины i, вес ребра между вершиной i и её предком)\n'
            '    for (int i = 1; i < n; i++) {\n'
            '        int v, w;\n'
            '        cin >> v >> w;\n'
            '        v--;\n'
            '        g[v].push_back({i, w});\n'
            '        g[i].push_back({v, w});\n'
            '    }\n'
            '    Log = 1;\n'
            '    while ((1 << Log) <= n) {\n'
            '        Log++;\n'
            '    }\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        up[i].resize(Log + 1);\n'
            '        Min[i].resize(Log + 1);\n'
            '    }\n'
            '    dfs(0);\n'
            '    int m;\n'
            '    cin >> m;\n'
            '    REP(m) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        cout << get_min(v, u) << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Однако не всегда дерево вводится\n'
            'В задаче дерево может строится путём добавления вершин (запрос: привесить новую вершину к уже существующей)\n'
            'В таком дереве тоже можно считать lca, однако функция поиска lca изменится\n'
            'Ведь в изменяющемся дереве мы не можем посчитать времена входа и выхода\n'
            'Поэтому можно основываться на высотах вершин\n'
            'Пусть даны вершины v, u\n'
            'Сначала приведём их к одной высоте (двоичными подъёмами поднимем вершину с бОльшей высотой до высоты второй вершины)\n'
            'Если v == u, то мы нашли lca, иначе будем поднимать вершины\n'
            'Теперь мы можем одновременно поднимать обе вершины двоичными подъёмами\n'
            'Поднимать мы будем, пока у v и u не будет один и тот же прямой предок (предок, соединённый ребром)\n'
            'Тогда lca(v, u) будет up[v][0] (или up[u][0])\n'
            '\n'
            'Код:\n'
            'int lca(int v, int u) {\n'
            '    if (d[v] > d[u]) {\n'
            '        swap(v, u);\n'
            '    }\n'
            '    for (int i = Log; i >= 0; i--) {\n'
            '        if (d[up[u][i]] >= d[v]) {\n'
            '            u = up[u][i];\n'
            '        }\n'
            '    }\n'
            '    if (v == u) {\n'
            '        return v;\n'
            '    }\n'
            '    for (int i = Log; i >= 0; i--) {\n'
            '        if (up[v][i] != up[u][i]) {\n'
            '            v = up[v][i];\n'
            '            u = up[u][i];\n'
            '        }\n'
            '    }\n'
            '    return up[v][0];\n'
            '}\n'
            '\n'
            'Двоичные подъёмы позволяют считать функции и на массивах (сумма, минимум...)\n'
            'Вводится запрос [L, R]\n'
            'Для ответа нужно пройти по степеням двойки от L до R и собрать ответ\n'
            '\n'
            '2. LCA -> RMQ\n'
            'LCA можно свести к задаче RMQ\n'
            'Для этого нужно совершить эйлеров обход дерева (выписать вершину при заходе в неё)\n'
            'Но сам массив вершин понадобится только для поиска номера вершины\n'
            'Важен массив высот вершин, соответсвующий массиву выписанных вершин\n'
            'На массиве нужно построить структуру данных, позволяющую искать RMQ на отрезке (ДО, Sparse Table, SQRT-decomposition...)\n'
            '\n'
            'Для каждой вершины нужно хранить её индекс в массиве обхода (индекс любого вхождения)\n'
            'Чтобы найти LCA(v, u), нужно найти минимум на отрезке [ind[v], ind[u]] массива высот\n'
            '\n'
            'Реализация с ДО:\n'
            'vector<vector<int>> g;\n'
            'vector<int> d;\n'
            'vector<int> a;\n'
            'vector<int> indexes;\n'
            'vector<bool> used;\n'
            'vector<pair<int, int>> t;\n'
            'int sz;\n'
            '\n'
            'void dfs(int v, int depth) {\n'
            '    a.push_back(v);\n'
            '    d.push_back(depth);\n'
            '    indexes[v] = d.size() - 1;\n'
            '    used[v] = true;\n'
            '    for (int u: g[v]) {\n'
            '        if (!used[u]) {\n'
            '            dfs(u, depth + 1);\n'
            '            a.push_back(v);\n'
            '            d.push_back(depth);\n'
            '            indexes[v] = d.size() - 1;\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'void build(int v, int l, int r) {\n'
            '    if (r - l == 1) {\n'
            '        t[v] = {d[l], l};\n'
            '        return;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    build(v * 2 + 1, l, m);\n'
            '    build(v * 2 + 2, m, r);\n'
            '    t[v] = min(t[v * 2 + 1], t[v * 2 + 2]);\n'
            '}\n'
            '\n'
            'pair<int, int> ask(int v, int l, int r, int askl, int askr) {\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return {1e9, -1};\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        return t[v];\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    return min(ask(v * 2 + 1, l, m, askl, askr), ask(v * 2 + 2, m, r, askl, askr));\n'
            '}\n'
            '\n'
            'int lca(int v, int u) {\n'
            '    int vi = indexes[v];\n'
            '    int ui = indexes[u];\n'
            '    if (vi > ui) {\n'
            '        swap(vi, ui);\n'
            '    }\n'
            '    pair<int, int> res = ask(0, 0, sz, vi, ui + 1);\n'
            '    return a[res.second];\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    g.resize(n);\n'
            '    indexes.resize(n);\n'
            '    used.resize(n);\n'
            '    REP(n - 1) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        g[v].push_back(u);\n'
            '        g[u].push_back(v);\n'
            '    }\n'
            '    dfs(0, 0);\n'
            '    sz = d.size();\n'
            '    t.resize(4 * sz);\n'
            '    build(0, 0, sz);\n'
            '    int m;\n'
            '    cin >> m;\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        cout << lca(v, u) + 1 << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Реализация с Sparse Table:\n'
            'vector<vector<int>> g;\n'
            'vector<int> d, a, indexes;\n'
            'vector<bool> used;\n'
            'vector<vector<pair<int, int>>> sparse;\n'
            'vector<int> logs;\n'
            'int sz;\n'
            '\n'
            'void dfs(int v, int depth) {\n'
            '    used[v] = true;\n'
            '    a.push_back(v);\n'
            '    d.push_back(depth);\n'
            '    indexes[v] = d.size() - 1;\n'
            '    for (int u: g[v]) {\n'
            '        if (!used[u]) {\n'
            '            dfs(u, depth + 1);\n'
            '            a.push_back(v);\n'
            '            d.push_back(depth);\n'
            '            indexes[v] = d.size() - 1;\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'void build_sparse() {\n'
            '    logs.resize(sz + 1);\n'
            '    logs[1] = 0;\n'
            '    for (int i = 2; i <= sz; i++) {\n'
            '        logs[i] = logs[i / 2] + 1;\n'
            '    }\n'
            '    sparse.resize(logs[sz] + 1, vector<pair<int, int>>(sz));\n'
            '    for (int i = 0; i < sz; i++) {\n'
            '        sparse[0][i] = {d[i], i};\n'
            '    }\n'
            '    for (int level = 1; (1 << level) <= sz; level++) {\n'
            '        for (int i = 0; i + (1 << level) <= sz; i++) {\n'
            '            sparse[level][i] = min(sparse[level - 1][i], sparse[level - 1][i + (1 << (level - 1))]);\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'pair<int, int> ask(int l, int r) {\n'
            '    int len = r - l + 1;\n'
            '    int level = logs[len];\n'
            '    pair<int, int> ans = min(sparse[level][l], sparse[level][r - (1 << level) + 1]);\n'
            '    return ans;\n'
            '}\n'
            '\n'
            'int lca(int v, int u) {\n'
            '    int vi = indexes[v];\n'
            '    int ui = indexes[u];\n'
            '    if (vi > ui) {\n'
            '        swap(vi, ui);\n'
            '    }\n'
            '    pair<int, int> res = ask(vi, ui);\n'
            '    return a[res.second];\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    g.resize(n);\n'
            '    used.resize(n);\n'
            '    indexes.resize(n);\n'
            '    REP(n - 1) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        g[v].push_back(u);\n'
            '        g[u].push_back(v);\n'
            '    }\n'
            '    dfs(0, 0);\n'
            '    sz = d.size();\n'
            '    build_sparse();\n'
            '    int m;\n'
            '    cin >> m;\n'
            '    REP(m) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        cout << lca(v, u) + 1 << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            '3. АЛГОРИТМ ТАРЬЯНА\n'
            'Алгоритм Тарьяна решает задачу LCA в оффлайне (все запросы должны быть даны в начале, алгоритм отвечает на запросы не по порядку)\n'
            'Пройдём по дереву при помощи dfs\n'
            'Допустим мы стоим в вершине v, а нам нужно найти LCA(v, u)\n'
            'Пусть вершина u уже посещена\n'
            'Тогда LCA(v, u) - это какой-то предок вершины v, для которого u является потомком\n'
            'Пусть p - какой-нибудь предок вершины v; тогда LCA(v, i), где i - все вершины лежащие в поддеревьях вершины p (кроме того дерева, в котором лежит v), будет равно p\n'
            'Т.е. все предки вершины v - это какие-то представители классов вершин, у которых LCA с v одинаков\n'
            'Получается, нам всего лишь нужно найти представителя класса, в котором лежит вершина u\n'
            'Это делается при помощи СНМ\n'
            'Важно также хранить массив ancestor, в котором будет лежать правильная вершина (ведь представитель класса может быть любым при ранговой эвристике)\n'
            'Код:\n'
            'vector<vector<int>> g, Q;\n'
            'vector<int> p, d, ancestor;\n'
            'vector<bool> used;\n'
            'map<pair<int, int>, int> ans;\n'
            'vector<pair<int, int>> Q_pair;\n'
            '\n'
            'int get_par(int v) {\n'
            '    if (v == p[v]) {\n'
            '        return v;\n'
            '    }\n'
            '    return p[v] = get_par(p[v]);\n'
            '}\n'
            '\n'
            'void unite(int v, int u, int new_ancestor) {\n'
            '    v = get_par(v);\n'
            '    u = get_par(u);\n'
            '    if (v != u) {\n'
            '        if (d[u] > d[v]) {\n'
            '            swap(v, u);\n'
            '        }\n'
            '        p[u] = v;\n'
            '        if (d[v] == d[u]) {\n'
            '            d[v]++;\n'
            '        }\n'
            '        ancestor[v] = new_ancestor;\n'
            '    }\n'
            '}\n'
            '\n'
            'void dfs(int v) {\n'
            '    p[v] = v;\n'
            '    ancestor[v] = v;\n'
            '    used[v] = true;\n'
            '    for (int u: g[v]) {\n'
            '        if (!used[u]) {\n'
            '            dfs(u);\n'
            '            unite(v, u, v);\n'
            '        }\n'
            '    }\n'
            '    for (int u: Q[v]) {\n'
            '        if (used[u]) {\n'
            '            int lca = ancestor[get_par(u)];\n'
            '            ans[{v, u}] = lca;\n'
            '            ans[{u, v}] = lca;\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    fastIO;\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    g.resize(n);\n'
            '    used.resize(n);\n'
            '    ancestor.resize(n);\n'
            '    p.resize(n);\n'
            '    d.resize(n);\n'
            '    Q.resize(n);\n'
            '    int v, u;\n'
            '    REP(n - 1) {\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        g[v].push_back(u);\n'
            '        g[u].push_back(v);\n'
            '    }\n'
            '    int m;\n'
            '    cin >> m;\n'
            '    REP(m) {\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        Q[v].push_back(u);\n'
            '        Q[u].push_back(v);\n'
            '        Q_pair.emplace_back(v, u);\n'
            '    }\n'
            '    dfs(0);\n'
            '    for (auto pa: Q_pair) {\n'
            '        v = pa.first;\n'
            '        u = pa.second;\n'
            '        cout << ans[{v, u}] + 1 << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n')


def maxmatch():
    return ('Максимальное паросочетание\n'
            '\n'
            'Паросочетание - это набор рёбер графа, в котором никакие два ребра не имеют общей вершины\n'
            '\n'
            'Максимальное паросочетание - это паросочетание, состоящее из максимального кол-ва рёбер (для невзвешенного графа) или имеющее максимальный суммарный вес (для взвешенного графа)\n'
            '\n'
            'Паросочетание ищется по-разному для разных видов графа:\n'
            '1. Для дерева\n'
            '2. Для произвольного графа\n'
            '3. Для двудольного графа\n'
            '\n'
            '1. ДЕРЕВО\n'
            'Для поиска максимального паросочетания в дереве используется ДП по поддеревьям\n'
            'dp[v][0] - вершина v не соединена в просочетании с каким-либо из сыновей\n'
            'dp[v][1] - вершина v соединена в просочетании с каким-либо из сыновей\n'
            '\n'
            'Если вершина не соединена с каким-лио сыном, то dp[v][0] = max(dp[ui][0], dp[ui][1]) (не важны состояния сыновей)\n'
            'Но если вершина соединена с каким-либо из сыновей, то dp[v][0] = max(dp[uk][0] + max(dp[ui][0], dp[ui][1]), ui != uk)\n'
            '\n'
            'Код:\n'
            'vector<vector<pair<int, int>>> g;\n'
            'vector<vector<int>> dp;\n'
            '\n'
            'void dfs(int v, int pr) {\n'
            '    for (pair<int, int> p: g[v]) {\n'
            '        int u = p.first;\n'
            '        if (u != pr) {\n'
            '            dfs(u, v);\n'
            '            dp[v][0] += max(dp[u][0], dp[u][1]);\n'
            '        }\n'
            '    }\n'
            '    for (pair<int, int> p: g[v]) {\n'
            '        int u = p.first;\n'
            '        int w = p.second;\n'
            '        if (u != pr) {\n'
            '            dp[v][1] = max(dp[v][1], dp[u][0] + dp[v][0] - max(dp[u][0], dp[u][1]) + w);\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    g.resize(n);\n'
            '    dp.resize(n, vector<int>(2));\n'
            '    REP(n - 1) {\n'
            '        int v, u, w;\n'
            '        cin >> v >> u >> w;\n'
            '        v--;\n'
            '        u--;\n'
            '        g[v].push_back({u, w});\n'
            '        g[u].push_back({v, w});\n'
            '    }\n'
            '    dfs(0, -1);\n'
            '    cout << max(dp[0][0], dp[0][1]) << el;\n'
            '    return 0;\n'
            '}\n'
            '\n'
            '2. ПРОИЗВОЛЬНЫЙ ГРАФ\n'
            'Здесь будет рассматриваться медленный, но простой алгоритм для произвольного графа\n'
            '\n'
            'В алгоритме используется ДП по подмножествам\n'
            'dp[mask] - ответ, если все вершины подмножества находятся в паросочетании\n'
            'Если из всех вершин подмножества нельзя составить паросочетание, то dp[mask] = -1\n'
            '\n'
            'В текущем подмножестве выберем любую вершину v и посмотрим на всех её сыновей\n'
            'Пусть мы сейчас рассматривает сына u\n'
            'Если dp[mask без вершин u и v] не равен -1, то обновим dp[mask]\n'
            '\n'
            'Код:\n'
            'vector<vector<pair<int, int>>> g;\n'
            'vector<int> dp;\n'
            '\n'
            'int get_last1_bit(int mask) {\n'
            '   // предполагается, что бит 1 всегда есть\n'
            '   for (int i = 0; i < 31; i++) {\n'
            '       if ((1 << i) & mask) {\n'
            '           return i;\n'
            '       }\n'
            '   }\n'
            '}\n'
            '\n'
            'int get_bit(int mask, int i) {\n'
            '    return ((1 << i) & mask);\n'
            '}\n'
            '\n'
            'int bit_to0(int mask, int i) {\n'
            '    return mask & ~(1 << i);\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    g.resize(n);\n'
            '    dp.resize((1 << n), -1);\n'
            '    int m;\n'
            '    cin >> m;\n'
            '    REP(m) {\n'
            '        int v, u, w;\n'
            '        cin >> v >> u >> w;\n'
            '        v--;\n'
            '        u--;\n'
            '        g[v].push_back({u, w});\n'
            '        g[u].push_back({v, w});\n'
            '    }\n'
            '    dp[0] = 0;\n'
            '    int ans = 0;\n'
            '    for (int mask = 1; mask < (1 << n); mask++) {\n'
            '        int v = get_last1_bit(mask);\n'
            '        for (pair<int, int> p: g[v]) {\n'
            '            int u = p.first;\n'
            '            int w = p.second;\n'
            '            if (get_bit(mask, u)) {\n'
            '                int nmask = bit_to0(mask, u);\n'
            '                nmask = bit_to0(nmask, v);\n'
            '                if (dp[nmask] != -1) {\n'
            '                    dp[mask] = max(dp[mask], dp[nmask] + w);\n'
            '                    ans = max(ans, dp[mask]);\n'
            '                }\n'
            '            }\n'
            '        }\n'
            '    }\n'
            '    cout << ans << el;\n'
            '    return 0;\n'
            '}\n'
            '\n'
            '3. ДВУДОЛЬНЫЙ ГРАФ\n'
            'См. Kuhn (там же применение паросочетаний)\n')


def Kuhn():
    return ('Алгоритм Куна\n'
            '\n'
            'Алгоритм Куна - это алгоритм поиска максимального по размеру паросочетания в двудольном графе\n'
            '\n'
            'Пусть граф уже разбит на две доли\n'
            'Будем по порядку добавлять вершины первой доли\n'
            'Если мы можем найти свободную пару для новой вершины, то создадим пару и закончим вызов алгоритма\n'
            'Если мы не можем найти свободную пару, то попробуем отобрать вершину, соединённую с предыдущей добавленной вершиной\n'
            'Будем делать это рекурсивно\n'
            '\n'
            'Код:\n'
            'int n, m; // размеры долей графа\n'
            'vector<vector<int>> g; // len = n, хранить только для первой доли\n'
            'vector<int> used; // used[i] - номер последнего запуска алгоритма, в котором i было true\n'
            'vector<int> pairs; // len = m, сначала заполнен -1\n'
            '\n'
            '\n'
            '// Если граф задан как обычно\n'
            'int N;\n'
            'vector<vector<int>> G;\n'
            'vector<int> col;\n'
            'vector<int> col1, col2;\n'
            '\n'
            'void color(int v, int c) {\n'
            '    col[v] = c;\n'
            '    for (int u: G[v]) {\n'
            '        if (col[u] == -1) {\n'
            '            color(u, (c + 1) % 2);\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            '\n'
            'bool kuhn(int v, int timer) {\n'
            '    used[v] = timer;\n'
            '    for (int u: g[v]) {\n'
            '        if (pairs[u] == -1 || (used[pairs[u]] != timer && kuhn(pairs[u], timer))) {\n'
            '            pairs[u] = v;\n'
            '            return true;\n'
            '        }\n'
            '    }\n'
            '    return false;\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    // input\n'
            '    // Если input ненормальный (граф задан как обычно):\n'
            '    col.resize(N, -1);\n'
            '    color(0, 0);\n'
            '    for (int i = 0; i < N; i++) {\n'
            '        if (col[i] == 0) {\n'
            '            col1.push_back(i);\n'
            '        }\n'
            '        else {\n'
            '            col2.push_back(i);\n'
            '        }\n'
            '    }\n'
            '    n = col1.size();\n'
            '    m = col2.size();\n'
            '    g.resize(n);\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        g[i] = G[col1[i]];\n'
            '    }\n'
            '\n'
            '\n'
            '    pairs.resize(m, -1);\n'
            '    used.resize(n, -1);\n'
            '    for (int v = 0; v < n; v++) {\n'
            '        kuhn(v, v);\n'
            '    }\n'
            '    // ответ можно восстановить по pairs\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Применение паросочетаний:\n'
            'Построим паросочетание на графе\n'
            'Теперь ориентируем рёбра (если есть в парсоче, то <-, иначе ->)\n'
            'Запустим dfs из всех ненасыщенных вершин (т.е. из тех, которые не затрагивает паросочетание)\n'
            'Все вершины разобьются на 4 группы:\n'
            'L+ - левая доля, посещены dfs\n'
            'L- - левая доля, не посещены dfs\n'
            'R+ - правая доля, посещены dfs\n'
            'R- - правая доля, не посещены dfs\n'
            '\n'
            'Рёбра между этими группами могут быть только такие:\n'
            '   ---->\n'
            'L+ <---- R+\n'
            '         ^\n'
            '      /\n'
            '   /\n'
            'L- ----> R-\n'
            '   <----\n'
            '\n'
            '1) Минимальное вершинное покрытие = min(L, R, L- + R+) (Мощность мин. покрытия равна мощности макс. паросочетания)\n'
            '2) Максимальное независимое множество = L+ + R-\n'
            'Поэтому 1 + 2 = кол-во вершин\n'
            '\n'
            'ПОКРЫТИЕ ОРИЕНТИРОВАННОГО ГРАФА МИНИМАЛЬНЫМ КОЛ-ВОМ ПУТЕЙ\n'
            'Продублируем вершины графа (правая доля - копия всех вершин)\n'
            'Проведём рёбра из левой доли в правую (те рёбра, которые были в исходном графе)\n'
            'Построим парсоч на этом графе\n'
            'Теперь проведём обратные рёбра (из вершины 1 правой доли в вершину 1 левой доли, из вершины 2 правой доли в вершину 2 левой доли...)\n'
            '\n'
            'Будем запускаться из вершин правой доли, которые не покрыты парсочем\n'
            'Алгоритм таков: переходим по обратному ребру в левую долю,\n'
            '                если есть ребро паросочетания, то переходим по нему и повторяем алгоритм (так мы считаем один из путей)\n'
            '                если ребра парсоча нет, то заканчиваем\n'
            '\n'
            'Код:\n'
            'vector<vector<int>> graph;\n'
            'vector<int> used;\n'
            'vector<int> pairs;\n'
            'int n;\n'
            '\n'
            'bool Kuhn(int v, int timer) {\n'
            '    used[v] = timer;\n'
            '    for (int u : graph[v]) {\n'
            '        if (pairs[u] == -1 || (used[pairs[u]] != timer && Kuhn(pairs[u], timer))) {\n'
            '            pairs[u] = v;\n'
            '            return true;\n'
            '        }\n'
            '    }\n'
            '    return false;\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int m;\n'
            '    cin >> n >> m;\n'
            '    graph.resize(n);\n'
            '    pairs.resize(n, -1);\n'
            '    used.resize(n, -1);\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        graph[v].push_back(u);\n'
            '    }\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        Kuhn(i, i);\n'
            '    }\n'
            '    int cnt_paths = 0;\n'
            '    vector<vector<int>> paths;\n'
            '    int cur_path = -1;\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        if (pairs[i] == -1) {\n'
            '            cnt_paths++;\n'
            '            int v = i;\n'
            '            paths.push_back({});\n'
            '            cur_path++;\n'
            '            bool was_edge = false;\n'
            '            while (true) {\n'
            '                paths[cur_path].push_back(v + 1);\n'
            '                was_edge = false;\n'
            '                for (int u : graph[v]) {\n'
            '                    if (pairs[u] == v) {\n'
            '                        v = u;\n'
            '                        was_edge = true;\n'
            '                        break;\n'
            '                    }\n'
            '                }\n'
            '                if (!was_edge) {\n'
            '                    break;\n'
            '                }\n'
            '            }\n'
            '        }\n'
            '    }\n'
            '    cout << cnt_paths << el;\n'
            '    cout << paths << el;\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Антицепь - макс. множество вершин, в котором от любой вершины нельзя добраться до любой другой (в ориентированном графе)\n'
            'Кол-во вершин в антицепи равно минимальному кол-ву путей, на которые можно разбить граф\n')


def prefix_function():
    return ('Префикс-функция\n'
            '\n'
            'Префикс-функция элемента i строки s - это длина наибольшей подстроки, совпадающей с префиксом строки s и заканчивающейся в позиции i\n'
            'Другими словами, префикс функция элемента i строки s - это длина максимального бордера строки s[0..i]\n'
            '\n'
            'Для построения переберём бордеры в порядке уменьшения (просто будем брать бордер от текущего бордера) и посмотрим, какой из них мы можем дополнить новым символом\n'
            'Код:\n'
            'int n = s.size();\n'
            'vector<int> p(n);\n'
            'int k = 0;\n'
            'for (int i = 1; i < n; i++) {\n'
            '    while (k > 0 && s[i] != s[k]) {\n'
            '        k = p[k - 1];\n'
            '    }\n'
            '    if (s[i] == s[k]) {\n'
            '        k++;\n'
            '    }\n'
            '    p[i] = k;\n'
            '}\n'
            '\n'
            'Применения:\n'
            '# Поиск подстроки в строке\n'
            '  Запишем две строки через специальный символ (сначала та строка, которую мы ищем) и посчитаем префикс-функцию от получившейся строки\n'
            '  Если в каком-то элементе (после спец. символа) значение функции будет равно длине искомой строки, то мы нашли её вхождение\n'
            '\n'
            '# Период строки (требуется найти минимальную по длине строку t такую, что строку s можно представить в виде конкатенации нескольких строк t)\n'
            '  Посчитаем префикс-функцию от строки и возьмём последнее значение (p_last)\n'
            '  Если n делится на n - p_last, то ответ n - p_last\n'
            '  Иначе ответ n\n')


def bridges_cutpoints():
    return ('Мосты и точки сочленения\n'
            '\n'
            'Мост - ребро, при удалении которого граф распадается (число компонент связности увеличивается)\n'
            'Запустим dfs\n'
            'Из вершины могут идти прямые рёбра (ребра вниз), а также обратные рёбра (рёбра, которые ведут в вершины выше предка)\n'
            'Если у вершины есть обратные рёбра, то ребро (предок - текущая вершина) не является мостом\n'
            '\n'
            'struct Edge {\n'
            '    int u;\n'
            '    int index;\n'
            '    bool isbridge;\n'
            '    Edge* back;\n'
            '    Edge() {}\n'
            '    Edge(int u_, int index_) {\n'
            '        isbridge = false;\n'
            '        u = u_;\n'
            '        index = index_;\n'
            '    }\n'
            '};\n'
            '\n'
            'vector<vector<Edge*>> graph;\n'
            'vector<bool> used;\n'
            'vector<int> depth;\n'
            'vector<int> up;\n'
            'vector<int> ans;\n'
            '\n'
            'void dfs(int v, int d = 0, Edge* p = nullptr) {\n'
            '    used[v] = true;\n'
            '    depth[v] = d;\n'
            '    up[v] = d;\n'
            '    for (Edge* e : graph[v]) {\n'
            '        if (!used[e->u]) {\n'
            '            dfs(e->u, d + 1, e);\n'
            '            up[v] = min(up[v], up[e->u]);\n'
            '        }\n'
            '        else if (p && p->back != e) {\n'
            '            up[v] = min(up[v], depth[e->u]);\n'
            '        }\n'
            '    }\n'
            '    if (p && up[v] == depth[v]) {\n'
            '        p->isbridge = true;\n'
            '        p->back->isbridge = true;\n'
            '        ans.push_back(p->index + 1);\n'
            '    }\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n, m;\n'
            '    cin >> n >> m;\n'
            '    graph.resize(n);\n'
            '    depth.resize(n);\n'
            '    used.resize(n);\n'
            '    up.resize(n);\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        Edge* e1 = new Edge(u, i);\n'
            '        Edge* e2 = new Edge(v, i);\n'
            '        e1->back = e2;\n'
            '        e2->back = e1;\n'
            '        graph[v].push_back(e1);\n'
            '        graph[u].push_back(e2);\n'
            '    };\n'
            '    for (int v = 0; v < n; v++) {\n'
            '        if (!used[v]) {\n'
            '            dfs(v);\n'
            '        }\n'
            '    }\n'
            '    cout << ans.size() << el;\n'
            '    cout << ans << el;\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Точка сочленения - вершина, при удалении которой граф распадается (кол-во компонент связности увеличивается)\n'
            'Поиск точек сочленения похож на поиск мостов, однако есть отличия\n'
            'Во-первых, если хотя бы у одного сына нет обратного ребра, то текущая вершина является точкой сочленения\n'
            'Во-вторых, нужно отдельно проверить корень обхода: если у корня больше 1 сына, то он точка сочленения\n'
            '\n'
            'vector<vector<int>> graph;\n'
            'vector<bool> used;\n'
            'vector<int> depth;\n'
            'vector<int> up;\n'
            'vector<bool> is_cutpoint;\n'
            '\n'
            'void dfs(int v, int d = 0, int p = -1) {\n'
            '    used[v] = true;\n'
            '    depth[v] = d;\n'
            '    int children = 0;\n'
            '    up[v] = d;\n'
            '    for (int u : graph[v]) {\n'
            '        if (!used[u]) {\n'
            '            dfs(u, d + 1, v);\n'
            '            children++;\n'
            '            up[v] = min(up[v], up[u]);\n'
            '            if (p != -1 && up[u] >= depth[v]) {\n'
            '                is_cutpoint[v] = true;\n'
            '            }\n'
            '        }\n'
            '        else if (p != u) {\n'
            '            up[v] = min(up[v], depth[u]);\n'
            '        }\n'
            '    }\n'
            '    if (p == -1 && children > 1) {\n'
            '        is_cutpoint[v] = true;\n'
            '    }\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n, m;\n'
            '    cin >> n >> m;\n'
            '    graph.resize(n);\n'
            '    depth.resize(n);\n'
            '    used.resize(n);\n'
            '    up.resize(n);\n'
            '    is_cutpoint.resize(n);\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        graph[v].push_back(u);\n'
            '        graph[u].push_back(v);\n'
            '    };\n'
            '    for (int v = 0; v < n; v++) {\n'
            '        if (!used[v]) {\n'
            '            dfs(v);\n'
            '        }\n'
            '    }\n'
            '    vector<int> ans;\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        if (is_cutpoint[i]) {\n'
            '            ans.push_back(i + 1);\n'
            '        }\n'
            '    }\n'
            '    cout << ans.size() << el;\n'
            '    cout << ans << el;\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'С мостами и точками сочленения связаны компоненты двусвязности\n'
            'Две вершины рёберно двусвязны, если существуют хотя бы два непересекающихся по рёбрам пути между ними\n'
            'Два ребра вершинно двусвязны, если существуют хотя бы два непересекающихся по вершинам пути, соединяющие концы этих рёбер\n'
            '\n'
            'Компоненты рёберной двусвязности ищутся довольно просто\n'
            'Можно просто запустить dfs и не ходить по мостам\n'
            'Компоненты можно сжимать в вершины (полученный граф - дерево)\n'
            '\n'
            'Сжатие компонент рёберной двусвязности:\n'
            'vector<vector<int>> graph2;\n'
            'vector<int> comp;\n'
            '\n'
            'void dfs_comp(int v, int cur_comp) {\n'
            '    used[v] = true;\n'
            '    comp[v] = cur_comp;\n'
            '    for (Edge* e : graph[v]) {\n'
            '        if (!used[e->u] && !e->isbridge) {\n'
            '            dfs_comp(e->u, cur_comp);\n'
            '        }\n'
            '        else if (used[e->u] && e->isbridge) {\n'
            '            graph2[cur_comp].push_back(comp[e->u]);\n'
            '            graph2[comp[e->u]].push_back(cur_comp);\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    // ввод, нахождение мостов\n'
            '    used.assign(n, false);\n'
            '    int cur_comp = 0;\n'
            '    for (int v = 0; v < n; v++) {\n'
            '        if (!used[v]) {\n'
            '            graph2.push_back(vector<int>());\n'
            '            dfs_comp(v, cur_comp);\n'
            '            cur_comp++;\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'Нахождение компонент вершинной двусвязности:\n'
            'struct Edge {\n'
            '    int u;\n'
            '    int index;\n'
            '    Edge() {}\n'
            '    Edge(int u_, int index_) {\n'
            '        u = u_;\n'
            '        index = index_;\n'
            '    }\n'
            '};\n'
            '\n'
            'vector<vector<Edge>> graph;\n'
            'vector<bool> used;\n'
            'vector<int> depth;\n'
            'vector<int> up;\n'
            'vector<int> col;\n'
            'int maxcol = 0;\n'
            '\n'
            'void dfs(int v, int d = 0, int p = -1) {\n'
            '    used[v] = true;\n'
            '    depth[v] = d;\n'
            '    up[v] = d;\n'
            '    for (Edge e : graph[v]) {\n'
            '        int u = e.u;\n'
            '        if (!used[u]) {\n'
            '            dfs(u, d + 1, v);\n'
            '            up[v] = min(up[v], up[u]);\n'
            '        }\n'
            '        else if (p != u) {\n'
            '            up[v] = min(up[v], depth[u]);\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'void dfs_comp(int v, int color, int e_index) {\n'
            '    used[v] = true;\n'
            '    for (Edge e : graph[v]) {\n'
            '        int u = e.u;\n'
            '        if (e.index == e_index) {\n'
            '            continue;\n'
            '        }\n'
            '        if (!used[u]) {\n'
            '            if (up[u] >= depth[v]) {\n'
            '                maxcol++;\n'
            '                col[e.index] = maxcol;\n'
            '                dfs_comp(u, maxcol, e.index);\n'
            '            }\n'
            '            else {\n'
            '                col[e.index] = color;\n'
            '                dfs_comp(u, color, e.index);\n'
            '            }\n'
            '        }\n'
            '        else {\n'
            '            if (depth[u] < depth[v]) {\n'
            '                col[e.index] = color;\n'
            '            }\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n, m;\n'
            '    cin >> n >> m;\n'
            '    graph.resize(n);\n'
            '    depth.resize(n);\n'
            '    used.resize(n);\n'
            '    up.resize(n);\n'
            '    col.resize(m);\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        graph[v].push_back(Edge(u, i));\n'
            '        graph[u].push_back(Edge(v, i));\n'
            '    };\n'
            '    for (int v = 0; v < n; v++) {\n'
            '        if (!used[v]) {\n'
            '            dfs(v);\n'
            '        }\n'
            '    }\n'
            '    used.assign(n, false);\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        if (!used[i]) {\n'
            '            dfs_comp(i, maxcol, -1);\n'
            '        }\n'
            '    }\n'
            '    cout << maxcol << el;\n'
            '    cout << col << el;\n'
            '    return 0;\n'
            '}\n')


def dsu():
    return ('СНМ (Система Непересекающихся Множеств)\n'
            '\n'
            'СНМ - структура данных, позволяющая объединять множества и считать функции на их объединении\n'
            'СНМ можно представить в виде графа\n'
            'У каждого множества есть лидер (к которому напрямую или через другие элементы) подвешиваются элементы множества\n'
            'Тогда объединение двух множеств - это просто подвешивание лидера одного множества к другому множеству\n'
            '\n'
            'p - массив предков, d - массив рангов\n'
            '\n'
            'В приведённом ниже коде используются ранговая эвристика и эвристика сжатия путей\n'
            '1) Ранговая эвристика: подвешивать лучше меньшее к большему (здесь это производится не по размерам множеств, а по рангам, но сути не меняет)\n'
            '2) Эвристика сжатия путей: хорошо, когда все вершины подвешены к лидеру напрямую\n'
            '\n'
            'vector<int> p, d;\n'
            '\n'
            'void init(int n) {\n'
            '    d.assign(n, 0);\n'
            '    p.resize(n);\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        p[i] = i;\n'
            '    }\n'
            '}\n'
            '\n'
            'int get_par(int v) {\n'
            '    if (v == p[v]) {\n'
            '        return v;\n'
            '    }\n'
            '    return p[v] = get_par(p[v]);\n'
            '}\n'
            '\n'
            'void unite(int v, int u) {\n'
            '    u = get_par(u);\n'
            '    v = get_par(v);\n'
            '    if (u != v) {\n'
            '        if (d[u] > d[v]) {\n'
            '            swap(u, v);\n'
            '        }\n'
            '        p[u] = v;\n'
            '        if (d[u] == d[v]) {\n'
            '            d[v]++;\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'Функции на объединении можно считать в unite (можно завести массив значений функций для элементов, как массив d)\n'
            'Тогда если мы хотим узнать значение функции в множестве, где лежит элемент v, нам нужно найти значение в массиве функции для get_par(v)\n'
            '\n'
            'СНМ используется в алгоритме Тарьяна (см. lca) и для построения минимального остовного дерева (см. mst)\n')


def mst():
    return ('Минимальное остовное дерево\n'
            '\n'
            'Минимальное остовное дерево (в взвешенном графе) - это граф, соединяющий все вершины исходного графа и имеющий наименьшую длину\n'
            'В невзвешенном графе дерево должно иметь наименьшее кол-во рёбер (n - 1)\n'
            '\n'
            'Лемма о разрезе и критерий Тарьяна:\n'
            'Разобьём множество вершин графа на любые два множества и построим минимальное остовное дерево\n'
            'Тогда будут какие-то рёбра на разрезе, соединяющие два множества\n'
            'Утверждается, что минимальное среди таких рёбер будет принадлежать какому-нибудь минимальному остовному дереву\n'
            'Допустим, мы не взяли минимальное ребро (v, u), тогда существует другой путь, соединяющий эти две вершины (ведь это дерево)\n'
            'Пусть этот путь будет проходит через разрез по ребру (x, y)\n'
            'Теперь, если мы уберём ребро (x, y) и добавим ребро (v, u), то дерево всё равно останется минимальным, потому что ребро (v, u) - минимальное ребро\n'
            'Критерий Тарьяна звучит так: Остовное дерево минимально тогда и только тогда, когда для любого ребра, не принадлежащего остову, цикл, образуемый этим ребром при добавлении к остову, не содержит рёбер тяжелее этого ребра\n'
            'Если цикл имеет рёбра больше, то мы можем улучшить ответ, убрав ребро тяжелее текущего и добавив текущее в дерево\n'
            '\n'
            'Алгоритм Прима:\n'
            'Алгоритм Прима каждый раз выбирает минимальное ребро, не ведущее в уже построенную компоненту\n'
            'Код с восстановлением ответа (список рёбер):\n'
            'const int INF = 1e9;\n'
            'signed main() {\n'
            '    int n, m;\n'
            '    cin >> n >> m;\n'
            '    vector<vector<pair<int, int>>> g(n);\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int v, u, w;\n'
            '        cin >> v >> u >> w;\n'
            '        v--;\n'
            '        u--;\n'
            '        g[v].push_back({u, w});\n'
            '        g[u].push_back({v, w});\n'
            '    }\n'
            '    vector<int> d(n, INF);\n'
            '    d[0] = 0;\n'
            '    set<pair<int, int>> s;\n'
            '    s.insert({0, 0});\n'
            '    vector<bool> added(n);\n'
            '    added[0] = true;\n'
            '    ll minost = 0;\n'
            '    vector<int> p(n, -1);\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        int v = s.begin()->second;\n'
            '        minost += s.begin()->first;\n'
            '        s.erase(s.begin());\n'
            '        added[v] = true;\n'
            '        for (auto& k: g[v]) {\n'
            '            int u = k.first, w = k.second;\n'
            '            if (added[u]) {\n'
            '                continue;\n'
            '            }\n'
            '            if (d[u] > w) {\n'
            '                s.erase({d[u], u});\n'
            '                d[u] = w;\n'
            '                p[u] = v;\n'
            '                s.insert({d[u], u});\n'
            '            }\n'
            '        }\n'
            '    }\n'
            '    cout << minost << el;\n'
            '    vector<pair<int, int>> ans;\n'
            '    for (int i = 1; i < n; i++) {\n'
            '        ans.push_back({i + 1, p[i] + 1});\n'
            '    }\n'
            '    for (pair<int, int> p: ans) {\n'
            '        cout << p.first << \' \' << p.second << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Алгоритм Краскала:\n'
            'Алгоритм Краскала объединяет ещё не объединённые вершины\n'
            'Рёбра сортируются по весу и добавляются по одному в СНМ\n'
            'Код с восстановлением ответа:\n'
            'vector<int> p, d;\n'
            '\n'
            'void init(int n) {\n'
            '    d.assign(n, 0);\n'
            '    p.resize(n);\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        p[i] = i;\n'
            '    }\n'
            '}\n'
            '\n'
            'int get_par(int v) {\n'
            '    if (v == p[v]) {\n'
            '        return v;\n'
            '    }\n'
            '    return p[v] = get_par(p[v]);\n'
            '}\n'
            '\n'
            'void unite(int v, int u) {\n'
            '    u = get_par(u);\n'
            '    v = get_par(v);\n'
            '    if (u != v) {\n'
            '        if (d[u] > d[v]) {\n'
            '            swap(u, v);\n'
            '        }\n'
            '        p[u] = v;\n'
            '        if (d[u] == d[v]) {\n'
            '            d[v]++;\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'struct Edge {\n'
            '    int v, u, w;\n'
            '    Edge() {}\n'
            '    Edge(int v_, int u_, int w_): v(v_), u(u_), w(w_) {}\n'
            '    bool operator<(const Edge& a) const {\n'
            '        return w < a.w;\n'
            '    }\n'
            '};\n'
            '\n'
            'signed main() {\n'
            '    int n, m;\n'
            '    cin >> n >> m;\n'
            '    vector<Edge> edges;\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int v, u, w;\n'
            '        cin >> v >> u >> w;\n'
            '        v--;\n'
            '        u--;\n'
            '        edges.push_back(Edge(v, u, w));\n'
            '    }\n'
            '    init(n);\n'
            '    sort(edges.begin(), edges.end());\n'
            '    ll minost = 0;\n'
            '    vector<Edge> ans;\n'
            '    for (const Edge& e: edges) {\n'
            '        if (get_par(e.v) != get_par(e.u)) {\n'
            '            unite(e.v, e.u);\n'
            '            minost += e.w;\n'
            '            ans.push_back(e);\n'
            '        }\n'
            '    }\n'
            '    cout << minost << el;\n'
            '    for (const Edge& e: ans) {\n'
            '        cout << e.v + 1 << \' \' << e.u + 1 << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'В конце нужно проверить, сколько рёбер в структуре. Если кол-во рёбер != n - 1, то граф несвязный, остовное дерево не построено\n'
            '\n'
            'Также можно строить несколько минимальных остовных деревьев\n'
            'Сначала нужно построить минимальное дерево, а потом в цикле убирать по одному (или больше, если нужно много деревьев) ребру из дерева и заменять его другим в списке рёбер\n'
            'В конце нужно проверять существование нового остовного дерева (написано выше)\n')


def Floyd():
    return ('Алгоритм Флойда-Уоршелла\n'
            '\n'
            'Алгоритм Флойда-Уоршелла ищет кратчайшие расстояния между всеми парами вершин (веса могут быть отрицательными)\n'
            'Алгоритм использует матрицу смежности\n'
            'Алгоритм перебирает все пары вершин, а так же некоторую серединную вершину (путь между двумя вершинами обязан пройти через эту вершину)\n'
            '\n'
            'vector<vector<int>> m(n, vector<int>(n));\n'
            'cin >> m\n'
            'vector<vector<int>> dp = m;\n'
            'for (int k = 0; k < n; k++) {\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        for (int j = 0; j < n; j++) {\n'
            '            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n'
            '        }\n'
            '    }\n'
            '}\n'
            'cout << dp[start][finish] << el;\n'
            '\n'
            'Алгоритм Флойда позволяет транзитивное замыкание графа (строить матрицу dp, для которой dp[i][j] = 1, если можно добраться от вершины i до j) \n'
            'Достаточно лишь хранить bool и поменять строку на dp[i][j] = dp[i][j] || (dp[i][k] && dp[k][j]);\n'
            'Через транзитивное замыкание можно сказать, есть ли в графе цикл (если есть, то dp[i][i] = 1 для какого-то i)\n')


def top_sort():
    return ('Топологическая сортировка\n'
            '\n'
            'Топологическая сортировка применяется на ориентированных графах\n'
            'Результат сортировки - массив вершин, в котором выполняется условие "рёбра идут только вправо" (рёбра идут от вершин в начале к вершинам в конце)\n'
            'Сортировка невозможна в графе с циклами\n'
            '\n'
            'Сортировка пишется с использованием dfs\n'
            'Код:\n'
            'int n;\n'
            'vector<bool> used;\n'
            'vector<int> ts;\n'
            '\n'
            'void dfs_ts(int v) {\n'
            '    used[v] = true;\n'
            '    for (int u : g[v]) {\n'
            '        if (!used[u])\n'
            '            dfs_ts(u);\n'
            '    }\n'
            '    ts.push_back(v);\n'
            '}\n'
            '\n'
            'void top_sort() {\n'
            '    used.assign(n, false);\n'
            '    for (int v = 0; v < n; v++)\n'
            '        if (!used[v])\n'
            '            dfs_ts(v);\n'
            '    reverse(ts.begin(), ts.end());\n'
            '}\n'
            '\n'
            'Также для топологической сортировки существует алгоритм Кана\n'
            'Его идея заключается в том, что на каждом шаге мы точно можем добавить в сортировку вершину с входящей степенью 0\n'
            'А после добавления этой вершины удаляем все рёбра, идущие из этой вершины\n'
            '\n'
            'int n;\n'
            'vector<vector<int>> graph;\n'
            'vector<int> ts;\n'
            'vector<int> used;\n'
            'vector<int> in;\n'
            '\n'
            'void topsort() {\n'
            '    queue<int> q;\n'
            '    for (int i = 0; i < n; ++i) {\n'
            '        if (!in[i]) {\n'
            '            q.push(i);\n'
            '        }\n'
            '    }\n'
            '    while (!q.empty()) {\n'
            '        int v = q.front();\n'
            '        q.pop();\n'
            '        ts.push_back(v + 1);\n'
            '        for (int u : graph[v]) {\n'
            '            in[u]--;\n'
            '            if (!in[u]) {\n'
            '                q.push(u);\n'
            '            }\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int m;\n'
            '    cin >> n >> m;\n'
            '    graph.resize(n);\n'
            '    used.resize(n);\n'
            '    in.resize(n);\n'
            '    for (int i = 0; i < m; ++i) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        graph[v].push_back(u);\n'
            '        ++in[u];\n'
            '    }\n'
            '    topsort();\n'
            '    if (ts.size() != n) {\n'
            '        cout << "-1\\n"; // если в ответе есть не все вершины, то в графе есть цикл\n'
            '    }\n'
            '    else {\n'
            '        cout << ts << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Этот алгоритм позволяет найти минимальную лексикографическую топологическую сортировку\n'
            'Достаточно лишь заменить queue на какую-нибудь очередь с приоритетом (кучу, set,...) и каждый раз доставать из структуры вершину с наименьшим номером')


def dfs():
    return ('DFS - поиск в глубину\n'
            '\n'
            'dfs - это стандартный обход графа\n'
            '\n'
            'void dfs(int v, int d = 0) {\n'
            '    used[v] = true;\n'
            '    depth[v] = d;\n'
            '    for (int u : g[v]) {\n'
            '        if (!used[u]) {\n'
            '            dfs(u, d + 1);\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'Обычно dfs используется для прохода по графу и подсчёта какого-нибудь дп, функции и т.д.\n'
            '\n'
            'Некоторые задачи:\n'
            '1. Раскраска графа в 2 цвета\n'
            '   Граф можно раскрасить в 2 цвета, если он двудолен\n'
            '   Эту задачу можно решить жадным алгоритмом (просто попробовать раскрасить в 2 цвета)\n'
            '   Если мы встречаем вершину, которая уже покрашена, а сейчас мы знаем, что она должна быть покрашены в другой цвет, то граф не двудолен (есть цикл нечётной длины)\n'
            '2. Нахождение цикла в неориентированном графе\n'
            '   Чтобы найти цикл можно запустить dfs\n'
            '   Если мы находим вершину, которая уже посещена, и мы не пришли из неё, то цикл найден\n'
            '3. Нахождение цикла в ориентированном графе\n'
            '   Красим граф в 3 цвета:\n'
            '   Заходим в вершину, её цвет равен 1\n'
            '   Проходим по всем смежным вершинам\n'
            '   Если цвет смежной вершины равен 0, то запускаем dfs из неё\n'
            '   Если цвет равен 1, то мы нашли цикл\n'
            '   После цикла присваиваем вершине цвет 2\n'
            '4. Нахождение диаметра дерева (самый длинный путь)\n'
            '   Функция maxlen:\n'
            '      Будем запускать dfs и запоминать расстояния от начальной вершины до всех остальных\n'
            '      Потом выведем позицию максимума в списке этих расстояний\n'
            '   Теперь два раза запустим функцию\n'
            '   Первый раз (v1) от 0\n'
            '   Второй раз (v2) от v1\n'
            '   (v1, v2) - это ответ (пара вершин)\n'
            '5. Поиск компонент связности\n'
            '   Компонента связности - множество вершин, между каждой парой которых есть путь\n'
            '   Запустим dfs\n'
            '   Все вершины, которые он посетил - одна компонента связности\n'
            '   Запустим из непосещённой вершины, получим ещё одну компоненту\n'
            '6. Проверка, является ли одна вершина в дереве предком другой\n'
            '   Для этого будем сохранять времена входа и выхода для каждой вершины\n'
            '   Вершина v является предком u, если tin[v] <= tin[u] && tout[v] >= tout[u]\n')


def bfs():
    return ('BFS - поиск в ширину\n'
            '\n'
            'bfs ищет кратчайшие расстояния от одной вершины до остальных\n'
            'Код bfs (поиск кратчайшего пути между вершинами a и b + восстановление пути):\n'
            'const int INF = 1e9;\n'
            'signed main() {\n'
            '    int n, m, a, b;\n'
            '    cin >> n >> m >> a >> b;\n'
            '    a--;\n'
            '    b--;\n'
            '    vector<int> g(n);\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int u, v;\n'
            '        cin >> u >> v;\n'
            '        u--;\n'
            '        v--;\n'
            '        g[u].push_back(v);\n'
            '        g[v].push_back(u);\n'
            '    }\n'
            '    vector<int> d(n, INF);\n'
            '    vector<int> p(n, -1);\n'
            '    queue<int> q;\n'
            '    q.push(a);\n'
            '    d[a] = 0;\n'
            '    while (!q.empty()) {\n'
            '        int v = q.front();\n'
            '        q.pop();\n'
            '        for (int u : g[v]) {\n'
            '            if (d[u] > d[v] + 1) {\n'
            '                d[u] = d[v] + 1;\n'
            '                q.push(u);\n'
            '                p[u] = v;\n'
            '            }\n'
            '        }\n'
            '    }\n'
            '    if (d[b] == INF) {\n'
            '        cout << "-1\\n";\n'
            '    }\n'
            '    else {\n'
            '        cout << d[b] << el;\n'
            '        vector<int> ans;\n'
            '        int cur = b;\n'
            '        while (cur != -1) {\n'
            '            ans.push_back(cur + 1);\n'
            '            cur = p[cur];\n'
            '        }\n'
            '        reverse(ans.begin(), ans.end());\n'
            '        cout << ans << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            'Важно, что bfs ищет длину кратчайшего пути в РЁБРАХ, поэтому он применяется только на невзвешенных графах\n'
            'Это связано с самим алгоритмом\n'
            'Сначала bfs ищет кратчайшие пути длины 1, потом длины 2 и т.д.\n'
            '\n'
            'У bfs есть модификации:\n'
            '1. 0-1 BFS\n'
            '   Если рёбра имеют вес только 0 или 1, то нужно использовать не queue, a deque\n'
            '   Если ребро имеет вес 0, то нужно добавлять его в начало (push_front), иначе в конец (push_back)\n'
            '2. 0-k BFS\n'
            '   BFS может заменить Дейкстру при небольших k\n'
            '   Мы имеем k+1 очередь, одна из них текущая (расстояние d)\n'
            '   Если мы находим вершину c расстоянием x, то мы кладём её в очередь с вершинами d+x\n'
            '   Когда текущая очередь заканчивается, мы переходим в очередь d+1, а прошлая очередь становится максимальной\n'
            '   Пример:\n'
            '   Максимум был d+5\n'
            '   Текущая очередь d закончилась\n'
            '   Мы переходим в очередь d+1, а прошлая очередь теперь равна d+6\n')


def persistent_st():
    return ('Персистентное дерево отрезков\n'
            '\n'
            'Персистентное ДО сохраняет все свои версии (версии появляются в процессе запросов изменения)\n'
            '\n'
            'Чтобы сохранять версии, при запросе изменения нужно менять не сами вершины, а их копии\n'
            'Для этого ДО будет построено на указателях\n'
            'Когда мы заходим в вершину в запросе изменения, мы сначала копируем её, а потом делаем изменение в копии\n'
            'Сам запрос будет возвращать указатель - корень новой версии дерева\n'
            'Чтобы иметь доступ ко всем версиям дерева, можно класть все корни в массив\n'
            '\n'
            'Пример (персистентное ДО на сумму):\n'
            'vector<int> a;\n'
            '\n'
            'struct Node {\n'
            '    int sum;\n'
            '    Node* l;\n'
            '    Node* r;\n'
            '    Node() {\n'
            '        sum = 0;\n'
            '        l = nullptr;\n'
            '        r = nullptr;\n'
            '    }\n'
            '    Node(const Node* v) {\n'
            '        sum = v->sum;\n'
            '        l = v->l;\n'
            '        r = v->r;\n'
            '    }\n'
            '};\n'
            '\n'
            'Node* build(Node* v, int l, int r) {\n'
            '    if (r - l == 1) {\n'
            '        v->sum = a[l];\n'
            '        return v;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    v->l = new Node();\n'
            '    v->r = new Node();\n'
            '    v->l = build(v->l, l, m);\n'
            '    v->r = build(v->r, m, r);\n'
            '    v->sum = v->l->sum + v->r->sum;\n'
            '    return v;\n'
            '}\n'
            '\n'
            'int ask(Node* v, int l, int r, int askl, int askr) {\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return 0;\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        return v->sum;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    return ask(v->l, l, m, askl, askr) + ask(v->r, m, r, askl, askr);\n'
            '}\n'
            '\n'
            'Node* change(const Node* v, int l, int r, int pos, int val) {\n'
            '    Node* u = new Node(v);\n'
            '    if (r - l == 1) {\n'
            '        u->sum = val;\n'
            '        return u;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    if (pos < m) {\n'
            '        u->l = change(u->l, l, m, pos, val);\n'
            '    }\n'
            '    else {\n'
            '        u->r = change(u->r, m, r, pos, val);\n'
            '    }\n'
            '    u->sum = u->l->sum + u->r->sum;\n'
            '    return u;\n'
            '}\n'
            '\n'
            'Персистентое ДО может применяться для решения различных задач за хорошую асимптотику и в онлайне:\n'
            '1. K-ая порядковая статистика на отрезке (нужно найти число, которое будет на k-ом месте, если отрезок отсортировать)\n'
            '   Эту задачу можно решить при помощи merge-sort tree за O(log(n) ^ 2) на запрос, решение с персистентным ДО лучше\n'
            '   Сначала сожмём числа (отсортируем массив, удалим повторения и каждому числу из исходного массива сопоставим индекс в сжатом массиве)\n'
            '   Сделаем ДО на сумму, в листе i будет хранить кол-во чисел i в массиве в текущий момент\n'
            '   Заметим, что не применяя персистентность мы можем искать ответ на префиксе (для этого нужно спуститься по дереву и найти позицию k-ого числа)\n'
            '   Сделаем дерево персистентным. Пройдём по массиву (по не сжатому) и каждую версию будем добавлять по одному числу в ДО (увеличиваем значение в листе на 1)\n'
            '   Сделав дерево персистентным, мы можем искать ответ на отрезке: будем одновременно спускаться по версии r и версии l - 1\n'
            '   Тогда при проверке суммы левого сына во время спуска мы будем брать разность сумм двух версий\n'
            '   Так мы получаем реальное кол-во чисел на отрезке, поэтому можем найти ответ\n'
            'Код:\n'
            'template <class T> void uniq(vector<T>& a) {sort(a.begin(), a.end()); a.resize(unique(a.begin(), a.end()) - a.begin());}\n'
            '\n'
            'struct Node {\n'
            '    int sum;\n'
            '    Node* l;\n'
            '    Node* r;\n'
            '    Node() {\n'
            '        sum = 0;\n'
            '        l = nullptr;\n'
            '        r = nullptr;\n'
            '    }\n'
            '    Node(const Node* v) {\n'
            '        sum = v->sum;\n'
            '        l = v->l;\n'
            '        r = v->r;\n'
            '    }\n'
            '};\n'
            '\n'
            'vector<int> a;\n'
            'vector<int> uniq_a;\n'
            'vector<Node*> roots;\n'
            '\n'
            'Node* build(Node* v, int l, int r) {\n'
            '    if (r - l == 1) {\n'
            '        v->sum = 0;\n'
            '        return v;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    v->l = new Node();\n'
            '    v->r = new Node();\n'
            '    v->l = build(v->l, l, m);\n'
            '    v->r = build(v->r, m, r);\n'
            '    v->sum = v->l->sum + v->r->sum;\n'
            '    return v;\n'
            '}\n'
            '\n'
            'Node* change(const Node* v, int l, int r, int pos, int delta) {\n'
            '    Node* u = new Node(v);\n'
            '    if (r - l == 1) {\n'
            '        u->sum += delta;\n'
            '        return u;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    if (pos < m) {\n'
            '        u->l = change(u->l, l, m, pos, delta);\n'
            '    }\n'
            '    else {\n'
            '        u->r = change(u->r, m, r, pos, delta);\n'
            '    }\n'
            '    u->sum = u->l->sum + u->r->sum;\n'
            '    return u;\n'
            '}\n'
            '\n'
            'int kth(Node* v_r, Node* v_l, int l, int r, int k) {\n'
            '    if (r - l == 1) {\n'
            '        return l;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    int val = v_r->l->sum - v_l->l->sum;\n'
            '    if (val >= k) {\n'
            '        return kth(v_r->l, v_l->l, l, m, k);\n'
            '    }\n'
            '    return kth(v_r->r, v_l->r, m, r, k - val);\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    a.resize(n);\n'
            '    cin >> a;\n'
            '    uniq_a = a;\n'
            '    uniq(uniq_a);\n'
            '    int N = uniq_a.size();\n'
            '    Node* root = new Node();\n'
            '    root = build(root, 0, N);\n'
            '    roots.push_back(root);\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        int index = lower_bound(all(uniq_a), a[i]) - uniq_a.begin();\n'
            '        Node* nroot = change(root, 0, N, index, 1);\n'
            '        roots.push_back(nroot);\n'
            '        root = nroot;\n'
            '    }\n'
            '    int q;\n'
            '    cin >> q;\n'
            '    REP(q) {\n'
            '        int l, r, k;\n'
            '        cin >> l >> r >> k;\n'
            '        cout << uniq_a[kth(roots[r], roots[l - 1], 0, N, k)] << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            '2. Кол-во различных чисел на отрезке\n'
            '   Для позиции i массива будем хранить 1, если это последнее вхождение числа a[i] на префиксе [0, i]\n'
            '   При переходе к следующему префиксу, мы должны занулить предыдущее вхождение и поставить 1 на новую позицию\n'
            '   Построим на этом массиве персистентное ДО\n'
            '   Тогда для запроса [l, r] идём версию в r и считаем сумму на [l, r] в этой версии\n'
            '   Код не привожу, потому что на больших тестах мой код не работает (не знаю, почему)\n'
            '   Если задачу можно решить в оффлайне, то лучшее решение - алгоритм Мо (описано в Mo)\n'
            '   Также можно решить с использованием merge-sort tree (см. mergesort_tree)\n')


def euler():
    return ('Эйлеровость\n'
            '\n'
            'Эйлеров путь - путь в графе, проходящий по всем рёбрам один раз\n'
            'Эйлеров цикл - эйлеров путь, начинающийся и заканчивающийся в одной вершине\n'
            '\n'
            'Условие существования эйлерова пути: степени всех вершин чётные или есть две вершины с нечётными степенями\n'
            'Условие существования эйлерова цикла: степени всех вершин чётные\n'
            '\n'
            'Для ориентированных графов:\n'
            'Цикл есть, если условие "кол-во рёбер, входящих в вершину равно кол-во рёбер исходящих из вершины" выполняется для всех вершин\n'
            'Путь есть, если выполняется условие для всех вершин, кроме двух: у одной кол-во входящих рёбер больше кол-ва исходящих на 1, у второй наоборот\n'
            '\n'
            'Для построения пути будем просто ходить по рёбрам графа ровно по одному разу\n'
            'Для этого заведём массив first[v], в котором будет храниться индекс первого непосещённого ребра из данной вершины\n'
            'Конечно, если есть две вершины с нечётными степенями, нужно запускать алгоритм из одной из них\n'
            'В конце каждого запуска алгоритма (для одной вершины) добавляем вершину в ответ, потому что мы прошли все рёбра из этой вершины и больше в неё не вернёмся\n'
            'Для ориентированных графов нужно запускаться из вершины, у которой кол-во исходящих рёбер больше кол-ва входящих (если такая есть, иначе из любой вершины)\n'
            'Также в ориентированном графе в конце нужно развернуть путь\n'
            '\n'
            'Код:\n'
            'struct Edge {\n'
            '    int u;\n'
            '    int index;\n'
            '\n'
            '    Edge() {}\n'
            '    Edge(int u_, int index_) {\n'
            '        u = u_;\n'
            '        index = index_;\n'
            '    }\n'
            '};\n'
            '\n'
            'vector<vector<Edge>> graph;\n'
            'vector<bool> used;\n'
            'vector<int> first;\n'
            'vector<int> ans;\n'
            '\n'
            'void euler(int v) {\n'
            '    while (first[v] < graph[v].size()) {\n'
            '        int i = first[v];\n'
            '        int u = graph[v][i].u;\n'
            '        int e = graph[v][i].index;\n'
            '        first[v]++;\n'
            '        if (!used[e]) {\n'
            '            used[e] = true;\n'
            '            euler(u);\n'
            '        }\n'
            '    }\n'
            '    ans.push_back(v + 1);\n'
            '}\n'
            '\n'
            'ПОКРЫТИЕ НЕОРИЕНТИРОВАННОГО ГРАФА МИНИМАЛЬНЫМ КОЛ-ВОМ ПУТЕЙ\n'
            'Для покрытия путями для начала найдём все вершины с нечётными степенями\n'
            'Соединим их в пары (мы нашли 4 вершины, проведём рёбра 1 - 2 и 3 - 4)\n'
            'Запишем эти пары куда-нибудь\n'
            'Теперь построим эйлеров цикл (мы можем это сделать, потому что все степени вершин чётные)\n'
            'Разобьём цикл по рёбрам, которые мы добавили в начале\n'
            'Мы получаем пути. Надо не забыть склеить последний путь с первым (потому что это один путь)\n'
            'Единственная проблема заключается в том, что мы можем разрезать по рёбрам, которые были в графе изначально\n'
            'Пример - граф отрезок. После считывания мы добавим КРАТНОЕ ребро, соединяя две вершины с нечётными степенями\n'
            'Избежать это можно, храня кол-во рёбер между двумя соседними вершинами (мы должны разрезать только одно ребро)\n'
            '\n'
            'Код функции main (не претендует на идеальность, работает не особо быстро из-за map):\n'
            'signed main() {\n'
            '    int n, m;\n'
            '    cin >> n >> m;\n'
            '    map<pair<int, int>, int> edges;\n'
            '    graph.resize(n);\n'
            '    first.resize(n);\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        graph[v].push_back(Edge(u, i));\n'
            '        graph[u].push_back(Edge(v, i));\n'
            '        edges[{v, u}]++;\n'
            '        edges[{u, v}]++;\n'
            '    }\n'
            '    vector<int> n_vertex;\n'
            '    map<pair<int, int>, bool> to_del;\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        if (graph[i].size() % 2) {\n'
            '            n_vertex.push_back(i);\n'
            '        }\n'
            '    }\n'
            '    int cnt_edges = m;\n'
            '    for (int i = 1; i < n_vertex.size(); i += 2) {\n'
            '        int v = n_vertex[i - 1];\n'
            '        int u = n_vertex[i];\n'
            '        graph[v].push_back(Edge(u, cnt_edges));\n'
            '        graph[u].push_back(Edge(v, cnt_edges));\n'
            '        cnt_edges++;\n'
            '        to_del[{v + 1, u + 1}] = true;\n'
            '        to_del[{u + 1, v + 1}] = true;\n'
            '        edges[{v, u}]++;\n'
            '        edges[{u, v}]++;\n'
            '    }\n'
            '    used.resize(cnt_edges);\n'
            '    euler(0);\n'
            '    vector<vector<int>> paths;\n'
            '    paths.push_back({ans[0]});\n'
            '    for (int i = 1; i < ans.size(); i++) {\n'
            '        if (to_del.find({ans[i], ans[i - 1]}) != to_del.end()) {\n'
            '            if (edges[{ans[i] - 1, ans[i - 1] - 1}] <= 1) {\n'
            '                paths.push_back({});\n'
            '            }\n'
            '            paths[paths.size() - 1].push_back(ans[i]);\n'
            '            edges[{ans[i] - 1, ans[i - 1] - 1}]--;\n'
            '            edges[{ans[i - 1] - 1, ans[i] - 1}]--;\n'
            '        }\n'
            '        else {\n'
            '            paths[paths.size() - 1].push_back(ans[i]);\n'
            '        }\n'
            '    }\n'
            '    if (paths.size() > 1) {\n'
            '        cout << paths.size() - 1 << el;\n'
            '        for (int i : paths.back()) {\n'
            '            cout << i << \' \';\n'
            '        }\n'
            '        for (int i = 1; i < paths[0].size(); i++) {\n'
            '            cout << paths[0][i] << \' \';\n'
            '        }\n'
            '        cout << el;\n'
            '        for (int i = 1; i < paths.size() - 1; i++) {\n'
            '            for (int j : paths[i]) {\n'
            '                cout << j << \' \';\n'
            '            }\n'
            '            cout << el;\n'
            '        }\n'
            '    }\n'
            '    else {\n'
            '        cout << "1\\n";\n'
            '        for (int i : paths[0]) {\n'
            '            cout << i << \' \';\n'
            '        }\n'
            '        cout << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n')


def mitm():
    return ('Meet-in-the-middle\n'
            '\n'
            'MITM - это оптимизация перебора в множестве\n'
            'Вместо полного перебора всех значений производится перебор в половинах множества, а потом полученные значения совмещаются\n'
            '\n'
            'Примеры задач:\n'
            '1) Задача о рюкзаке (какой максимальный вес можно набрать) с огромными весами\n'
            '2) Разделить массив на два множества, чтобы разница сумм множеств была минимальной\n'
            '3) Найти в массиве множество, сумма которого, взятая по модулю Mod, максимальна\n'
            '\n'
            '1:\n'
            'Разобьём все предметы на две равные части (разница +-1)\n'
            'Для каждой части посчитаем все возможные суммы, которые мы может набрать, используя предметы этой части (перебор масок с проверкой, что сумма меньше, чем вместимость рюкзака)\n'
            'Отсортируем обе части (можно также сделать uniq)\n'
            'Теперь будем идти по суммам, полученным из первой части и искать максимальную сумму, которую мы можем взять из второй части (бинпоиск)\n'
            'Можно поддерживать и стоимости предметов, для этого нужно в процессе получения всех сумм делать пары (вес, стоимость)\n'
            'После получения всех сумм нужно отсортировать массив и удалить все пары, для которых мы можем набрать такой же вес, но бОльшую стоимость\n'
            'Тогда пары будут отсортированы и по весу, и по стоимости\n'
            'Код не привожу, но он очень похож на код второй и третьей задачи (только не надо забывать о проверке на то, что сумма весов не больше вместимости рюкзака)\n'
            '\n'
            '2:\n'
            'Опять же разобьём массив на две части\n'
            'Мы хотим набрать сумму наиболее близкую к sum / 2 (sum - сумма всех чисел массива)\n'
            'Для этого посчитаем для каждой части все возможные суммы, не превосходящие sum / 2\n'
            'Отсортируем и для каждой суммы первой части найдём максимальную сумму из второй части\n'
            'Код:\n'
            'll get_sum(int mask, const vector<int>& a) {\n'
            '    int cur = 1;\n'
            '    ll sum = 0;\n'
            '    int n = a.size();\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        if (cur & mask) {\n'
            '            sum += a[i];\n'
            '        }\n'
            '        cur = cur << 1;\n'
            '    }\n'
            '    return sum;\n'
            '}\n'
            '\n'
            'vector<ll> get_all_w(const vector<int>& a, ll w) {\n'
            '    vector<ll> res;\n'
            '    int n = a.size();\n'
            '    res.push_back(0);\n'
            '    for (int mask = 1; mask < (1 << n); mask++) {\n'
            '        ll sum = get_sum(mask, a);\n'
            '        if (sum <= w) {\n'
            '            res.push_back(sum);\n'
            '        }\n'
            '    }\n'
            '    return res;\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    vector<int> w1, w2;\n'
            '    ll sum = 0;\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        int x;\n'
            '        cin >> x;\n'
            '        if (i < n / 2) {\n'
            '            w1.push_back(x);\n'
            '        }\n'
            '        else {\n'
            '            w2.push_back(x);\n'
            '        }\n'
            '        sum += x;\n'
            '    }\n'
            '    ll half = sum / 2;\n'
            '    vector<ll> all_w1 = get_all_w(w1, half);\n'
            '    vector<ll> all_w2 = get_all_w(w2, half);\n'
            '    sort(all_w2.begin(), all_w2.end());\n'
            '    ll ans = 1e18;\n'
            '    for (ll sum1 : all_w1) {\n'
            '        ll need_sum = half - sum1;\n'
            '        ll sum2;\n'
            '        int ind = lower_bound(all_w2.begin(), all_w2.end(), need_sum) - all_w2.begin();\n'
            '        if (ind == all_w2.size() || all_w2[ind] > need_sum) {\n'
            '            ind--;\n'
            '        }\n'
            '        if (ind == -1) {\n'
            '            continue;\n'
            '        }\n'
            '        sum2 = all_w2[ind];\n'
            '        ans = min(abs(sum - 2 * (sum2 + sum1)), ans);\n'
            '    }\n'
            '    cout << ans << el;\n'
            '    return 0;\n'
            '}\n'
            '\n'
            '3:\n'
            'Разбиваем массив на две части\n'
            'Для каждой части считаем все возможные суммы по модулю Mod\n'
            'Сортируем суммы, делаем uniq\n'
            'Для каждой суммы из первой части ищем наибольшую возможную сумму из второй части (очевидно, она должна быть меньше или равна, чем Mod - sum1 - 1)\n'
            'Код:\n'
            'll Mod;\n'
            '\n'
            'll get_sum(int mask, const vector<ll>& a) {\n'
            '    ll sum = 0;\n'
            '    int n = a.size();\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        if ((1 << i) & mask) {\n'
            '            sum += (a[i] % Mod);\n'
            '            sum %= Mod;\n'
            '        }\n'
            '    }\n'
            '    return sum;\n'
            '}\n'
            '\n'
            'vector<ll> get_all_sums(const vector<ll>& a) {\n'
            '    vector<ll> res;\n'
            '    int n = a.size();\n'
            '    res.reserve((1 << n));\n'
            '    for (int mask = 0; mask < (1 << n); mask++) {\n'
            '        res.push_back(get_sum(mask, a));\n'
            '    }\n'
            '    return res;\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n;\n'
            '    cin >> n >> Mod;\n'
            '    vector<ll> a1, a2;\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        ll x;\n'
            '        cin >> x;\n'
            '        if (i < n / 2) {\n'
            '            a1.push_back(x);\n'
            '        }\n'
            '        else {\n'
            '            a2.push_back(x);\n'
            '        }\n'
            '    }\n'
            '    vector<ll> all1 = get_all_sums(a1);\n'
            '    vector<ll> all2 = get_all_sums(a2);\n'
            '    uniq(all1);\n'
            '    uniq(all2);\n'
            '    ll ans = 0;\n'
            '    for (ll cur : all1) {\n'
            '        int index = upper_bound(all(all2), Mod - cur - 1) - all2.begin() - 1;\n'
            '        if (index == -1) {\n'
            '            continue;\n'
            '        }\n'
            '        ans = max(ans, (cur + all2[index]) % Mod);\n'
            '    }\n'
            '    cout << ans << el;\n'
            '    return 0;\n'
            '}\n')


def condensation():
    return ('Конденсация\n'
            '\n'
            'Конденсация - это выделение в графе компонент сильной связности\n'
            'Компонента сильной связности (в ориентированном графе) - множество вершин, в котором от каждой вершины можно добраться до любой другой\n'
            '\n'
            'Чтобы выделить компоненты, нужно сначала сделать top_sort (граф может быть с циклами, но это не важно)\n'
            'Теперь нужно транспонировать граф (развернуть все рёбра). Это можно сделать ещё при вводе\n'
            'После этого пройдём по транспонированному графу в порядке top_sort\n'
            'Все вершины, которые мы прошли за один запуск dfs - это одна компонента сильной связности\n'
            '\n'
            'По конденсации можно построить граф (сжать каждую компоненту в вершину)\n'
            'Такой граф - дерево\n'
            'Если требуется, чтобы в конденсации не было кратных рёбер, можно хранить map для добавленных рёбер между компонентами\n'
            '\n'
            'Код с сжатием в вершины:\n'
            'vector<vector<int>> graph, r_graph, comp_graph;\n'
            'vector<int> comp;\n'
            'vector<int> ts;\n'
            'vector<bool> used;\n'
            'int n;\n'
            '\n'
            'void dfs(int v) {\n'
            '    used[v] = true;\n'
            '    for (int u : graph[v]) {\n'
            '        if (!used[u]) {\n'
            '            dfs(u);\n'
            '        }\n'
            '    }\n'
            '    ts.push_back(v);\n'
            '}\n'
            '\n'
            'void top_sort() {\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        if (!used[i]) {\n'
            '            dfs(i);\n'
            '        }\n'
            '    }\n'
            '    reverse(ts.begin(), ts.end());\n'
            '}\n'
            '\n'
            'void dfs_cond(int v, int cur_comp) {\n'
            '    used[v] = true;\n'
            '    comp[v] = cur_comp;\n'
            '    for (int u : r_graph[v]) {\n'
            '        if (!used[u]) {\n'
            '            dfs_cond(u, cur_comp);\n'
            '        }\n'
            '        else if (comp[u] != cur_comp) {\n'
            '            comp_graph[comp[u]].push_back(cur_comp);\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int m;\n'
            '    cin >> n >> m;\n'
            '    graph.resize(n);\n'
            '    r_graph.resize(n);\n'
            '    comp.resize(n);\n'
            '    used.resize(n);\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        graph[v].push_back(u);\n'
            '        r_graph[u].push_back(v);\n'
            '    }\n'
            '    top_sort();\n'
            '    used.assign(n, false);\n'
            '    int cur_comp = 0;\n'
            '    for (int i : ts) {\n'
            '        if (!used[i]) {\n'
            '            comp_graph.push_back({});\n'
            '            dfs_cond(i, cur_comp);\n'
            '            cur_comp++;\n'
            '        }\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Задача о минимальном достижимом числе для каждой вершины:\n'
            'int n, m;\n'
            'vector<vector<int>> g;\n'
            'vector<int> used;\n'
            'vector<int> ts;\n'
            'vector<vector<int>> rg;\n'
            'vector<int> comp;\n'
            'vector<vector<int>> cg;\n'
            'vector<int> num; // числа в исходных вершинах\n'
            'vector<int> numcond; // числа в сжатых вершинах\n'
            'vector<int> dp; // ответ для сжатых\n'
            'vector<int> ans; // ответ для исходных\n'
            '\n'
            'void dfs(int v) {\n'
            '    used[v] = 1;\n'
            '    for (int u: g[v]) {\n'
            '        if (!used[u]) {\n'
            '            dfs(u);\n'
            '        }\n'
            '    }\n'
            '    used[v] = 2;\n'
            '    ts.push_back(v);\n'
            '}\n'
            '\n'
            'void dfscond(int v, int cur_comp) {\n'
            '    used[v] = 1;\n'
            '    comp[v] = cur_comp;\n'
            '    for (int u: rg[v]) {\n'
            '        if (!used[u]) {\n'
            '            dfscond(u, cur_comp);\n'
            '        }\n'
            '        else if (cur_comp != comp[u]) {\n'
            '            cg[comp[u]].push_back(cur_comp);\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    cin >> n >> m;\n'
            '    g.resize(n);\n'
            '    rg.resize(n);\n'
            '    used.resize(n);\n'
            '    comp.resize(n);\n'
            '    num.resize(n);\n'
            '    ans.resize(n);\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int u, v;\n'
            '        cin >> u >> v;\n'
            '        g[u - 1].push_back(v - 1);\n'
            '        rg[v - 1].push_back(u - 1);\n'
            '    }\n'
            '    cin >> num;\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        if (!used[i]) {\n'
            '            dfs(i);\n'
            '        }\n'
            '    }\n'
            '    reverse(ts.begin(), ts.end());\n'
            '    used.assign(n, false);\n'
            '    int cur_comp = 0;\n'
            '    for (int v: ts) {\n'
            '        if (!used[v]) {\n'
            '            cg.push_back(vector<int>());\n'
            '            dfscond(v, cur_comp);\n'
            '            cur_comp++;\n'
            '        }\n'
            '    }\n'
            '    numcond.resize(cur_comp, INT_MAX);\n'
            '    dp.resize(cur_comp);\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        numcond[comp[i]] = min(numcond[comp[i]], num[i]);\n'
            '    }\n'
            '    for (int i = cur_comp - 1; i >= 0; i--) {\n'
            '        dp[i] = numcond[i];\n'
            '        for (int v: cg[i]) {\n'
            '            dp[i] = min(dp[i], dp[v]);\n'
            '        }\n'
            '    }\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        ans[i] = dp[comp[i]];\n'
            '    }\n'
            '    return 0;\n'
            '}\n')


def two_sat():
    return ('2-SAT\n'
            '\n'
            '2-SAT (2-CNF) - это задача о подборе значений булевым переменным, чтобы выражение, состоящее из конъюнкций дизъюнкций\n'
            'Выражение может быть таким: (a1 | not a2) & (a2 | a3) & (not a1 | a1)\n'
            '\n'
            'Создадим граф. Для каждой переменной сделаем две вершины: ai и not ai\n'
            'Выражение (a1 | a2) можно преобразовать в (not a1 -> a2) & (not a2 -> a1)\n'
            'Также нужно учитывать изначальные отрицания у переменных\n'
            'Пример: (not a3 | a4) переходит в (a3 -> a4) & (not a4 -> not a3)\n'
            'Теперь импликации показывают направленные рёбра, которые нужно провести (от первой переменной к второй)\n'
            '\n'
            'Если после создания графа x достижим из not x, и not x достижим из x, то решения для данного выражения нет\n'
            'Это условие можно представить по-другому: x и not x не должны лежать в одной компоненте сильной связности\n'
            'Проведём конденсацию (для каждой вершины найдём номер компоненты)\n'
            'Пройдём по всем переменным\n'
            'Если comp[x] < comp[not x], то x = 1, иначе x = 0\n')


def Ford_Bellman():
    return ('Алгоритм Форда-Беллмана\n'
            '\n'
            'Алгоритм Форда-Беллмана ищет кратчайшие расстояния от одной вершины до всех остальных\n'
            'Он похож на алгоритм Дейкстры, но единицей выступает не вершина, а ребро\n'
            '\n'
            'За одну итерацию алгоритма алгоритм ищет кратчайшие пути длины i + 1 (в рёбрах)\n'
            'Сам алгоритм заключается в переборе всех рёбер и релаксации в процессе перебора\n'
            '\n'
            'const int INF = 1e9;\n'
            '\n'
            'struct Edge {\n'
            '    int v, u, w;\n'
            '    Edge() {}\n'
            '    Edge(int v_, int u_, int w_): v(v_), u(u_), w(w_) {}\n'
            '};\n'
            '\n'
            'signed main() {\n'
            '    int n, m;\n'
            '    cin >> n >> m;\n'
            '    vector<Edge> edges;\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int v, u, w;\n'
            '        cin >> v >> u >> w;\n'
            '        u--;\n'
            '        v--;\n'
            '        edges.push_back(Edge(v, u, w));\n'
            '    }\n'
            '    vector<int> d(n, INF);\n'
            '    d[0] = 0;\n'
            '    for (int i = 0; i < n - 1; i++) {\n'
            '        bool was_change = false;\n'
            '        for (auto &e: edges) {\n'
            '            if (d[e.v] != INF && d[e.u] > d[e.v] + e.w) {\n'
            '                d[e.u] = d[e.v] + e.w;\n'
            '                was_change = true;\n'
            '            }\n'
            '        }\n'
            '        if (!was_change) {\n'
            '            break;\n'
            '        }\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            'В массиве d в конце будут лежать расстояния до всех вершин\n'
            '\n'
            'Алгоритм позволяет искать кратчайшие пути, состоящие из ровно k рёбер, от одной вершины до остальных\n'
            'Для этого нужно сделать у массива d второе измерение - кол-во рёбер в пути (ведь кратчайший путь может состоять и из одного ребра, но нам нужно ровно k рёбер)\n'
            '\n'
            'const int INF = 1e9;\n'
            '\n'
            'struct Edge {\n'
            '    int v, u;\n'
            '    int w;\n'
            '    Edge() {}\n'
            '    Edge(int v_, int u_, int w_) {\n'
            '        v = v_;\n'
            '        u = u_;\n'
            '        w = w_;\n'
            '    }\n'
            '};\n'
            '\n'
            'signed main() {\n'
            '    int n, m, k, start;\n'
            '    cin >> n >> m >> k >> start;\n'
            '    start--;\n'
            '    vector<Edge> edges(m);\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int v, u, w;\n'
            '        cin >> v >> u >> w;\n'
            '        v--;\n'
            '        u--;\n'
            '        edges[i] = {v, u, w};\n'
            '    }\n'
            '    vector<vector<int>> d(n, vector<int>(k + 1, INF));\n'
            '    d[start][0] = 0;\n'
            '    for (int i = 0; i < k; i++) {\n'
            '        for (Edge& e : edges) {\n'
            '            for (int path = 1; path <= k; path++) {\n'
            '                if (d[e.v][path - 1] != INF && d[e.u][path] > d[e.v][path - 1] + e.w) {\n'
            '                    d[e.u][path] = d[e.v][path - 1] + e.w;\n'
            '                }\n'
            '            }\n'
            '        }\n'
            '    }\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        if (d[i][k] != INF) {\n'
            '            cout << d[i][k] << el;\n'
            '        }\n'
            '        else {\n'
            '            cout << "-1\\n";\n'
            '        }\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'С помощью алгоритма Форда-Беллмана можно искать отрицательный цикл в графе\n'
            'Для этого достаточно лишь запустить алгоритм два раза и посмотреть, изменился ли массив расстояний\n'
            'Если расстояние для какой-то вершины изменилось, то она достижима из цикла отрицательного веса (или лежит на нём)\n'
            'Чтобы восстановить цикл, нужно хранить для каждой вершины, откуда мы в неё пришли, чтобы создать кратчайший путь\n'
            'Тогда будем откатываться по предкам от вершины, для которой изменилось расстояние, и класть вершины в стек\n'
            'Когда мы находим вершину, которая уже была в стеке, мы начинаем выбрасывать вершины из стека, пока не дойдём до первого вхождения вершины\n'
            'Все вершины, которые мы выбросим, - отрицательный цикл\n'
            'const ll INF = 1e9;\n'
            '\n'
            'struct Edge {\n'
            '    int v, u, w;\n'
            '    Edge() {}\n'
            '    Edge(int v_, int u_, int w_) {\n'
            '        v = v_;\n'
            '        u = u_;\n'
            '        w = w_;\n'
            '    }\n'
            '};\n'
            '\n'
            'signed main() {\n'
            '    int n, m;\n'
            '    cin >> n >> m;\n'
            '    vector<Edge> edges(m);\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int v, u, w;\n'
            '        cin >> v >> u >> w;\n'
            '        v--;\n'
            '        u--;\n'
            '        edges[i] = Edge(v, u, w);\n'
            '    }\n'
            '    vector<int> d(n, INF);\n'
            '    d[0] = 0;\n'
            '    vector<int> p(n, -1);\n'
            '    for (int i = 0; i < n - 1; i++) {\n'
            '        for (Edge& e : edges) {\n'
            '            if (d[e.v] != INF && d[e.u] > d[e.v] + e.w) {\n'
            '                d[e.u] = d[e.v] + e.w;\n'
            '                p[e.u] = e.v;\n'
            '            }\n'
            '        }\n'
            '    }\n'
            '    vector<int> old_d = d;\n'
            '    for (int i = 0; i < n - 1; i++) {\n'
            '        for (Edge& e : edges) {\n'
            '            if (d[e.v] != INF && d[e.u] > d[e.v] + e.w) {\n'
            '                d[e.u] = d[e.v] + e.w;\n'
            '                p[e.u] = e.v;\n'
            '            }\n'
            '        }\n'
            '    }\n'
            '    if (old_d == d) {\n'
            '        cout << "NO\\n";\n'
            '        return 0;\n'
            '    }\n'
            '    cout << "YES\\n";\n'
            '    int cur = -1;\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        if (old_d[i] != d[i]) {\n'
            '            cur = i;\n'
            '            break;\n'
            '        }\n'
            '    }\n'
            '    stack<int> st;\n'
            '    st.push(cur);\n'
            '    vector<bool> been(n);\n'
            '    vector<int> cycle;\n'
            '    been[cur] = true;\n'
            '    while (true) {\n'
            '        cur = p[cur];\n'
            '        if (been[cur]) {\n'
            '            cycle.push_back(cur + 1);\n'
            '            while (st.top() != cur) {\n'
            '                cycle.push_back(st.top() + 1);\n'
            '                st.pop();\n'
            '            }\n'
            '            cycle.push_back(cur + 1);\n'
            '            break;\n'
            '        }\n'
            '        been[cur] = true;\n'
            '        st.push(cur);\n'
            '    }\n'
            '    cout << cycle.size() << el;\n'
            '    cout << cycle << el;\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Но может быть случай, когда отрицательный цикл не достижим из вершины 0\n'
            'Тогда можно запускать из всех непосещённых вершин (у которых расстояние INF) (но это довольно долго)\n'
            '\n'
            'Можно проверить, определено ли значение кратчайшего пути для вершины\n'
            'Для этого нужно добавить после алгоритма:\n'
            'int finish;\n'
            'cin >> finish;\n'
            'bool reach = false;\n'
            'vector<bool> used(n);\n'
            'dfs(finish, used, rg, d, old, reach);\n'
            'if (reach) {\n'
            '    cout << "-INF\\n";\n'
            '}\n'
            '\n'
            'rg - перевёрнутый граф (можно создать в процессе ввода)\n'
            'Функция dfs:\n'
            'void dfs(int v, vector<bool>& used, const vector<vector<int>>& g, const vector<int>& d, const vector<int>& old, bool& reach) {\n'
            '    if (d[v] != old[v]) {\n'
            '        reach = true;\n'
            '    }\n'
            '    used[v] = true;\n'
            '    for (int u: g[v]) {\n'
            '        if (!used[u]) {\n'
            '            dfs(u, used, g, d, old, reach);\n'
            '        }\n'
            '    }\n'
            '}\n')


def knapsack():
    return ('Задача о рюкзаке\n'
            '\n'
            'Задача о рюкзаке звучит так: есть рюкзак,\n'
            'у рюкзака есть параметр W - максимальный вес, который можно положить в рюкзак,\n'
            'также есть n предметов, у каждого предмета есть свой вес,\n'
            'вопрос в том, какой максимальный вес можно набрать\n'
            '\n'
            'У задачи есть вариации\n'
            'Например, у каждого предмета есть стоимость, и вопрос состоит в том, какую максимальную стоимость можно набрать\n'
            '\n'
            'Самое простое решение - решение за O(nW)\n'
            'Для того, чтобы решить первую задачу, будем хранить dp[i][j], i - сколько предметов рассмотрено, j - какой вес набран\n'
            'dp[i][j] - bool для этой задачи (можем/не можем набрать вес j)\n'
            'Каждый раз мы смотрим, чему равно j - w[i]\n'
            'Если это true, то мы раньше смогли набрать j - w[i], а значит сейчас можем набрать j\n'
            '\n'
            'signed main() {\n'
            '    int n, W;\n'
            '    cin >> n >> W;\n'
            '    vector<int> w(n + 1);\n'
            '    for (int i = 1; i <= n; i++)\n'
            '        cin >> w[i];\n'
            '    vector<vector<bool>> dp(n + 1, vector<bool>(W + 1, false));\n'
            '    dp[0][0] = true;\n'
            '    for (int i = 1; i <= n; i++) {\n'
            '        for (int j = 0; j <= W; j++) {\n'
            '            dp[i][j] = dp[i - 1][j];\n'
            '            if (w[i] <= j && dp[i - 1][j - w[i]])\n'
            '                dp[i][j] = true;\n'
            '        }\n'
            '    }\n'
            '    int ans = 0;\n'
            '    for (int i = W; i >= 0; i--) {\n'
            '        if (dp[n][i]) {\n'
            '            ans = i;\n'
            '            break;\n'
            '        }\n'
            '    }\n'
            '    cout << ans << el;\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Задача со стоимостями решается так же, только в dp[i][j] мы храним не bool, а максимальную стоимость для веса j\n'
            'Код с восстановлением ответа:\n'
            'signed main() {\n'
            '    int n, W;\n'
            '    cin >> n >> W;\n'
            '    vector<int> w(n + 1);\n'
            '    vector<int> c(n + 1);\n'
            '    for (int i = 1; i <= n; i++)\n'
            '        cin >> w[i];\n'
            '    for (int i = 1; i <= n; i++)\n'
            '        cin >> c[i];\n'
            '    vector<vector<int>> dp(n + 1, vector<int>(W + 1, 0));\n'
            '    vector<vector<bool>> p(n + 1, vector<bool>(W + 1, false));\n'
            '    dp[0][0] = 0;\n'
            '    for (int i = 1; i <= n; i++) {\n'
            '        for (int j = 0; j <= W; j++) {\n'
            '            dp[i][j] = dp[i - 1][j];\n'
            '            p[i][j] = false;\n'
            '            if (w[i] <= j && dp[i - 1][j - w[i]] + c[i] > dp[i][j]) {\n'
            '                dp[i][j] = dp[i - 1][j - w[i]] + c[i];\n'
            '                p[i][j] = true;\n'
            '            }\n'
            '        }\n'
            '    }\n'
            '    int pos = 0;\n'
            '    for (int i = 0; i <= W; i++) {\n'
            '        if (dp[n][i] > dp[n][pos])\n'
            '            pos = i;\n'
            '    }\n'
            '    cout << dp[n][pos] << el;\n'
            '    int cur_i = n, cur_j = pos;\n'
            '    vector<int> ans;\n'
            '    while (cur_i > 0) {\n'
            '        if (!p[cur_i][cur_j])\n'
            '            cur_i--;\n'
            '        else {\n'
            '            ans.push_back(cur_i);\n'
            '            cur_j -= w[cur_i];\n'
            '            cur_i--;\n'
            '        }\n'
            '    }\n'
            '    sort(ans.begin(), ans.end());\n'
            '    for (int i: ans)\n'
            '        cout << i << el;\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Но решение можно улучшить\n'
            'Заметим, что мы строим целую таблицу, но на одной итерации нам нужно только строки i и i - 1\n'
            'Тогда можно хранить только две строки и после каждой итерации делать swap\n'
            '\n'
            'Пусть дана первая задача (без стоимостей)\n'
            'Мы улучшили решение, сжав таблицу до 2 строк\n'
            'Хотим восстановить ответ\n'
            'Для этого заведём массив A длины W, A[i] - момент времени, когда мы впервые смогли набрать вес i\n'
            'Для восстановления ответа мы смотрим на A[w] = i, вычитаем из w вес предмета i и продолжаем делать то же самое\n'
            'Все предметы, которые мы будем вычитать - это и есть ответ\n'
            '\n'
            'Можно ещё улучшить решение\n'
            'dp[i][j] = dp[i][j] | dp[i][j - w[i]]\n'
            'Тогда мы можем хранить bitset и быстро делать or\n'
            'dp[0] = 1\n'
            'dp = dp | (dp << w[i]) - делаем n раз\n'
            '\n'
            'Для восстановления ответа в таком случае нужно искать элементы, которые впервые стали 1\n'
            'Для этого не будем сразу обновлять dp, а заносить результат or в другой bitset\n'
            'Чтобы найти элементы, которые впервые стали 1, нужно сделать xor dp и нового значения и пройтись по всем единицам\n'
            'Все полученные позиции занести в массив A (про него написано выше)\n'
            'Код (массив A называется make_ans):\n'
            'const int MAX_W = 1e6 + 1;\n'
            'signed main() {\n'
            '    int W;\n'
            '    cin >> W;\n'
            '    int n = 0;\n'
            '    vector<int> w;\n'
            '    int x;\n'
            '    while (cin >> x) {\n'
            '        w.push_back(x);\n'
            '        n++;\n'
            '    }\n'
            '    w.insert(w.begin(), 0);\n'
            '    bitset<MAX_W> dp;\n'
            '    bitset<MAX_W> new_dp;\n'
            '    bitset<MAX_W> p;\n'
            '    dp[0] = true;\n'
            '    vector<int> make_ans(W + 1);\n'
            '    for (int i = 1; i <= n; i++) {\n'
            '        new_dp = dp | (dp << w[i]);\n'
            '        p = dp ^ new_dp;\n'
            '        int last_bit = 0, bit;\n'
            '        while (p._Find_next(last_bit) <= W) {\n'
            '            last_bit = p._Find_next(last_bit);\n'
            '            make_ans[last_bit] = i;\n'
            '            p[last_bit] = false;\n'
            '        }\n'
            '        dp = new_dp;\n'
            '    }\n'
            '    int sum = 0;\n'
            '    for (int i = W; i >= 0; i--) {\n'
            '        if (make_ans[i]) {\n'
            '            sum = i;\n'
            '            break;\n'
            '        }\n'
            '    }\n'
            '    cout << sum << el;\n'
            '    int cur = sum;\n'
            '    while (make_ans[cur]) {\n'
            '        cout << w[make_ans[cur]] << \' \';\n'
            '        cur -= w[make_ans[cur]];\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Случай задачи о рюкзаке с большими весами решается с meet-in-the-middle (описано в mitm)\n')


def ncr():
    return ('Кол-во сочетаний\n'
            '\n'
            'Сочетание из N по K - это набор размера K, выбранный из N элементов (порядок не важен)\n'
            '\n'
            'Кол-во сочетаний равно биномиальному коэффициенту и может быть вычислено по формуле n! / (k! * (n - k)!)\n'
            'Чтобы использовать такую формулу, нужно предпосчитать факториалы для всех i: 0 <= i <= n\n'
            '\n'
            'Кол-во сочетаний можно найти, используя треугольник Паскаля\n'
            'Тогда C из N по K будет равно значению в N строке (счёт сверху вниз) и в K столбце (счёт слева направо)\n'
            'Построение треугольника:\n'
            'void f(ull n) {\n'
            '    tp.resize(n + 1, vector<ull>(n + 1));\n'
            '    tp[0][0] = 1;\n'
            '    tp[1][0] = 1;\n'
            '    tp[1][1] = 1;\n'
            '    for (int i = 2; i <= n; i++) {\n'
            '        tp[i][0] = 1;\n'
            '        for (int j = 1; j < i; j++) {\n'
            '            tp[i][j] = (tp[i - 1][j - 1] + tp[i - 1][j]) % mod;\n'
            '        }\n'
            '        tp[i][i] = 1;\n'
            '    }\n'
            '}\n'
            '\n'
            'Существует задача нахождения кол-ва сочетаний по модулю, быстрее, чем за O(n^2), как в предыдущем алгоритме\n'
            'Для этого используется малая теорема Ферма и обратные элементы по модулю\n'
            '\n'
            'vector<ll> fact;\n'
            '\n'
            'ull power(ull x, int y) {\n'
            '    ull res = 1;\n'
            '    x = x % MOD;\n'
            '    while (y > 0) {\n'
            '        if (y & 1)\n'
            '            res = (res * x) % MOD;\n'
            '        y = y >> 1;\n'
            '        x = (x * x) % MOD;\n'
            '    }\n'
            '    return res;\n'
            '}\n'
            '\n'
            'ull inv(ull n) {\n'
            '    return power(n, MOD - 2);\n'
            '}\n'
            '\n'
            'void build_facts(ull n) {\n'
            '    fact.resize(n + 1);\n'
            '    fact[0] = 1;\n'
            '    for (int i = 1; i <= n; i++) {\n'
            '        fact[i] = (fact[i - 1] * i) % MOD;\n'
            '    }\n'
            '}\n'
            '\n'
            'ull get_ncr(ull n, int k) {\n'
            '    if (n < k) {\n'
            '        return 0;\n'
            '    }\n'
            '    if (k == 0) {\n'
            '        return 1;\n'
            '    }\n'
            '    return (fact[n] * inv(fact[k]) % MOD * inv(fact[n - k]) % MOD) % MOD;\n'
            '}\n'
            '\n'
            'Сначала нужно предпосчитать факториалы (build_facts), потом ответ на запрос - это вызов функции get_ncr\n'
            'Это решение находит одно значение C из N по K за O(nlogn)\n'
            '\n'
            'Если K фиксировано, то можно предпосчитать все inv, но это всё равно будет работать за то же время\n'
            'Однако если в задаче много запросов на нахождение кол-ва сочетаний, то это улучшит время\n')


def Levenshtein():
    return ('Расстояние Левенштейна\n'
            '\n'
            'Есть две строки\n'
            'Мы хотим получить вторую из первой путём нескольких операций, потратив наименьшее число денег\n'
            'Возможные операции:\n'
            '1. Удалить символ на позиции i, заплатив delCost\n'
            '2. Вставить символ на позицию i, заплатив addCost\n'
            '3. Поменять символ на другой на позиции i, заплатив repCost\n'
            '\n'
            'Решение использует дп\n'
            'Заведём массив dp, где dp[i][j] - ответ для префикса i первой строки и префикса j второй строки\n'
            'i будет от 0 до n включительно, и j будет от 0 до m включительно, потому что мы должны считать ответ и для пустых строк\n'
            '\n'
            '           ┌ 0,                если i = j = 0\n'
            '           | j * addCost,      если i = 0\n'
            '           | i * delCost,      если j = 0\n'
            'dp[i][j] = | dp[i - 1][j - 1], если a[i - 1] = b[j - 1]\n'
            '           | min( dp[i - 1][j] + delCost,      - мы можем удалить символ\n'
            '           |      dp[i][j - 1] + addCost,      - мы можем вставить новый символ\n'
            '           └      dp[i - 1][j - 1] + repCost ) - мы можем поменять символ\n'
            '\n'
            'string a, b;\n'
            'cin >> a >> b;\n'
            'int n = a.size();\n'
            'int m = b.size();\n'
            'int addCost, delCost, repCost;\n'
            'cin >> addCost >> delCost >> repCost;\n'
            'vector<vector<int>> dp(n + 1, vector<int>(m + 1));\n'
            'for (int i = 0; i <= n; i++) {\n'
            '    for (int j = 0; j <= m; j++) {\n'
            '        if (i == 0 && j == 0) {\n'
            '            continue;\n'
            '        }\n'
            '        if (i == 0) {\n'
            '            dp[i][j] = j * addCost;\n'
            '        }\n'
            '        else if (j == 0) {\n'
            '            dp[i][j] = i * delCost;\n'
            '        }\n'
            '        else if (a[i - 1] == b[i - 1]) {\n'
            '            dp[i][j] = dp[i - 1][j - 1];\n'
            '        }\n'
            '        else {\n'
            '            dp[i][j] = min({dp[i - 1][j] + delCost, dp[i][j - 1] + addCost, dp[i - 1][j - 1] + repCost});\n'
            '        }\n'
            '    }\n'
            '}\n'
            'cout << dp[n][m] << el;\n')


def LCIS():
    return ('Наибольшая общая возрастающая подпоследовательность\n'
            '\n'
            'Будем использовать дп\n'
            '\n'
            'Решение за O(n^4):\n'
            'dp[i][j] - ответ для префикса i массива a, префикса j массива b, i и j входят в ответ\n'
            'Если a[i] != b[j], то dp[i][j] = 0\n'
            'Иначе перебираем все i1 до i и j1 до j\n'
            'Если a[i1] < a[i] и a[i1] == b[j1], то обновляем dp[i][j] через dp[i1][j1] + 1\n'
            '\n'
            'Решение за O(n^3):\n'
            'dp[i][j] - ответ для префикса i массива a, префикса j массива b, i входит в ответ\n'
            'Если a[i] != b[j], то dp[i][j] = dp[i][j - 1]\n'
            'Иначе dp[i][j] = max(dp[i1][j - 1]) + 1, если i1 < i и a[i1] < a[i]\n'
            'Мы включаем j и перебираем i\n'
            '\n'
            'Решение за O(n^2):\n'
            'dp[i][j] - ответ для префикса i массива a, префикса j массива b, j входит в ответ\n'
            'Если a[i] != b[j], то dp[i][j] = dp[i - 1][j]\n'
            'Иначе dp[i][j] = max(dp[i - 1][j1]) + 1, j1 < j и b[j1] < b[j]\n'
            'При фиксированном i мы перебираем все возможные j1, но это не надо, т.к. для каждого i мы можем запомнить j1\n'
            '\n'
            'int get(int i, int j, const vector<vector<int>>& dp) {\n'
            '    if (i < 0 || j < 0) {\n'
            '        return 0;\n'
            '    }\n'
            '    return dp[i][j];\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    vector<int> a(n);\n'
            '    cin >> a;\n'
            '    int m;\n'
            '    cin >> m;\n'
            '    vector<int> b(m);\n'
            '    cin >> b;\n'
            '    vector<vector<int>> dp(n, vector<int>(m));\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        int j1 = -1;\n'
            '        for (int j = 0; j < m; j++) {\n'
            '            if (a[i] != b[j]) {\n'
            '                dp[i][j] = get(i - 1, j, dp);\n'
            '            }\n'
            '            else {\n'
            '                dp[i][j] = 1;\n'
            '                if (j1 != -1) {\n'
            '                    dp[i][j] = get(i - 1, j1, dp) + 1;\n'
            '                }\n'
            '            }\n'
            '            if (b[j] < a[i] && get(i - 1, j, dp) > get(i - 1, j1, dp) {\n'
            '                j1 = j;\n'
            '            }\n'
            '        }\n'
            '    }\n'
            '    cout << *max_element(dp[n - 1].begin(), dp[n - 1].end()) << el;\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Код может быть неверным\n')


def fractional_cascading():
    return ('Частичное каскадирование\n'
            '\n'
            'Пусть нужно найти кол-во чисел, меньших заданного числа X в K массивах\n'
            'Это можно сделать бинпоиском в каждом массиве за O(Klogn), где n - кол-во чисел в одном массив\n'
            'Это решение можно ускорить до O(K + logn), используя технику частичного каскадирования\n'
            '\n'
            'ДВА МАССИВА\n'
            'Мы хотим взять один массив и сделать бинпоиск на нём, найдя ответ сразу на всех массивах\n'
            'Пусть у нас есть два массива (A и B). Бинпоиск мы будем производить на массиве A\n'
            'Возьмём каждый второй элемент массива B и добавим его в массив A. Конечно, массив должен остаться отсортированным\n'
            '\n'
            'Пример:\n'
            'A = [1, 7, 45, 202]\n'
            'B = [3, 6, 60, 310]\n'
            'После добавления массив A будет выглядеть так:\n'
            '$A = [1, <3>, <6>, 7, 45, <60>, 202, <310>]\n'
            'Выделены добавленные элементы\n'
            '\n'
            'Теперь мы можем запустить бинпоиск на массиве A\n'
            'Для найденной позиции мы можем сказать ближайшие числа из второго массива\n'
            'Но так как мы добавляли каждое второе число из второго массива, осталось только проверить, больше ли X числа, которое находится между двумя ближайшими числами из второго массива\n'
            '\n'
            'Есть вопрос, как находить индексы ближайших чисел во втором массиве. Для этого можно хранить в массивах тройки чисел:\n'
            '1. Само число\n'
            '2. Номер массива, из которого взято это число\n'
            '3. Индекс числа в массиве, из которого оно взято\n'
            '\n'
            'Используя такие тройки, мы можем предпосчитать для каждой позиции в массиве A ближайшие числа из массива B\n'
            '\n'
            'K МАССИВОВ\n'
            'Для случая с K массивами решение похоже на решение для двух массивов\n'
            'Теперь мы будем класть элементы из каждого массива в предыдущий массив\n'
            'Сначала добавляем каждый второй элемент из последнего массива в предпоследний\n'
            'После этого из полученного предпоследнего массива добавляем каждый второй элемент в следующий массив и т.д.\n'
            '\n'
            'При таком каскадировании первый массив не "разрастётся". Это можно доказать\n'
            'В лучшем случае из массива K в массив K - 1 будет добавлено n/2 элементов из последнего массива,\n'
            'из массива K - 1 в массив K - 2 будет добавлено n / 4 элементов из последнего массива,\n'
            'из массива K - 2 в массив K - 3 будет добавлено n / 8 элементов и т.д.\n'
            'Сумма всех таких значений не больше 2n. Т.е. первый массив вырастет не более, чем в 2 раза\n'
            '\n'
            'Как найти ответ? Для каждой позиции в каждом массиве предпосчитаем ближайшие элементы из предыдущего массива\n'
            'Запускаем бинпоиск в первом массиве, находим в нём ближайшие элементы их второго массива\n'
            'Находим число между ними и сравниваем с числом X. Теперь у нас есть новая позиция X, продолжаем делать то же самое\n'
            '\n'
            'Важно, что тройки чисел должны меняться при добавлении к следующему массиву, иначе мы не сможем правильно выбрать позиции чисел\n'
            'При добавлении элементов к следующему массиву, эти тройки чисел в новом массиве начинают хранить информацию только о предыдущем массиве (даже если они остались ещё от последнего массива)\n'
            'Тройки чисел нужны только для предпосчёта, в самом алгоритме их использовать не получится, иначе асимптотика станет намного хуже\n'
            '\n'
            'Итого, мы запустили бинпоиск на первом массиве и сделали K спусков по массивам. Асимптотика равна O(K + logn)\n')


def cht_opt():
    return ('Convex Hull Trick\n'
            '\n'
            'Convex Hull Trick - оптимизация дп, позволяющая сделать из асимптотики О(n^2) асимптотику O(nlogn)\n'
            'Оптимизация работает для дп вида dp[i] = min(dp[j] + b[j] * a[i])\n'
            '\n'
            'Видно, что a[i] фиксировано для dp[i], изменяются только dp[j] и b[j]\n'
            'Сделаем a[i] = x, b[j] = k, dp[j] = b\n'
            'Получилось dp[i] = min(b + kx)\n'
            'Т.е. dp[i] - это минимум по значениям всех линейных функций в точке x\n'
            '\n'
            'Мы посчитали как-то dp[i], теперь нужно добавить эту функцию в какую-то структуру для подсчёта новых dp\n'
            'Очевидно, что в каждой точке x нам выгодно хранить только функцию, значения которой минимально в этой точке\n'
            'y = kx + b - прямая, поэтому будем хранить структуру из прямых\n'
            'Пусть у нас уже есть какие-то прямые в структуре, сейчас мых хотим добавить ещё одну\n'
            'Эта прямая как-то пересечёт уже имеющиеся прямые. Если прямая окажется ниже какой-то части прямых, то мы удалим всё, что выше новой прямой и скажем, что на этом отрезке минимальная функция - новая\n'
            'Получается, что наша структура - это огибающая (выглядит, как кусочная функция с не более, чем одним, экстремумом)\n'
            'Если в dp[i] min, то огибающая выгнута вверх, если max - вниз\n'
            '\n'
            'Часто в задачах есть ограничения на b[j]: он возрастает/убывает\n'
            'Предположим, что b[j] убывает. Это означает, что каждая новая прямая будет иметь меньший k, чем все предыдущие\n'
            'Т.е. новая прямая точно отсечёт какую-то часть структуры в конце\n'
            '\n'
            'Как хранить прямые?\n'
            'Прямые можно хранить просто в списке. Структуру можно хранить через точки пересечения прямых\n'
            'Если пересечение новой прямой и последней прямой ниже, чем последнее пересечение прямых (мы рассматриваем случай с min), то последнюю прямую нужно удалить из структуры\n'
            'Дальше нужно продолжить алгоритм. Т.е. мы пытаемся пересечь новую прямую с прямыми в конце, постепенно их удаляя\n'
            'Это означает, что добавления прямой работает за O(n), ведь каждая прямая может только один раз добавиться и один раз удалиться\n'
            '\n'
            'Как найти значение dp[i], если мы построили такую структуру?\n'
            'Мы знаем точки пересечения прямых огибающей. Чтобы найти значение dp[i], мы должны найти, между какими точками лежит x\n'
            'Это можно сделать бинпоиском\n'
            '\n'
            'Т.е. итоговая асимптотика O(nlogn)\n'
            '\n'
            'Решение задачи https://codeforces.com/contest/319/problem/C:\n'
            '#define ll long long\n'
            '#define ld long double\n'
            '#define all(a) (a).begin(), (a).end()\n'
            '#define el \'\\n\'\n'
            'struct Line {\n'
            '    int k, b; // kx + b\n'
            '    Line() {}\n'
            '    Line(int k_, int b_) {\n'
            '        k = k_;\n'
            '        b = b_;\n'
            '    }\n'
            '    int get_val(int x) {\n'
            '        return k * x + b;\n'
            '    }\n'
            '};\n'
            '\n'
            'vector<ld> points; // позиции пересечений прямых по x\n'
            'vector<Line> cht; // массив с прямыми\n'
            '\n'
            'ld cross(const Line& a, const Line& b) {\n'
            '    return (ld)(b.b - a.b) / (ld)(a.k - b.k);\n'
            '}\n'
            '\n'
            'void add(const Line& l) {\n'
            '    if (cht.empty()) {\n'
            '        points.push_back(INT_MIN);\n'
            '        cht.push_back(l);\n'
            '        return;\n'
            '    }\n'
            '    while (cht.size() > 1) {\n'
            '        ld cur = cross(cht.back(), l);\n'
            '        if (cur <= points.back()) {\n'
            '            points.pop_back();\n'
            '            cht.pop_back();\n'
            '        }\n'
            '        else {\n'
            '            break;\n'
            '        }\n'
            '    }\n'
            '    points.push_back(cross(cht.back(), l));\n'
            '    cht.push_back(l);\n'
            '}\n'
            '\n'
            'int get(int x) {\n'
            '    int pos = lower_bound(all(points), x) - points.begin();\n'
            '    return cht[pos - 1].get_val(x);\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    vector<ll> a(n);\n'
            '    vector<ll> b(n);\n'
            '    cin >> a >> b;\n'
            '    vector<ll> dp(n, (ll)1e18);\n'
            '    dp[0] = 0;\n'
            '    add(Line(b[0], dp[0]));\n'
            '    for (int i = 1; i < n; i++) {\n'
            '        dp[i] = get(a[i]);\n'
            '        add(Line(b[i], dp[i]));\n'
            '    }\n'
            '    cout << dp[n - 1] << el;\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Если k возрастает, то для минимума мы будем добавлять не в конец, а в начало\n'
            'Если мы ищем max, то при возрастании k - конец, при убывании - в начало\n'
            '\n'
            'Если ограничение на монотонное изменение k нет, то можно поддерживать отсортированную структуру прямых (например, бинарное дерево поиска)\n'
            'Тогда добавление прямой будет не с концов, а в любом месте структуры\n')


def matrix_opt():
    return ('Матричная оптимизация ДП\n'
            '\n'
            'Матричная оптимизация основана на возведении матрицы в степень\n'
            'Для этого можно использовать быстрое возведение в степень, которое работает за log (так можно делать, потому что умножение матриц обладает свойством ассоциативности)\n'
            'Поэтому единственное, что нужно знать - как перемножить две матрицы\n'
            '\n'
            'Есть две матрицы: a[n][m] и b[l][k]\n'
            'Их можно перемножить только тогда, когда m == l\n'
            'Т.е. b[m][k]\n'
            '\n'
            'Результат умножения - матрица c[n][k]\n'
            'c[i][j] = sum(a[i][t] * b[t][j]), где 0 <= t <= m - 1\n'
            '\n'
            'Пример задачи: найти n-ое число Фибоначчи, где n <= 10^18\n'
            'Хотим из матрицы (f(n+1), f(n)) получить матрицу (f(n + 2), f(n + 1)) - матрицы (2, 1) (т.е. они на самом деле не строки, а столбцы)\n'
            'Такое преобразование можно выполнить, умножив первую матрицу на матрицу ((1, 1), (1, 0))\n'
            '\n'
            'Код:\n'
            'll MOD = 1e9 + 7;\n'
            '\n'
            '// Произведение матриц\n'
            'vector<vector<ll>> mul(const vector<vector<ll>>& a, const vector<vector<ll>>& b) {\n'
            '    int n = a.size();\n'
            '    int m = a[0].size();\n'
            '    int k = b[0].size();\n'
            '    vector<vector<ll>> c(n, vector<ll>(k));\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        for (int j = 0; j < k; j++) {\n'
            '            for (int q = 0; q < m; q++) {\n'
            '                c[i][j] += a[i][q] * b[q][j];\n'
            '                c[i][j] %= MOD;\n'
            '            }\n'
            '        }\n'
            '    }\n'
            '    return c;\n'
            '}\n'
            '\n'
            'vector<vector<ll>> bin_pow(const vector<vector<ll>>& matrix, int n) {\n'
            '    if (n == 1) {\n'
            '        return matrix;\n'
            '    }\n'
            '    if (n % 2 == 0) {\n'
            '        auto cur = bin_pow(matrix, n / 2);\n'
            '        return mul(cur, cur);\n'
            '    }\n'
            '    auto cur = bin_pow(matrix, n - 1);\n'
            '    return mul(cur, matrix);\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    if (n == 0) {\n'
            '        cout << "0\\n";\n'
            '        return 0;\n'
            '    }\n'
            '    if (n == 1) {\n'
            '        cout << "1\\n";\n'
            '        return 0;\n'
            '    }\n'
            '    vector<vector<ll>> matrix {{1, 1}, {1, 0}};\n'
            '    auto res = bin_pow(matrix, n - 1);\n'
            '    vector<vector<ll>> start {{1}, {1}};\n'
            '    auto ans = mul(res, start);\n'
            '    cout << ans[1][0] << el;\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'В общем случае мы можем оптимизировать задачи, в которых есть рекуррентное выражение числа dp[i]\n'
            'Если выражение вида dp[n] = 2 * dp[n - 1] + 10 * dp[n - 3] - 3 * dp[n - 4], то мы будем делать переход\n'
            'dp[n - 1]        dp[n]\n'
            'dp[n - 2]  --->  dp[n - 1]\n'
            'dp[n - 3]        dp[n - 2]\n'
            'dp[n - 4]        dp[n - 3]\n'
            'Матрица, которую мы будем возводить в степень:\n'
            '2, 0, 10, -3\n'
            '1, 0, 0,   0\n'
            '0, 1, 0,   0\n'
            '0, 0, 1,   0\n'
            'Числа в матрице определяются коэффициентами в выражении, т.к. c[i][j] - сумма произведений соответствующих элементов строки первой матрицы и столбца второй матрицы\n'
            'Т.е. c[0][0] будет равно 2 * dp[n - 1] + 0 * dp[n - 2] + 10 * dp[n - 3] + (-3) * dp[n - 4]\n'
            'А c[1][0] будет равно 1 * dp[n - 1] + 0 * dp[n - 2] + 0 * dp[n - 3] + 0 * dp[n - 4]\n')


def Hamilton():
    return ('Поиск гамильтонова пути\n'
            '\n'
            'Гамильтонов путь - путь, проходящий через все вершины графа ровно по одному разу\n'
            '\n'
            'Решим задачу поиска минимального по весу гамильтонова пути в ориентированном графе\n'
            'Для решения будем использовать дп по подмножествам\n'
            'В маске будет набор из уже посещённых вершин\n'
            'Второй параметр динамики - какая вершина была последней в пути\n'
            '\n'
            'bool get_bit(int mask, int i) {\n'
            '    return mask & (1 << i);\n'
            '}\n'
            '\n'
            'int bit_to_1(int mask, int i) {\n'
            '    return mask | (1 << i);\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    vector<vector<pair<int, int>>> graph(n);\n'
            '    // ввод графа\n'
            '    vector<vector<int>> dp((1 << n), vector<int>(n, 1e9));\n'
            '    dp[1][0] = 0;\n'
            '    vector<vector<pair<int, int>>> p((1 << n), vector<pair<int, int>>(n, {-1, -1}));\n'
            '    for (int mask = 1; mask < (1 << n); mask++) {\n'
            '        for (int v = 0; v < n; v++) {\n'
            '            if (dp[mask][v] == 1e9 || !get_bit(mask, v)) {\n'
            '                continue;\n'
            '            }\n'
            '            for (pair<int, int> pair : graph[v]) {\n'
            '                int u = pair.first;\n'
            '                int w = pair.second;\n'
            '                if (get_bit(mask, u)) {\n'
            '                    continue;\n'
            '                }\n'
            '                int nmask = bit_to_1(mask, u);\n'
            '                if (dp[mask][v] + w < dp[nmask][u]) {\n'
            '                    p[nmask][u] = {mask, v};\n'
            '                    dp[nmask][u] = dp[mask][v] + w;\n'
            '                }\n'
            '            }\n'
            '        }\n'
            '    }\n'
            '    int ans = 1e9;\n'
            '    int pos = -1;\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        if (dp[(1 << n) - 1][i] < ans) {\n'
            '            ans = dp[(1 << n) - 1][i];\n'
            '            pos = i;\n'
            '        }\n'
            '    }\n'
            '    if (pos == -1) {\n'
            '        cout << "-1\\n";\n'
            '        return 0;\n'
            '    }\n'
            '    cout << ans << el;\n'
            '    vector<int> order;\n'
            '    int cur_mask = (1 << n) - 1;\n'
            '    while (true) {\n'
            '        order.push_back(pos + 1);\n'
            '        pair<int, int> prev = p[cur_mask][pos];\n'
            '        if (prev == make_pair(-1, -1)) {\n'
            '            break;\n'
            '        }\n'
            '        cur_mask = prev.first;\n'
            '        pos = prev.second;\n'
            '    }\n'
            '    reverse(all(order));\n'
            '    for (int i : order) {\n'
            '        cout << i << \' \';\n'
            '    }\n'
            '    cout << el;\n'
            '    return 0;\n'
            '}\n')


def heap():
    return ('Куча\n'
            '\n'
            'Куча - структура данных, позволяющая добавлять элементы, находить минимум/максимум всех элементов, удалять минимум/максимум\n'
            '\n'
            'Куча - это дерево из чисел, в котором выполняется условие: число в родителе меньше или равно чисел в детях (для кучи на минимум)\n'
            'Для кучи на максимум условие: число в родителе больше или равно чисел в детях\n'
            '\n'
            '1. Поиск минимума/максимума\n'
            'Минимум/максимум - это вершина кучи\n'
            '\n'
            '2. Добавление\n'
            'Добавим требуемое число в конец дерева (мы храним кучу на массиве, как дерево отрезков)\n'
            'Но условие кучи могло нарушиться, поэтому будем применять операцию проталкивания наверх: если условие для родителя и ребёнка не выполнено, поменяем их местами, и продолжим для родителя\n'
            '\n'
            '3. Удаление минимума/максимума\n'
            'Хотим удалить корень. Тогда присвоим корню значение последнего элемента кучи, и уменьшим размер кучи на один (для массива сделаем pop)\n'
            'Теперь нужно восстановить условие кучи. Будем проталкивать вниз\n'
            'Для кучи на минимум: берём минимального сына (понятно, что сыновей может быть 0, 1 или 2), и если с ним условие не выполнено, меняем родителя с ним и продолжаем алгоритм для этого сына\n'
            'Для кучи на максимум разница только в том, что мы берём максимального сына\n'
            '\n'
            'Реализация (на минимум):\n'
            '\n'
            'class Heap {\n'
            'private:\n'
            '    vector<int> a;\n'
            '\n'
            '    void go_down(int v) {\n'
            '        while (v * 2 + 1 < a.size()) {\n'
            '            int go_to = v * 2 + 1;\n'
            '            if (v * 2 + 2 < a.size() && a[v * 2 + 2] < a[v * 2 + 1]) {\n'
            '                go_to = v * 2 + 2;\n'
            '            }\n'
            '            if (a[v] > a[go_to]) {\n'
            '                swap(a[v], a[go_to]);\n'
            '                v = go_to;\n'
            '            }\n'
            '            else {\n'
            '                break;\n'
            '            }\n'
            '        }\n'
            '    }\n'
            '\n'
            '    void go_up(int v) {\n'
            '        while (v) {\n'
            '            int par = (v + 1) / 2 - 1;\n'
            '            if (a[par] > a[v]) {\n'
            '                swap(a[par], a[v]);\n'
            '                v = par;\n'
            '            }\n'
            '            else {\n'
            '                break;\n'
            '            }\n'
            '        }\n'
            '    }\n'
            'public:\n'
            '    Heap() {};\n'
            '    Heap(vector<int>& arr) { // создание кучи за O(n) из массива\n'
            '        a = arr;\n'
            '        for (int i = a.size() - 1; i >= 0; i--) {\n'
            '            go_down(i);\n'
            '        }\n'
            '    }\n'
            '\n'
            '    int get_min() {\n'
            '        return a[0];\n'
            '    }\n'
            '\n'
            '    void add(int x) {\n'
            '        a.push_back(x);\n'
            '        go_up(a.size() - 1);\n'
            '    }\n'
            '\n'
            '    void del_min() {\n'
            '        a[0] = a.back();\n'
            '        a.pop_back();\n'
            '        go_down(0);\n'
            '    }\n'
            '};\n'
            '\n'
            'Пирамидальная сортировка\n'
            'Кучу можно использовать для сортировки массива. Для этого достаточно создать кучу на минимум, добавить в неё все элементы массива и по одному вытаскивать минимум из кучи. Последовательность вытащенных минимумов будет отсортированным массивом\n')


def no(a):
    global list_com
    global list_names
    list_names = [
        '\nМАТЕМАТИКА:',
        '\nЧТО-ТО:',
        '\nСТРОКИ:',
        '\nДП:',
        '\nСТРУКТУРЫ ДАННЫХ:',
        '\nГРАФЫ:',
        '\nГЕОМЕТРИЯ:'
    ]
    list_com = ['all',

                '\nМАТЕМАТИКА:',
                'quick_pow',
                'bit_operations',
                'f_Euler',
                'gcdex',
                'eratosthenes_sieve',
                'check_for_simplicity',
                'factorize',
                'gcd_lcm',
                'ncr',

                '\nЧТО-ТО:',
                'date_time',
                'two_pointers',
                'testing',
                'binsearch',
                'fractional_cascading',
                'ternary_search',
                'sorts',

                '\nСТРОКИ:',
                'hashes',
                'z_function',
                'prefix_function',
                'Manacher',
                'trie',
                'Huffman',

                '\nДП:',
                'LCS',
                'LIS',
                'LCIS',
                'knapsack',
                'Levenshtein',
                'cht_opt',
                'matrix_opt',
                'mitm',

                '\nСТРУКТУРЫ ДАННЫХ:',
                'heap',
                'segment_tree',
                'persistent_st',
                'sparse_table',
                'sqrt_decomposition',
                'Mo',
                'dsu',
                'mergesort_tree',
                'segment_tree_2Dproblems',
                'pref_sum',
                'Fenwick',
                'treap',
                'implicit_treap',

                '\nГРАФЫ:',
                'dfs',
                'bfs',
                'Ford_Bellman',
                'Floyd',
                'Dijkstra',
                'mst',
                'top_sort',
                'condensation',
                'two_sat',
                'euler',
                'bridges_cutpoints',
                'lca',
                'maxmatch',
                'Kuhn',
                'Hamilton',

                '\nГЕОМЕТРИЯ:',
                'geometry', # rewrite and rename
                'intersections', # no
                'polygons', # no
                'convex_hull' # no
                ]
    if a in list_names:
        return False
    if a not in list_com:
        return False
    else:
        return True


def all():
    for i in range(len(list_com)):
        if i != len(list_com) - 1:
            print(list_com[i], end='\n')
        else:
            print(list_com[i])
    return ''


H = """
Commands:
  all - list of all sections
  q - exit
  h - this text
  \'section_name\' - read section with the title \'section_name\'
"""
a = '1'
print(H)
while True:
    a = input('>>>')
    if a == 'q':
        sys.exit()
    elif a == 'h':
        print(H)
    else:
        if not no(a):
            print('There is no such section. Try \'all\'')
        else:
            a += '()'
            print(eval(a))


