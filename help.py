# -*-coding: utf-8-*-
import sys
from termcolor import colored


def date_time():
    return ('Задачи на дату/время\n'
            '\n'
            'ВРЕМЯ\n'
            '\n'
            'Считывание при вводе:\n'
            'P: h, m, s = [int(i) for i in input().split(\':\')]\n'
            'C: scanf("%d:%d:%d", &h, &m, &s)\n'
            '\n'
            'Перевод из строки в число:\n'
            'P: int(s[0] + s[1])\n'
            'C: (s[0] - \'0\') * 10 + (s[1] - \'0\') # char является числом (кодом символв в ASCII)\n'
            '\n'
            'проще перевести всё в секунды: sec = h * 3600 + m * 60 + s\n'
            '\n'
            'ДАТЫ\n'
            '\n'
            'Считывание, такое же, как во времени\n'
            '\n'
            'Перевод в дни:\n'
            'days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] # можно сделать префиксные суммы\n'
            'd = sum(days[mm - 2]) + dd # может возникнуть проблема с месяцем (если введён первый месяц)\n'
            '\n'
            'Перевод из дней в месяц:\n'
            'i = 0\n'
            'while x > 0:\n'
            '    if x <= days[i]:\n'
            '         print(i + 1)\n'
            '         break\n'
            '    else:\n'
            '         x -= days[i]\n'
            '         i += 1\n'
            '\n'
            'Полный код переводов в C/C++ (високосный год не учитывается):)\n'
            '#include <iostream>\n'
            'using namespace std;\n'
            'int prefDays[12];\n'
            'int days[12] = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n'
            'int dateToDays(int m, int d) {\n'
            '\tint ans = 0;\n'
            '\tif (m > 1) {\n'
            '\t\tint ans = prefDays[m - 2];\n'
            '\t}\n'
            '\tans += d;\n'
            '\t/*for (int i = 0; i <= m - 2; ++i) {\n'
            '\t\tans += days[i];*/\n'
            '\treturn ans;\n'
            '}\n'
            'pair <int, int> daysToDate(int x) {\n'
            '\tint m = 1, d = 0;\n'
            '\tfor (int i = 0; i < 12; ++i) {\n'
            '\t\tif (x <= days[i]) {\n'
            '\t\t\td = x;\n'
            '\t\t\treturn {m, x};\n'
            '\t\t}\n'
            '\t\telse {\n'
            '\t\t\tm++;\n'
            '\t\t\tx -= days[i];\n'
            '\t\t}\n'
            '\t}\n'
            '}\n'
            'int main() {\n'
            '\tprefDays[0] = days[0];\n'
            '\tfor (int i = 1; i < 12; ++i) {\n'
            '\t\tprefDays[i] = prefDays[i - 1] + days[i];\n'
            '\t}\n'
            '}\n'
            '\n'
            'Проверка на високосность года:\n'
            'if year % 400 == 0 or (year % 4 == 0 and year % 100 != 0):\n'
            '    print(\'Yes\')\n'
            'else:\n'
            '    print(\'No\')\n'
            '\n'
            'Посчитать кол-во високосных лет с одного заданного года до другого можно так:\n'
            '(year1 - year2) // 4 - (year1 - year2) // 100 + (year1 - year2) // 400\n'
            '\n'
            'Определение дня недели по номеру дня в году (n - номер дня, ng - день недели 1 января)\n'
            'dn = (ng - 2 + n) % 7 + 1\n')


def combinations_enumeration():
    return ('Один из способов перевода - битовые маски\n'
            'Следующий код выводит все сочетания из 0 и 1 длиной n\n'
            '\n'
            '#include <iostream>\n'
            '\n'
            'using namespace std;\n'
            '\n'
            'int main() {\n'
            '\tint n;\n'
            '\tcin >> n;\n'
            '\tfor (int i = 0; i < (1 << n); ++i) {\n'
            '\t\tfor (int q = 0; q < n; ++q) {\n'
            '\t\t\tif (i & (1 << q)) {\n'
            '\t\t\t\tcout << 1;\n'
            '\t\t\t}\n'
            '\t\t\telse {\n'
            '\t\t\t\tcout << 0;\n'
            '\t\t\t}\n'
            '\t\t}\n'
            '\t\tcout << endl;\n'
            '\t}\n'
            '}\n'
            '\n'
            'Следующий код свыводит все сочетания чисел от start до end длиной n в лексикографическом порядке\n'
            'Python:\n'
            'def gen(left, cur):\n'
            '    if left == 0:\n'
            '        print(*cur)\n'
            '        return\n'
            '    for i in range(start, end + 1):\n'
            '        gen(left - 1, cur + [i])\n'
            '\n'
            '\n'
            'n, start, end = map(int, input().split())\n'
            'gen(n, [])\n'
            '\n'
            'C++:\n'
            '#include <iostream>\n'
            '#include <vector>\n'
            '\n'
            'using namespace std;\n'
            '\n'
            'int n, start, end_;\n'
            '\n'
            'void gen(int left, vector<int> cur) {\n'
            '\tif (left == 0) {\n'
            '\t\tfor (int i : cur) {\n'
            '\t\t\tcout << i << \' \';\n'
            '\t\t}\n'
            '\t\tcout << endl;\n'
            '\t\treturn;\n'
            '\t}\n'
            '\tfor (int i = start; i <= end_; ++i) {\n'
            '\t\tcur.push_back(i);\n'
            '\t\tgen(left - 1, cur);\n'
            '\t\tcur.pop_back();\n'
            '\t}\n'
            '}\n'
            '\n'
            'int main() {\n'
            '\tcin >> n >> start >> end_;\n'
            '\tgen(n, vector<int>{});\n'
            '}\n'
            '\n'
            'Следующий код имеет функцию gen, которая делает то же самое, что и предыдущий код (только без повторений чисел)\n'
            'Также код имеет функию n_permutation (аналог встроенной next_permutation), которая выводит следующую последовательность из цифр в лексикографическом порядке\n'
            '\n'
            '#include <iostream>\n'
            '#include <vector>\n'
            '#include <algorithm>\n'
            '\n'
            'using namespace std;\n'
            '\n'
            'int n;\n'
            '\n'
            'void gen(int left, vector<int> cur, vector<int> been) {\n'
            '\tif (left == 0) {\n'
            '\t\tfor (int i : cur) {\n'
            '\t\t\tcout << i << \' \';\t\t\t\n'
            '\t\t}\n'
            '\t\tcout << endl;\n'
            '\t\treturn;\n'
            '\t}\n'
            '\tfor (int i = 0; i < n; ++i) {\n'
            '\t\tif (!been[i]) {\n'
            '\t\t\tbeen[i] = 1;\n'
            '\t\t\tcur.push_back(i + 1);\n'
            '\t\t\tgen(left - 1, cur, been);\n'
            '\t\t\tcur.pop_back();\n'
            '\t\t\tbeen[i] = 0;\n'
            '\t\t}\n'
            '\t}\n'
            '}\n'
            '\n'
            'void n_permutation(vector<int>& p) {\n'
            '\tint n = p.size();\n'
            '\tfor (int i = n - 1; i > 0; --i) {\n'
            '\t\tif (p[i] > p[i - 1]) {\n'
            '\t\t\tint pos;\n'
            '\t\t\tfor (int j = n - 1; j >= i; --j) {\n'
            '\t\t\t\tif (p[j] > p[i - 1]) {\n'
            '\t\t\t\t\tpos = j;\n'
            '\t\t\t\t\tbreak;\n'
            '\t\t\t\t}\n'
            '\t\t\t}\n'
            '\t\t\tswap(p[pos], p[i - 1]);\n'
            '\t\t\tsort(p.begin() + i, p.end());\n'
            '\t\t\tbreak;\n'
            '\t\t}\n'
            '\t}\n'
            '}\n'
            '\n'
            'int main() {\n'
            '\tcin >> n;\n'
            '\tgen(n, vector<int>{}, vector<int>(n, 0));\n'
            '\t/*vector<int> a = { 3, 1, 5, 2, 7, 6, 4 };\n'
            '\tn_permutation(a);\n'
            '\tfor (int i : a) {\n'
            '\t\tcout << i << \' \';\n'
            '\t}*/\n'
            '}\n')


def binsearch():
    return ('Бинпоиск\n'
            '\n'
            'Смысл бинпоиска - поиск элемента в отсортированном массиве путём деления массива на две части\n'
            'Поэтому сложность бинпоиска - log2(n)\n'
            '\n'
            'Код бинпоиска:\n'
            'l = 0\n'
            'r = 10 ** 100\n'
            'while r - l > 1:\n'
            '    m = (l + r) // 2\n'
            '    if f(m) >= x:\n'
            '        r = m\n'
            '    else:\n'
            '        l = m\n'
            'print(r)\n'
            '\n'
            'f - какая-то функция, x - заданное число\n'
            '\n'
            'При вещественном бинпоиске (с нецелыми числами, заданная точность) можно заменить while на for\n'
            'for будет выполняться math.ceil(math.log2((r - l) * 10000000000))\n'
            'кол-во нулей в последнем числе - точность ответа\n'
            '\n'
            'Всторенный бинпоиск\n'
            'Python:\n'
            'from bisect import bisect_right, bisect_left\n'
            '\n'
            'a = [1, 2, 4, 5, 6, 6, 7, 9]\n'
            'ind = bisect_left(a, 5)\n'
            'ind1 = bisect_right(a, 6)\n'
            'print(ind, ind1)\n'
            ''
            'C++:\n'
            '#include <iostream>\n'
            '#include <algorithm>\n'
            '#include <vector>\n'
            '\n'
            'using namespace std;\n'
            '\n'
            'int main() {\n'
            '\tvector<int> a {1, 2, 4, 5, 6, 6, 7, 9};\n'
            '\tint b[7] = { 2, 4, 4, 6, 8, 8, 9 };\n'
            '\tauto it = lower_bound(a.begin(), a.end(), 5);\n'
            '\tcout << *it << \' \' << it - a.begin() << endl;\n'
            '\tauto it1 = upper_bound(b, b + 7, 6);\n'
            '\tcout << *it1 << \' \' << it1 - b << endl;\n'
            '}\n'
            '\n'
            'bisect_left и lower_bound ищут первый элемент >= заданного\n'
            'bisect_right и upper_bound ищут первый элемент > заданного\n')


def two_pointers():
    return ('Метод двух указателей\n'
            '\n'
            'Смысл метода заключается в закреплении одного элемента отсортированного массива и передвижения второго\n'
            'Стандартный код метода двух указателей:\n'
            'for (int first_point = 0; first_point < len_array; first_point++) {\n'
            '    while (second_point < len_array && <условие>) {\n'
            '        second_point++;\n'
            '    }\n'
            '}\n'
            '\n'
            'Указатели могут относится к разным массивам\n'
            'Указателей может быть больше двух, тогда добавляются циклы while в цикле for (один указатель - один цикл while)\n')


def testing():
    return ('Тестирование\n'
            '\n'
            'В основном, тестирование - это генерация тестов\n'
            'В Python за генерацию отвечает модуль random\n'
            'Основные функции:\n'
            'randint(start, end)      # случайное целое число от start до end включительно\n'
            'choice(l)                # случайный элемент списка l\n'
            'normalvariate(mu, sigma) # нормальное распределение\n'
            'random()                 # случайное число от 0 до 1\n'
            '\n'
            'Некоторые генерации:\n'
            '1. Правильная скобочная последовательность\n'
            'n = int(input())\n'
            'l = 0\n'
            'bal = 0\n'
            's = \'\'\n'
            'for i in range(n):\n'
            '    if not bal:\n'
            '        s += \'(\'\n'
            '        l += 1\n'
            '        bal += 1\n'
            '    elif bal + 1 > n - l - 1:\n'
            '        s += \')\'\n'
            '        l += 1\n'
            '        bal -= 1\n'
            '    else:\n'
            '        par = randint(0, 1)\n'
            '        if not par:\n'
            '            s += \'(\'\n'
            '            l += 1\n'
            '            bal += 1\n'
            '        else:\n'
            '            s += \')\'\n'
            '            l += 1\n'
            '            bal -= 1\n'
            'print(s)\n'
            '\n'
            '2. Массив заданной длины и суммы элементов\n'
            'n = int(input())\n'
            's = int(input())\n'
            'border = []\n'
            'for i in range(n - 1):\n'
            '    border.append(randint(0, s))\n'
            'border.sort()\n'
            'border = [0] + border + [s]\n'
            'a = []\n'
            'for i in range(1, n + 1):\n'
            '    a.append(border[i] - border[i - 1])\n'
            'print(a)\n'
            '\n'
            '3. Массив заданной длины из чисел от 1 до k без повторений\n'
            'n = int(input())\n'
            'k = int(input())\n'
            'if k < 5 * n:\n'
            '    a = list(range(1, k + 1))\n'
            '    shuffle(a)\n'
            '    a = a[:n]\n'
            '    print(a)\n'
            'else:\n'
            '    s = set()\n'
            '    while len(s) < n:\n'
            '        s.add(randint(1, k))\n'
            '    l = list(s)\n'
            '    shuffle(l)\n'
            '    print(l)\n'
            '\n'
            'ТЕСТИРОВНИЕ НЕПРАВИЛЬНОГО РЕШЕНИЯ ПРИ НАЛИЧИИ МЕДЛЕННОГО ПРАВИЛЬНОГО\n'
            'Правильное, но медленное решение - slow.py. Неработающее решение - testme.py\n'
            '\n'
            'Для начала пишем генератор для программ в отдельном файле (например, gen3.py)\n'
            '\n'
            'Теперь нужно написать программу, котрая свяжет всё (генератор, два решения и проверку правильности ответа)\n'
            'Например, run.py\n'
            'Тогда программа run.py будет выглядеть так:\n'
            'import os\n'
            '\n'
            'test = 1\n'
            'while True:\n'
            '    os.system(\'python gen3.py > input\')\n'
            '    os.system(\'python testme.py < input > output\')\n'
            '    os.system(\'python slow.py < input > correct\')\n'
            '    output = [i.strip() for i in open(\'output\').readlines()]\n'
            '    correct = [i.strip() for i in open(\'correct\').readlines()]\n'
            '    if output != correct:\n'
            '        print(\'Error at test\', test)\n'
            '        break\n'
            '    print(\'Test\', test, \'is OK\')\n'
            '    print(\'--------------------\')\n'
            '    test += 1\n'
            '\n'
            '< и > перенаправляют вывод в файл\n'
            'Тест, неправильный и правильный ответ можно будет посмотреть после тестирования в файлах input, output и correct\n')


def hashes():
    return ('Хэши\n'
            '\n'
            'Идеальный хэш - это тот хэш, который удовлетворяет равенствам:\n'
            'x = y => H(x) = H(y)\n'
            'x ≠ y => H(x) ≠ H(y)\n'
            'Но представленный ниже алгоритм - это неидеальный хэш\n'
            '\n'
            'Один из алгоритмов хэширования:\n'
            'Присутствуют два параметра: p и mod\n'
            'p <= 300\n'
            'mod ** 2 должен влезать в long long и желательно быть простым числом\n'
            'популярные mod: 10 ** 9 + 7; 10 ** 9 + 9; 2 * 10 ** 9 + 11\n'
            'но популярные mod лучше не использовать\n'
            'Также лучше в начале программы выбирать параметры из списка, используя random\n'
            '\n'
            'Номер каждого элемента в ASCII умножается на соответствующую степень числа p, затем произведения складываются, и находится остаток от деления на mod\n'
            'Example:\n'
            'H(\'abac\') = (ord(\'a\') * p ** 3 + ord(\'b\') * p ** 2 + ord(\'a\') * p ** 1 + ord(\'c\')) % mod\n'
            '\n'
            'Но, т.к. данный хэш неидеален, можно делать двойной, тройной и т.д. хэш (деать к одной строке несколько хэшей с разными p и mod)\n'
            '\n'
            'Код такого хэширования на C++:\n'
            'long long getHash(const string& s, int p, long long mod) {\n'
            '    long long H = 0;\n'
            '    for (auto& c : s) {\n'
            '        H = (H * p + c) % mod;\n'
            '    }\n'
            '    return H;\n'
            '}\n'
            '\n'
            'Гораздо полезнее хранить хэши префиксов строки. Код на C++:\n'
            'vector <long long> getHash(const string& s, int p, long long mod) {\n'
            '\tvector<long long> ans(s.size());\n'
            '\tans[0] = s[0];\n'
            '\tfor (size_t i = 1; i < s.size(); ++i) {\n'
            '\t\tans[i] = (ans[i - 1] * p + s[i]) % mod;\n'
            '\t}\n'
            '\treturn ans;\n'
            '}\n'
            '\n'
            'Благодаря нахождению хэшей префиксов, можно искать хэши подстрок\n'
            'Код:\n'
            'long long subHash(int l, int r, long long mod) {\n'
            '\tlong long big = H[r];\n'
            '\tlong long small = 0;\n'
            '\tif (l != 0) {\n'
            '\t\tsmall = (H[l - 1] * st[r - l + 1]) % mod;\n'
            '\t}\n'
            '\treturn (big - small + mod) % mod;\n'
            '}\n'
            'st - список степеней p, H - список хэшей префиксов\n'
            '\n'
            'Про двойное хэширование:\n'
            'Двойной хэш - это пара двух значений хэша с разными p и mod (список пар)\n'
            'Все действия производятся не с числами, а с парами\n'
            'Пример двойного хэширования:\n'
            'const ll p1 = 179, Mod1 = 556556107;\n'
            'const ll p2 = 139, Mod2 = 2e9 + 11;\n'
            'vector<ll> powers1;\n'
            'vector<ll> powers2;\n'
            '\n'
            'vector<pair<ll, ll>> getHash(const string& s) {\n'
            '    vector<pair<ll, ll>> h(s.size());\n'
            '    h[0].first = s[0];\n'
            '    h[0].second = s[0];\n'
            '    for (int i = 1; i < s.size(); i++) {\n'
            '        h[i].first = (h[i - 1].first * p1 + s[i]) % Mod1;\n'
            '        h[i].second = (h[i - 1].second * p2 + s[i]) % Mod2;\n'
            '    }\n'
            '    return h;\n'
            '}\n'
            '\n'
            'pair<ll, ll> subHash(int l, int r, const vector<pair<ll, ll>>& h) {\n'
            '    pair<ll, ll> big = h[r];\n'
            '    pair<ll, ll> small = {0, 0};\n'
            '    if (l > 0) {\n'
            '        small.first = (h[l - 1].first * powers1[r - l + 1]) % Mod1;\n'
            '        small.second = (h[l - 1].second * powers2[r -l + 1]) % Mod2;\n'
            '    }\n'
            '    pair<ll, ll> res;\n'
            '    res.first = (big.first - small.first + Mod1) % Mod1;\n'
            '    res.second = (big.second - small.second + Mod2) % Mod2;\n'
            '    return res;\n'
            '}\n'
            '\n'
            'Что можно делать с хэшами:\n'
            '# Можно найти подстроку в строке (найти её хэш и посмотреть все хэши подстрок такой же длины)\n'
            '\n'
            '# Найти циклический сдвиг\n'
            '  Дано две строки. Вторая - циклический сдвиг первой\n'
            '  n - длина строки, k - сдвиг\n'
            '  Можно умножить первую строку на две, тогда она будет выглядеть так:\n'
            '  n - k   k   n - k   k\n'
            '  Вторая строка выглядит так:\n'
            '  k   n - k\n'
            '  Теперь можно найти вхождение второй строки в первую\n'
            '\n'
            '# Проверка подстроки на палиндром\n'
            '  Для этого нужно найти хэш подстроки и её обратный хэш (хэш перевёрнутой строки)\n'
            '  После этого проверить равенство хэшей\n'
            '\n'
            '# Проверка на период (можно ли разбить на одинаковые блоки длиной k)\n'
            '  Сначала нужно проверить, делится ли длина строки на k\n'
            '  Дальше нужно сравнить хэши строк от второго до последнего блока и от первого до предпоследнего\n'
            '  s[:n - k] и s[k + 1:]\n'
            '\n'
            '# Минимальный период строки\n'
            '  Нужно разложить длину строки на множители и увеличивать значение, пока строка яаляется периодом (делить на всё большее значение)\n'
            '\n'
            '# Сравнение строк\n'
            '  Нужно найти самый большой общий префикс, а потом сравнить символы после него\n'
            '  Длину префикса можно найти бинпоиском\n'
            '\n'
            '# Поиск подпалиндромов\n'
            '  Палиндром может быть нечётной длины (центр - символ) и чётной (центр между символами)\n'
            '  Можно пройти по строке, смотря на символы и промежутки между символами. Таким образом мы перебираем центр палиндрома\n'
            '  От каждого центра мы будем расширять строку, пока эта строка является палиндромом (проверка делается хэшами)\n'
            '\n'
            '  Но поиск палиндромов можно осуществить быстрее, проще и без хэшей с использованием Алгоритма Манакера\n'
            '  (раздел Manacher)\n'
            '\n'
            '# Поиск наибольшей общей подстроки\n'
            '  Посчитаем хэши двух строк\n'
            '  Теперь сделаем бинпоиск по длине общей подстроки\n'
            '  Для каждого значения m бинпоиска пройдём сначала по первой строке и положим все хэши подстрок длины m в map\n'
            '  Теперь пройдём по хэшам подстрок длины m второй строки и посмотрим, есть ли какие-то из них в map\n'
            '\n'
            '# z-функция\n'
            '  z-функция - это поиск максимального числа l, такого, что подстрока, начинающаяся в i и длиной l, равна префиксу длины l\n'
            '  l можно искать бинпоиском, а сравнивать строки - хэшами\n'
            '\n'
            '  Но z-функцию можно написать проще и без хэшей\n'
            '  (раздел z_function)\n'
            '\n'
            '# По строке можно построить дерево хэшей (описано в segment_tree_NEW)\n'
            '  Такое дерево позволяет делать операции с хэшами и изменять элементы строки\n')


def z_function():
    return ('Z-функция\n'
            '\n'
            'Z-функция для индекса i ищет максимальное число l, такое, что подстрока, начинающаяся в i и длиной l, равна префиксу длины l\n'
            '\n'
            'Z-функция может быть использована для проверки вхождения подстроки в строку (нужно дописать к меньшей строке символ, которого нет в обоих строках, и большую строку)\n'
            'тогда, посчитав z-функцию от получившейся строки можно будет найти все вхождения первой строки во вторую\n'
            '\n'
            'Z-функция может быть реализована по-разному\n'
            'Основные способы:\n'
            '1. Хэши (описано в hashes)\n'
            '2. Алгоритм, вычисляющий следующие значения, используя уже вычисленные значения\n'
            '\n'
            'Рассмотрим второй алгоритм\n'
            '\n'
            'Следующие значения вычисляются на основе предыдущих\n'
            'Хранятся границы такого z-блока, правая граница которого максимальна\n'
            '(z-блок - подстрока с началом в i и максимальной длиной l (значение z-функции для i))\n'
            '\n'
            'Есть два случая:\n'
            '1. i не лежит в сохранённом блоке (тогда нужно наивно пройти по строке и сравнить)\n'
            '2. i лежит в сохранённом блоке (тогда есть два случая)\n'
            '   2.1 z[i - left] + i > right (тогда нужно наивно пройти по строке от r и сравнить)\n'
            '   2.2. z[i - left] + i <= right (тогда уже известно значение, оно равно z[i - left])\n'
            '\n'
            'Реализация такого алгоритма (l, r на полуинтервалах):\n'
            'int n = s.size();\n'
            'vector<int> z(n);\n'
            'z[0] = n;\n'
            'int l = 0, r = 1;\n'
            'for (int i = 1; i < n; i++) {\n'
            '    z[i] = max(0, min(z[i - l], r - i));\n'
            '    while (s[z[i]] == s[z[i] + i]) {\n'
            '        z[i]++;\n'
            '    }\n'
            '    if (z[i] + i > r) {\n'
            '        r = z[i] + i;\n'
            '        l = i;\n'
            '    }\n'
            '}\n'
            '\n'
            'Применения:\n'
            '# Поиск подстроки в строке\n'
            '  Запишем две строки через спец. символ (сначала строка, которую мы ищем) и посчитаем z-функцию\n'
            '  Позиция, где z-функция равна длине искомой строки - начало вхождения подстроки\n'
            '\n'
            '# Период строки (требуется найти минимальную по длине строку t такую, что строку s можно представить в виде конкатенации нескольких строк t)\n'
            '  Посчитаем z-функцию\n'
            '  Теперь пройдём по массиву z и найдём первую позицию i такую, что i + z[i] == n && n % i == 0 (1-индексация)\n'
            '  Тогда ответ i\n'
            '  Если такой позиции нет, ответ - n\n')


def Manacher():
    return ('Алгоритм Манакера\n'
            '\n'
            'Алгоритм Манакера позволяет находить для каждого элемента строки максимальную длину подстроки-палиндрома с центром в этом элементе\n'
            '\n'
            'Алгоритм возвращает два массива половин длин палиндромов (для чётных и нечётных палиндромов)\n'
            'Благодаря этому можно легко найти общее кол-во палиндромов в строке, сложив все значения двух массивов\n'
            '\n'
            'Реализация Алгоритма Манакера схожа с реализацией оптимального алгоритма нахождения z-функции\n'
            'Следующие значения вычисляются на основе предыдущих и хранятся границы палиндрома, правая граница которого максимальна\n'
            '\n'
            'Есть 2 случая:\n'
            '1. Следующий элемент лежит в сохранённом палиндроме (тогда находится зеркальное значение и выполняется наивный алгоритм)\n'
            '2. Слудующий элемент не лежит в сохранённом палиндроме (наивный алгоритм)\n'
            '\n'
            'Реализация на C++:\n'
            'vector<int> one(string s) {\n'
            '\tint n = s.length();\n'
            '\tvector<int> d1(n);\n'
            '\tfor (int i = 0, l = 0, r = -1; i < n; i++) {\n'
            '\t\tint k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\n'
            '\t\twhile (0 <= i - k && i + k < n && s[i - k] == s[i + k]) {\n'
            '\t\t\tk++;\n'
            '\t\t}\n'
            '\t\td1[i] = k--;\n'
            '\t\tif (i + k > r) {\n'
            '\t\t\tl = i - k;\n'
            '\t\t\tr = i + k;\n'
            '\t\t}\n'
            '\t}\n'
            '\treturn d1;\n'
            '}\n'
            '\n'
            'vector<int> two(string s) {\n'
            '\tint n = s.length();\n'
            '\tvector<int> d2(n);\n'
            '\tfor (int i = 0, l = 0, r = -1; i < n; i++) {\n'
            '\t\tint k = (i > r) ? 0 : min(d2[l + r - i + 1], r - i + 1);\n'
            '\t\twhile (0 <= i - k - 1 && i + k < n && s[i - k - 1] == s[i + k]) {\n'
            '\t\t\tk++;\n'
            '\t\t}\n'
            '\t\td2[i] = k--;\n'
            '\t\tif (i + k > r) {\n'
            '\t\t\tl = i - k - 1;\n'
            '\t\t\tr = i + k;\n'
            '\t\t}\n'
            '\t}\n'
            '\treturn d2;\n'
            '}\n'
            '\n')


def bit_operations():
    return ('Битовые операции\n'
            '\b'
            'битовые операции значительно упрощают и ускоряют написание и работу некоторых алгоритмов, функций\n'
            '\n'
            '| - or\n'
            '& - and\n'
            '~ - not\n'
            '^ - xor\n'
            '>>, << - битовые сдвиги\n'
            'в основном биты считаютя справа налево\n'
            '\n'
            '1 << c                  # 2 в степени c\n'
            'x | (1 << n)            # установление n-ого бита в 1\n'
            'x & ~(1 << n)           # установление n-ого бита в 0\n'
            'x ^ (1 << n)            # инвертирование n-ого бита\n'
            'n << 1                  # умножение на 2\n'
            'n >> 1                  # целая часть от деления на 2\n'
            'n << m                  # умножение на 2^m\n'
            'n >> m                  # целая часть от деления на 2^m\n'
            '(a ^ b) == 0            # проверка на равенство\n'
            '(n & 1) == 1            # проверка на чётность\n'
            'int(bool(x & (1 << n))) # определение n-ого бита\n'
            '(x + y) >> 1            # среднее арифметическое (целое)\n')


def f_Euler():
    return ('Функия Эйлера\n'
            '\n'
            'Функция Эйлера вычисляет кол-во чисел от 1 до n, взаимно простых с n\n'
            '\n'
            'def fi(n):\n'
            '    ans = n\n'
            '    i = 2\n'
            '    while i * i <= n:\n'
            '        if n % i == 0:\n'
            '            while n % i == 0:\n'
            '                n //= i\n'
            '            ans -= ans // i\n'
            '        i += 1\n'
            '    if n > 1:\n'
            '        ans -= ans // n\n'
            '    print(ans)\n'
            '\n'
            'Асимптотика - O(sqrt(n))\n')


def quick_pow():
    return ('Быстрое возведение в степень\n'
            '\n'
            'def quick_pow(x, y):\n'
            '    if not y:\n'
            '        return 1\n'
            '    if not y % 2:\n'
            '        ans = quick_pow(x, y // 2)\n'
            '        return ans * ans\n'
            '    return quick_pow(x, y - 1) * x\n'
            '\n'
            'Асимптотика - O(log n)\n')


def eratosthenes_sieve():
    return ('N = int(input())                           # До какого числа мы ищем простые числа\n'
            'isPrime = [True] * (N + 1)                 # Создание списка из True\n'
            'Primes = []                                # Список, в котором будут простые числа\n'
            'for d in range(2, N + 1):\n'
            '    if isPrime[d]:\n'
            '        Primes.append(d)\n'
            '        for i in range(d ** 2, N + 1, 2): # Убираем лишние числа\n'
            '            isPrime[i] = False\n'
            'print(Primes)\n'
            '\n'
            'Алгоритм выше работает за O(n log log n)\n'
            'Существует алгоритм решета, работающий за O(n):\n'
            'vector<int> lp(N + 1, 0), pr;  // lp[i] - минимильный простой делитель числа i; pr - список простых чисел\n'
            'for (int i = 2; i <= N; i++) {\n'
            '    if (!lp[i]) {              // простое число или нет\n'
            '        lp[i] = i;\n'
            '        pr.push_back(i);\n'
            '    }\n'
            '    for (int j = 0; j < pr.size() && pr[j] * i <= N && pr[j] <= lp[i]; j++)\n'
            '        lp[pr[j] * i] = pr[j];\n'
            '}\n'
            '\n'
            'С помощью второго алгоритма можно выполнить факторизацию числа\n'
            'vector<int> factorize(int n, const vector<int>& lp) {\n'
            '    vector<int> ans;\n'
            '    while (n > 1) {\n'
            '        ans.push_back(lp[n]);\n'
            '        n /= lp[n];\n'
            '    }\n'
            '    return ans;\n'
            '}\n')


def check_for_simplicity():
    return ('z = False\n'
            'x = int(input())\n'
            'if x % 2 == 0 and x != 2:                    # Проверка, является ли число 2, и делится ли оно на два\n'
            '    print(\'NO\')\n'
            'else:\n'
            '    for i in range(3, int(x ** 0.5) + 1, 2):\n'
            '        if x % i == 0:\n'
            '            z = True\n'
            '            break                            # Если находится хотя бы один делитель, то число уже не является простым\n'
            '    if z:\n'
            '        print(\'NO\')\n'
            '    else:\n'
            '        print(\'YES\')')


def suffix_automaton():
    return ('Суффиксный автомат\n'
            '\n'
            'Суффиксный автомат - один из алгоритмов на строках, представляющий из себя ориентированный ациклический граф слов\n'
            '\n'
            'Граф состоит из состояний (вершин), переходов (рёбер) и суффиксных ссылок\n'
            'На переходах хранятся буквы\n'
            'Код:\n'
            'const int MAXLEN = 100000;\n'
            'state st[MAXLEN * 2];\n'
            'int sz, last;\n'
            '\n'
            'void sa_init() {\n'
            '    sz = last = 0;\n'
            '    st[0].len = 0;\n'
            '    st[0].link = -1;\n'
            '    ++sz;\n'
            '}\n'
            '\n'
            'void sa_extend(char c) {\n'
            '    int cur = sz++;\n'
            '    st[cur].len = st[last].len + 1;\n'
            '    int p;\n'
            '    for (p = last; p != -1 && !st[p].next.count(c); p = st[p].link)\n'
            '        st[p].next[c] = cur;\n'
            '    if (p == -1)\n'
            '        st[cur].link = 0;\n'
            '    else {\n'
            '        int q = st[p].next[c];\n'
            '        if (st[q].len == st[p].len + 1)\n'
            '            st[cur].link = q;\n'
            '        else {\n'
            '            int clone = sz++;\n'
            '            st[clone].link = st[q].link;\n'
            '            st[clone].next = st[q].next;\n'
            '            st[clone].len = st[p].len + 1;\n'
            '            for (; p != -1 && st[p].next[c] == q; p = st[p].link)\n'
            '                st[p].next[c] = clone;\n'
            '            st[q].link = st[cur].link = clone;\n'
            '        }\n'
            '    }\n'
            '    last = cur;\n'
            '}\n'
            '\n'
            'MAXLEN - максимальная длина строки во входных данных\n'
            'Суффиксный автомат каждый раз добавляет новую букву, поэтому создание происходит в цикле по всем буквам строки\n'
            '\n'
            'ПРИМЕНЕНИЯ:\n'
            '1. Проверка, является ли строка (s) подстрокой другой строки (S)n\n'
            'Создадим суффиксный автомат для S\n'
            'Теперь будем идти от t0 (начального состояния) по переходам, хранящим буквы s (если s = \"abc\", то a -> b -> c)\n'
            'Если мы прошли по всей строке, то она является подстрокой. Если в какой-то момент нет нужного перехода, то строка не является подстрокой\n'
            'Код:\n'
            'int v = 0;\n'
            'bool z = true;\n'
            'for (char & i : in) {\n'
            '    if (st[v].next.count(i))\n'
            '        v = st[v].next[i];\n'
            '    else {\n'
            '        z = false;\n'
            '        break;\n'
            '    }\n'
            '}\n'
            'if (z)\n'
            '    cout << "yes" << el;\n'
            'else\n'
            '    cout << "no" << el;\n'
            '\n'
            '2. Кол-во различных подстрок\n'
            'Нужно посчитать кол-во различных путей от начальной вершины\n'
            'Для этого добавим функцию подсчёта путей (dfs с dp):\n'
            'int col[MAXLEN * 2];\n'
            'll dp[MAXLEN * 2];\n'
            'void dfs(int v) {\n'
            '    col[v] = 1;\n'
            '    for (pair<const char, int>& item : st[v].next) {\n'
            '        if (!col[item.second])\n'
            '            dfs(item.second);\n'
            '        dp[v] += dp[item.second];\n'
            '    }\n'
            '    dp[v]++;\n'
            '    col[v] = 2;\n'
            '}\n'
            'Для ответа нужно запустить dfs от вершины 0 и вывести dp[0] - 1 (чтобы не учитывать пустую строку нужно вычесть 1)\n'
            '\n'
            '3. Минимальный циклический сдвиг строки\n'
            'Построим суффиксный автомат для строки (S + S)\n'
            'После этого пройдём по автомату от начальной вершины, выбирая жадно символы (каждый раз берём минимальный символ)\n'
            'Функция:\n'
            'string min_shift(int n) {\n'
            '    string ans;\n'
            '    int cur_len = 0, v = 0;\n'
            '    char c;\n'
            '    while (cur_len < n) {\n'
            '        cur_len++;\n'
            '        for (pair<const char, int>& item: st[v].next) {\n'
            '            v = item.second;\n'
            '            c = item.first;\n'
            '            break;\n'
            '        }\n'
            '        ans.push_back(c);\n'
            '    }\n'
            '    return ans;\n'
            '}\n'
            'Из основной программы функцию нужно запускать с аргументом n - начальная длина строки s (не удвоенная)\n'
            '\n'
            '4. Количество вхождений подстроки (с пересечениями):\n'
            'Создадим суффиксный автомат для большей строки\n'
            'Будем хранить массив cnt\n'
            'Добавим в самое начало (2 строка) функции создания автомата строку cnt[cur] = 1\n'
            'После создания пройдём по переходам-символам меньшей строки (см. пункт 1) и найдём последнее состояние v\n'
            'Выведем cnt[v]\n'
            'Код:\n'
            'void dfs(int v) {\n'
            '    col[v] = 1;\n'
            '    for (pair<const char, int>& item : st[v].next) {\n'
            '        if (!col[item.second])\n'
            '            dfs(item.second);\n'
            '        cnt[st[item.second].link] += cnt[item.second];\n'
            '    }\n'
            '    col[v] = 2;\n'
            '}\n'
            'Основная функция:\n'
            '...'
            'dfs(0);\n'
            'int v = 0;\n'
            'for (char & i : in)\n'
            '    v = st[v].next[i];\n'
            'cout << cnt[v];\n'
            '...\n'
            '\n'
            '5. Позиция первого вхождения строки в строку\n'
            'Будем хранить массив firstpos\n'
            'При создании st[cur] (начало функции), будем добавлять firstpos[cur] = st[cur].len - 1\n'
            'При клонировании firstpos[clone] = firstpos[q]\n'
            'Потом пройдём по символам меньшей строки p (см. предыдущие пункты) и найдём последнее состояние v\n'
            'Ответ: firstpos[v] - p.size() + 1\n'
            '\n'
            '6. Позиции всех вхождений\n'
            'Будем модифицировать предыдущий пункт\n'
            'В state добавим bool is_clone (метка клона). При клонировании будем писать st[clone].is_clone = true\n'
            'В state добавим vector<int> inv_link (ивертированные суффиксные ссылки)\n'
            'Сразу после создания автомата:\n'
            'for (int v = 1; v < sz; v++)\n'
            '    st[st[v].link].inv_link.push_back(v);\n'
            'Потом пройдём по символам меньшей строки и найдём последнее состояние v\n'
            'Ответ будем хранить в массиве allpos\n'
            'Функция для получения ответа:\n'
            'void find_allpos(int v, int p_len) {\n'
            '    if (!st[v].is_clone)\n'
            '        allpos.push_back(firstpos[v] - p_len + 1);\n'
            '    for (int i : st[v].inv_link)\n'
            '        find_allpos(i, p_len);\n'
            '}\n'
            'Из основной программы функцию следует запускать с аргументами v (найденное нами последнее состояние) и p_len (длина меньшей строки)\n'
            'ВАЖНО: 1. до создания автомата нужно проверить, является ли строка подстрокой, иначе ответ будет выглядеть странно\n'
            '       2. allpos не отсортирован; если нужен отсортированный ответ, нужно сделать сортировку до вывода массива\n'
            '\n'
            '7. Кратчайшая строка, не входящая в данную\n'
            'Будем решать с помощью dp\n'
            'Если из вершины v нет переходов по символам из алфавита, то dp[v] = 1\n'
            'Иначе dp[v] - это минимум из ответов по всем переходам + 1\n'
            '\n'
            '8. Наидлиннейшая общая подстрока двух строк\n'
            'Для первой строки построим автомат\n'
            'Втору строку передадми в функцию lcs\n'
            'Код:\n'
            'string lcs(string t) {\n'
            '    int v = 0, l = 0, best = 0, bestpos = 0;\n'
            '    for (int i = 0; i < t.size(); i++) {\n'
            '        while (v && !st[v].next.count(t[i])) {\n'
            '            v = st[v].link;\n'
            '            l = st[v].len;\n'
            '        }\n'
            '        if (st[v].next.count(t[i])) {\n'
            '            v = st[v].next[t[i]];\n'
            '            l++;\n'
            '        }\n'
            '        if (l > best) {\n'
            '            best = l;\n'
            '            bestpos = i;\n'
            '        }\n'
            '    }\n'
            '    return t.substr(bestpos - best + 1, best);\n'
            '}\n')


def Dijkstra():
    return ('Алгоритм Дейкстры\n'
            '\n'
            'Алгоритм Дейкстры - это алгоритм поиска кратчайших путей от начальной вершины до всех остальных во взвешенном графе\n'
            '\n'
            'Описание:\n'
            'Ответы для всех вершин будем хранить в массиве d\n'
            'Сначала все элементы d заполнены INF (большое число), кроме стартовой (s), d[s] = 0\n'
            'Каждую итерацию мы ищем непосещённую вершину с минимальным d[j] (v)\n'
            'После этого мы пытаемся обновить ответы для всех смежных вершин (минимум из d[смежная_вершина] и d[v] + длина_ребра)\n'
            '\n'
            'Также можно восстановить пути до вершин\n'
            'Для этого при обновлении ответов для смежных вершин будем присваивать p[смежная_вершина] = v\n'
            'После нужно будет пройтись от конечной вершины по предкам до начальной и развернуть полученный путь\n'
            '\n'
            'Можно не перебирать каждый раз вершину с наименьшим расстоянием, а использовать структуру, которая делает это автоматически - set\n'
            'Такой способ будет работать быстрее (кроме случая с полными графами - в полных графах лучше просто циклом искать вершину)\n'
            'int n, start, finish;\n'
            'cin >> n >> start >> finish;\n'
            'start--;\n'
            'finish--;\n'
            'vector<vector<pair<int, int>>> g(n);\n'
            'vector<int> p(n, -1);\n'
            '// Ввод графа (первое значение в паре - вершина, второе - вес)\n'
            'vector<int> d(n, INF);\n'
            'd[start] = 0;\n'
            'set<pair<int, int>> s;\n'
            's.insert({0, start});\n'
            'while (!s.empty()) {\n'
            '    int v = s.begin()->second;\n'
            '    s.erase(s.begin());\n'
            '    for (auto i: g[v]) {\n'
            '        int u = i.first;\n'
            '        int w = i.second;\n'
            '        if (d[u] > d[v] + w) {\n'
            '            s.erase({d[u], u});\n'
            '            d[u] = d[v] + w;\n'
            '            p[u] = v;\n'
            '            s.insert({d[u], u});\n'
            '        }\n'
            '    }\n'
            '}\n'
            'if (d[finish] == INF) {\n'
            '    cout << "-1\\n";\n'
            '    return 0;\n'
            '}\n'
            'cout << d[finish] << el;\n'
            'vector<int> path;\n'
            'for (int v = finish; v != start; v = p[v])\n'
            '    path.push_back(v + 1);\n'
            'path.push_back(s + 1);\n'
            'reverse(path.begin(), path.end());\n'
            'cout << path << el;\n')


def gcdex():
    return ('Расширенный алгоритм Евклида\n'
            '\n'
            'Алгоритм позволяет искать решения уравнения ax + by = c\n'
            '\n'
            'int gcd(int a, int b, int& x, int& y) {\n'
            '    if (a == 0) {\n'
            '        x = 0;\n'
            '        y = 1;\n'
            '        return b;\n'
            '    }\n'
            '    int x1, y1;\n'
            '    int g = gcd(b % a, a, x1, y1);\n'
            '    x = y1 - (b / a) * x1;\n'
            '    y = x1;\n'
            '    return g;\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int a, b, c, x, y;\n'
            '    cin >> a >> b >> c;\n'
            '    int signa = 1, signb = 1;\n'
            '    if (a < 0) {\n'
            '        a *= -1;\n'
            '        signa = -1;\n'
            '    }\n'
            '    if (b < 0) {\n'
            '        b *= -1;\n'
            '        signb = -1;\n'
            '    }\n'
            '    int g = gcd(a, b, x, y);\n'
            '    if (c % g != 0) {\n'
            '        cout << "Impossible" << endl;\n'
            '        return 0;\n'
            '    }\n'
            '    x *= (c / g) * signa;\n'
            '    y *= (c / g) * signb;\n'
            '    cout << \' \' << x << \' \' << y << endl;\n'
            '    return 0;\n'
            '}\n')


def sorts():
    return ('Сортировки\n'
            '\n'
            '1. Сортировка слиянием (mergesort):\n'
            'vector<int> tmp;\n'
            'void mergesort(vector<int>& a, int l, int r) {\n'
            '    if (l == r - 1)\n'
            '        return;\n'
            '    int m = (l + r) / 2;\n'
            '    mergesort(a, l, m);\n'
            '    mergesort(a, m, r);\n'
            '    merge(a.begin() + l, a.begin() + m, a.begin() + m, a.begin() + r, tmp.begin() + l);\n'
            '    copy(tmp.begin() + l, tmp.begin() + r, a.begin() + l);\n'
            '}\n'
            'Из основной программы запускается с l = 0 и r = n\n'
            '\n'
            'Если написать свой merge, то можно считать кол-во инверсий в массиве\n'
            'vector<int> tmp;\n'
            'll ans = 0;\n'
            'void mergesort(vector<int>& a, int l, int r) {\n'
            '    if (l == r - 1)\n'
            '        return;\n'
            '    int m = (l + r) / 2;\n'
            '    mergesort(a, l, m);\n'
            '    mergesort(a, m, r);\n'
            '    int it1 = l, it2 = m, pos = l;\n'
            '    while(it1 < m || it2 < r) {\n'
            '        if (it1 == m) {\n'
            '            tmp[pos] = a[it2];\n'
            '            ++it2;\n'
            '        }\n'
            '        else if (it2 == r) {\n'
            '            tmp[pos] = a[it1];\n'
            '            ++it1;\n'
            '        }\n'
            '        else if (a[it1] <= a[it2]){\n'
            '            tmp[pos] = a[it1];\n'
            '            ++it1;\n'
            '        }\n'
            '        else {\n'
            '            tmp[pos] = a[it2];\n'
            '            ++it2;\n'
            '            ans += (m - it1);\n'
            '        }\n'
            '        ++pos;\n'
            '    }\n'
            '    copy(tmp.begin() + l, tmp.begin() + r, a.begin() + l);\n'
            '}\n'
            '\n'
            '2. Пузырьковая сортировка (bubble sort):\n'
            'int n;\n'
            'cin >> n;\n'
            'vector<int> a(n);\n'
            'cin >> a;\n'
            'for (int i = 0; i < n - 1; i++) {\n'
            '    for (int j = 0; j < n - 1; j++) {\n'
            '        if (a[j] > a [j + 1])\n'
            '            swap(a[j], a[j + 1]);\n'
            '    }\n'
            '}\n'
            '\n'
            '3. Сортировка выбором минимума/максимума:\n'
            'int n;\n'
            'cin >> n;\n'
            'vector<int> a(n);\n'
            'cin >> a;\n'
            'for (int i = 0; i < n; i++) {\n'
            '    int pos = min_element(a.begin() + i, a.end()) - a.begin();\n'
            '    swap(a[i], a[pos]);\n'
            '}\n'
            'cout << a << el;\n')


def factorize():
    return ('Факторизация\n'
            '\n'
            'Факторизация числа - это разложение числа на простые множители\n'
            'int n;\n'
            'cin >> n;\n'
            'vector<int> ans;\n'
            'int n1 = n;\n'
            'for (int i = 2; i * i <= n1; i++) {\n'
            '    while (n % i == 0) {\n'
            '        ans.push_back(i);\n'
            '        n /= i;\n'
            '    }\n'
            '}\n'
            'if (n > 1)\n'
            '    ans.push_back(n);\n'
            'cout << ans << endl;\n'
            '\n'
            'Также факторизацию можно выполнить при помощи быстрого решета Эратосфена (см. eratosthenes_sieve)\n')


def gcd_lcm():
    return ('НОД и НОК\n'
            '\n'
            'НОД - наибольший общий делитель\n'
            'int a, b;\n'
            'cin >> a >> b;\n'
            'while (a != 0) {\n'
            '    b %= a;\n'
            '    swap(a, b);\n'
            '}\n'
            'cout << b << endl;\n'
            '\n'
            'НОК - наименьшее общее кратное\n'
            'НОК(a, b) = (a * b) / НОД(a, b)\n')


def LCS():
    return ('// НОП (наибольшая общая подпоследовательность) с восстановлением ответа\n'
            '#pragma GCC optimize("Ofast")\n'
            '#include <bits/stdc++.h>\n'
            'using namespace std;\n'
            '\n'
            '#define ll long long\n'
            '#define Yes cout << "Yes" << el\n'
            '#define No cout << "No" << el\n'
            '#define el \'\\n\'\n'
            '#define fastIO ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\n'
            '#define fileIO freopen("input.txt", "r", stdin);freopen("output.txt", "w", stdout)\n'
            'template <class T1, class T2> istream& operator >>(istream& in, pair<T1, T2>& p) {in >> p.first >> p.second; return in;}\n'
            'template <class T1, class T2> ostream& operator <<(ostream& out, const pair<T1, T2>& p) {out << p.first << \' \' << p.second << el; return out;}\n'
            'template <class T> istream& operator >>(istream& in, vector<T>& arr) {for (T& i: arr) in >> i; return in;}\n'
            'template <class T> ostream& operator <<(ostream& out, const vector<T>& arr) {for (const T& i: arr) out << i << \' \'; return out;}\n'
            'template <class T> ostream& operator <<(ostream& out, const vector<vector<T>>& arr) {for (const vector<T>& i: arr) out << i << \' \' << el; return out;}\n'
            '\n'
            'int get(int i, int j, const vector<vector<int>>& dp) {\n'
            '    if (i < 0 || j < 0)\n'
            '        return 0;\n'
            '    return dp[i][j];\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    fastIO;\n'
            '    // fileIO;\n'
            '    int n, m;\n'
            '    cin >> n;\n'
            '    vector<int> a(n);\n'
            '    cin >> a >> m;\n'
            '    vector<int> b(m);\n'
            '    cin >> b;\n'
            '    vector<vector<int>> dp(n, vector<int>(m));\n'
            '    vector<vector<int>> p(n, vector<int>(m, -1));\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        for (int j = 0; j < m; j++) {\n'
            '            if (a[i] == b[j]) {\n'
            '                dp[i][j] = get(i - 1, j - 1, dp) + 1;\n'
            '                p[i][j] = 1;\n'
            '            }\n'
            '            else {\n'
            '                if (get(i - 1, j, dp) < get(i, j - 1, dp)) {\n'
            '                    dp[i][j] = get(i, j - 1, dp);\n'
            '                    p[i][j] = 2;\n'
            '                }\n'
            '                else {\n'
            '                    dp[i][j] = get(i - 1, j, dp);\n'
            '                    p[i][j] = 3;\n'
            '                }\n'
            '            }\n'
            '        }\n'
            '    }\n'
            '    // make answer\n'
            '    vector<int> ans;\n'
            '    int curi = n - 1, curj = m - 1;\n'
            '    while (curi >= 0 && curj >= 0) {\n'
            '        if (p[curi][curj] == 1) {\n'
            '            ans.push_back(a[curi]);\n'
            '            curi--;\n'
            '            curj--;\n'
            '        }\n'
            '        else if (p[curi][curj] == 2) {\n'
            '            curj--;\n'
            '        }\n'
            '        else {\n'
            '            curi--;\n'
            '        }\n'
            '    }\n'
            '    reverse(ans.begin(), ans.end());\n'
            '    cout << ans << el;\n'
            '    return 0;\n'
            '}\n')


def LIS():
    return ('// НВП (наибольшая возрастающая подпоследовательность)\n'
            '#pragma GCC optimize("Ofast")\n'
            '#include <bits/stdc++.h>\n'
            'using namespace std;\n'
            '\n'
            '#define ll long long\n'
            '#define Yes cout << "Yes" << el\n'
            '#define No cout << "No" << el\n'
            '#define el \'\\n\'\n'
            '#define fastIO ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\n'
            '#define fileIO freopen("input.txt", "r", stdin);freopen("output.txt", "w", stdout)\n'
            'template <class T1, class T2> istream& operator >>(istream& in, pair<T1, T2>& p) {in >> p.first >> p.second; return in;}\n'
            'template <class T1, class T2> ostream& operator <<(ostream& out, const pair<T1, T2>& p) {out << p.first << \' \' << p.second << el; return out;}\n'
            'template <class T> istream& operator >>(istream& in, vector<T>& arr) {for (T& i: arr) in >> i; return in;}\n'
            'template <class T> ostream& operator <<(ostream& out, const vector<T>& arr) {for (const T& i: arr) out << i << \' \'; return out;}\n'
            'template <class T> ostream& operator <<(ostream& out, const vector<vector<T>>& arr) {for (const vector<T>& i: arr) out << i << \' \' << el; return out;}\n'
            '\n'
            'signed main() {\n'
            '    fastIO;\n'
            '    // fileIO;\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    vector<int> a(n);\n'
            '    cin >> a;\n'
            '    vector<int> dp(n, 1);\n'
            '    vector<int> p(n, -1);\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        for (int j = 0; j < i; j++) {\n'
            '            if (a[i] > a[j] && dp[j] + 1 > dp[i]) {\n'
            '                dp[i] = dp[j] + 1;\n'
            '                p[i] = j;\n'
            '            }\n'
            '        }\n'
            '    }\n'
            '    // make answer\n'
            '    int cur = max_element(dp.begin(), dp.end()) - dp.begin();\n'
            '    vector<int> ans;\n'
            '    while (cur != -1) {\n'
            '        ans.push_back(a[cur]);\n'
            '        cur = p[cur];\n'
            '    }\n'
            '    reverse(ans.begin(), ans.end());\n'
            '    cout << ans << el;\n'
            '    return 0;\n'
            '}\n'
            '\n\n'
            '// Быстрый НВП (наибольшая возрастающая последовательность) с восстановлением ответа\n'
            '#pragma GCC optimize("Ofast")\n'
            '#include <bits/stdc++.h>\n'
            'using namespace std;\n'
            '\n'
            '#define ll long long\n'
            '#define Yes cout << "Yes" << el\n'
            '#define No cout << "No" << el\n'
            '#define el \'\\n\'\n'
            '#define fastIO ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL)\n'
            '#define fileIO freopen("input.txt", "r", stdin);freopen("output.txt", "w", stdout)\n'
            'template <class T1, class T2> istream& operator >>(istream& in, pair<T1, T2>& p) {in >> p.first >> p.second; return in;}\n'
            'template <class T1, class T2> ostream& operator <<(ostream& out, const pair<T1, T2>& p) {out << p.first << \' \' << p.second << el; return out;}\n'
            'template <class T> istream& operator >>(istream& in, vector<T>& arr) {for (T& i: arr) in >> i; return in;}\n'
            'template <class T> ostream& operator <<(ostream& out, const vector<T>& arr) {for (const T& i: arr) out << i << \' \'; return out;}\n'
            'template <class T> ostream& operator <<(ostream& out, const vector<vector<T>>& arr) {for (const vector<T>& i: arr) out << i << \' \' << el; return out;}\n'
            '\n'
            'signed main() {\n'
            '    fastIO;\n'
            '    // fileIO;\n'
            '    int INF = 1e9;\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    vector<int> a(n);\n'
            '    cin >> a;\n'
            '    vector<int>dp(n + 1, INF);\n'
            '    vector<int>index(n + 1, -1);\n'
            '    vector<int>p(n, -1);\n'
            '    dp[0] = -INF;\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        int pos = lower_bound(dp.begin(), dp.end(), a[i]) - dp.begin();\n'
            '        p[i] = index[pos - 1];\n'
            '        dp[pos] = a[i];\n'
            '        index[pos] = i;\n'
            '    }\n'
            '\n'
            '    // make answer\n'
            '    for (int i = n; i >= 0; --i) {\n'
            '        if (dp[i] != INF) {\n'
            '            int cur = index[i];\n'
            '            vector<int> ans;\n'
            '            while (cur != -1) {\n'
            '                ans.push_back(a[cur]);\n'
            '                cur = p[cur];\n'
            '            }\n'
            '            reverse(ans.begin(), ans.end());\n'
            '            cout << ans << el;\n'
            '            break;\n'
            '        }\n'
            '    }\n'
            '    return 0;\n'
            '}\n')


def segment_tree():
    return ('Дерево отрезков\n'
            '\n'
            'Дерево отрезков - структура данных, хранящая значения функций для всех отрезков массива\n'
            'Листья - элементы массива, уровень выше - объединение листьев (непересекающиеся отрезки массива длины 2) и т.д.\n'
            'Дерево отрезков удобно хранить в массиве: сыновья вершины v - v * 2 + 1 и v * 2 + 2\n'
            '\n'
            'Все примеры кода используют дерево отрезков НА ПОЛУИНТЕРВАЛАХ'
            '\n'
            'Дерево для поиска позиции максимума на отрезке с изменением элементов\n'
            'В самом дереве хранится индекс, для поиска максимума сделана функция Max\n'
            'Для нейтрального элемента к массиву добавлено самое маленькое значение\n'
            '\n'
            'int n;\n'
            'vector<int> a, t;\n'
            '\n'
            'int Max(int i, int j) {\n'
            '    if (a[i] > a[j])\n'
            '        return i;\n'
            '    return j;\n'
            '}\n'
            '\n'
            'void build(int v, int l, int r) {\n'
            '    if (r - l == 1) {\n'
            '        t[v] = l;\n'
            '        return;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    build(v * 2 + 1, l, m);\n'
            '    build(v * 2 + 2, m, r);\n'
            '    t[v] = Max(t[v * 2 + 1], t[v * 2 + 2]);\n'
            '}\n'
            '\n'
            'int ask(int v, int l, int r, int askl, int askr) {\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return n; // neutral element\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        return t[v];\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    return Max(ask(2 * v + 1, l, m, askl, askr), ask(2 * v + 2, m, r, askl, askr));\n'
            '}\n'
            '\n'
            'void change(int v, int l, int r, int pos, int val) {\n'
            '    if (r - l == 1) {\n'
            '        a[l] = val;\n'
            '        t[v] = val;\n'
            '        return;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    if (pos < m) {\n'
            '        change(2 * v + 1, l, m, pos, val);\n'
            '    }\n'
            '    else {\n'
            '        change(2 * v + 2, m, r, pos, val);\n'
            '    }\n'
            '    t[v] = Max(t[v * 2 + 1], t[v * 2 + 2]);\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    cin >> n;\n'
            '    a.resize(n);\n'
            '    t.resize(4 * n);\n'
            '    cin >> a;\n'
            '    a.push_back(-INT_MAX);\n'
            '    build(0, 0, n);\n'
            '\n'
            '    int q;\n'
            '    cin >> q;\n'
            '    while (q--) {\n'
            '        int l, r;\n'
            '        cin >> l >> r;\n'
            '        int ind = ask(0, 0, n, l - 1, r);\n'
            '        cout << a[ind] << \' \' << ind + 1 << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Функция ask проверяет цвет вершины:\n'
            'жёлтая - пересечение с отрезком запроса\n'
            'зелёная - текущий отрезок входит в отрезок запроса\n'
            'красная - нет пересечения с отрезком запроса\n'
            '\n'
            'Из зелёной вершины всегда идут зелёные, из красной - красные\n'
            'Первый if - проверка на красную, второй - на зелёную\n'
            '\n'
            'При сумме нейтральный элемент - 0\n'
            '\n'
            'Универсальное дерево - это вершина Node() и функция unite()\n'
            'В универсальном дереве меняется только Node() и unite()\n'
            'Пример (кол-во максимумов на отрезке):\n'
            'struct Node {\n'
            '    int maxx, cnt;\n'
            '    Node(): maxx(-INT_MAX), cnt(0) {}\n'
            '};\n'
            '\n'
            'int n;\n'
            'vector<int> a;\n'
            'vector<Node> t;\n'
            '\n'
            'Node unite(const Node& a, const Node& b) {\n'
            '    Node res;\n'
            '    if (a.maxx > b.maxx) {\n'
            '        res = a;\n'
            '    }\n'
            '    else if (a.maxx < b.maxx) {\n'
            '        res = b;\n'
            '    }\n'
            '    else {\n'
            '        res.maxx = a.maxx;\n'
            '        res.cnt = a.cnt + b.cnt;\n'
            '    }\n'
            '    return res;\n'
            '}\n'
            '\n'
            'void build(int v, int l, int r) {\n'
            '    if (r - l == 1) {\n'
            '        t[v].maxx = a[l];\n'
            '        t[v].cnt = 1;\n'
            '        return;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    build(v * 2 + 1, l, m);\n'
            '    build(v * 2 + 2, m, r);\n'
            '    t[v] = unite(t[v * 2 + 1], t[v * 2 + 2]);\n'
            '}\n'
            '\n'
            'Node ask(int v, int l, int r, int askl, int askr) {\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return Node();\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        return t[v];\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    return unite(ask(2 * v + 1, l, m, askl, askr), ask(2 * v + 2, m, r, askl, askr));\n'
            '}\n'
            '\n'
            'void change(int v, int l, int r, int pos, int val) {\n'
            '    if (r - l == 1) {\n'
            '        t[v].maxx = val;\n'
            '        t[v].cnt = 1;\n'
            '        return;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    if (pos < m) {\n'
            '        change(2 * v + 1, l, m, pos, val);\n'
            '    }\n'
            '    else {\n'
            '        change(2 * v + 2, m, r, pos, val);\n'
            '    }\n'
            '    t[v] = unite(t[v * 2 + 1], t[v * 2 + 2]);\n'
            '}\n'
            '\n'
            'Node и unite для посика наибольшей суммы подотрезка на отрезке:\n'
            'Node unite(const Node& a, const Node& b) {\n'
            '    Node res;\n'
            '    res.summ = a.summ + b.summ;\n'
            '    res.maxpref = max(a.maxpref, a.summ + b.maxpref);\n'
            '    res.maxsuff = max(b.maxsuff, b.summ + a.maxsuff);\n'
            '    res.maxsum = max({a.maxsum, b.maxsum, a.maxsuff + b.maxpref});\n'
            '    return res;\n'
            '}\n'
            'struct Node {\n'
            '    int maxsum, maxpref, maxsuff, summ;\n'
            '    Node(): maxsum(0), maxpref(0), maxsuff(0), summ(0) {}\n'
            '    Node(int x): maxsum(x), maxpref(x), maxsuff(x), summ(x) {}\n'
            '\n'
            '};\n'
            '\n'
            'МАССОВЫЕ ОПЕРАЦИИ\n'
            'Массовые операции - операции прибавления и присвоения на отрезке\n'
            'Для массовых операций используются отложенные операции (выполняем операцию, когда понадобится соответствующий отрезок)\n'
            'Реализация прибавления и присвоения различны\n'
            '\n'
            'Массовое прибавление (для суммы):\n'
            'void push(int v) {\n'
            '    c[v * 2 + 1] += c[v];\n'
            '    c[v * 2 + 2] += c[v];\n'
            '    c[v] = 0;\n'
            '}\n'
            'int ask(int v, int l, int r, int askl, int askr) {\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return 0;\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        return t[v] + c[v] * (r - l);\n'
            '        // for min: return t[v] + c[v];\n'
            '    }\n'
            '    push(v);\n'
            '    int m = (l + r) / 2;\n'
            '    int x = ask(2 * v + 1, l, m, askl, askr);\n'
            '    int y = ask(2 * v + 2, m, r, askl, askr);\n'
            '    t[v] = t[v * 2 + 1] + t[v * 2 + 2] + c[v * 2 + 1] * (m - l) + c[v * 2 + 2] * (r - m);\n'
            '    return x + y;\n'
            '}\n'
            'void change(int v, int l, int r, int askl, int askr, int val) {\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return;\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        c[v] += val;\n'
            '        return;\n'
            '    }\n'
            '    push(v);\n'
            '    int m = (l + r) / 2;\n'
            '    change(v * 2 + 1, l, m, askl, askr, val);\n'
            '    change(v * 2 + 2, m, r, askl, askr, val);\n'
            '    t[v] = t[v * 2 + 1] + t[v * 2 + 2] + c[v * 2 + 1] * (m - l) + c[v * 2 + 2] * (r - m);\n'
            '    // for min: t[v] = min(t[v * 2 + 1] + c[v * 2 + 1], t[v * 2 + 2] + c[v * 2 + 2]);\n'
            '}\n'
            '\n'
            'Для этой опперации понадобится массив c (размер 4*n), в котором будут хранится значения, которые нужно прибавить\n'
            'Также используется операция проталкивания (push), которая заносит прибавление в вершине в её сыновей\n'
            'build не меняется\n'
            '\n'
            'Массовове присвоение (для суммы):\n'
            'void push(int v) {\n'
            '    if (isch[v]) {\n'
            '        c[v * 2 + 1] = c[v];\n'
            '        c[v * 2 + 2] = c[v];\n'
            '        isch[v * 2 + 1] = true;\n'
            '        isch[v * 2 + 2] = true;\n'
            '        isch[v] = false;\n'
            '    }\n'
            '}\n'
            'int ask(int v, int l, int r, int askl, int askr) {\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return 0;\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        return (isch[v] ? c[v] * (r - l) : t[v]);\n'
            '    }\n'
            '    push(v);\n'
            '    int m = (l + r) / 2;\n'
            '    int x = ask(2 * v + 1, l, m, askl, askr);\n'
            '    int y = ask(2 * v + 2, m, r, askl, askr);\n'
            '    t[v] = t[v * 2 + 1] + t[v * 2 + 2] + c[v * 2 + 1] * (m - l) + c[v * 2 + 2] * (r - m);\n'
            '    return x + y;\n'
            '}\n'
            'void change(int v, int l, int r, int askl, int askr, int val) {\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return;\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        c[v] = val;\n'
            '        isch[v] = true;\n'
            '        return;\n'
            '    }\n'
            '    push(v);\n'
            '    int m = (l + r) / 2;\n'
            '    change(v * 2 + 1, l, m, askl, askr, val);\n'
            '    change(v * 2 + 2, m, r, askl, askr, val);\n'
            '    t[v] = (isch[v * 2 + 1] ? c[v * 2 + 1] * (m - l) : t[v * 2 + 1]) + (isch[v * 2 + 2] ? c[v * 2 + 2] * (r - m) : t[v * 2 + 2]);\n'
            '    // for min: min((isch[v * 2 + 1] ? c[v * 2 + 1] * (m - l) : t[v * 2 + 1]), (isch[v * 2 + 2] ? c[v * 2 + 2] * (r - m) : t[v * 2 + 2]));\n'
            '}\n'
            '\n'
            'Для присвоения добавляется массив bool isch, который хранит true, если было изменение в данной вершине\n'
            '\n'
            'Используя дерево отрезков, можно построить дерево хэшей и делать операции с хэшами, имея аозможность изменять элементы строки\n'
            'Получение хэша подстроки с изменением элемента (в коде в функции передаются дерево и строка, потому что часто строк несколько, нужны обратные хэши и т.д., поэтому нужны несколько деревьев):\n'
            'll unite(ll h1, ll h2, int len2) {\n'
            '    return (h1 * powers[len2] + h2) % MOD;\n'
            '}\n'
            'void build(vector<ll>& tree, const string& str, int v, int l, int r) {\n'
            '    if (r - l == 1) {\n'
            '        tree[v] = str[l];\n'
            '        return;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    build(tree, str, v * 2 + 1, l, m);\n'
            '    build(tree, str, v * 2 + 2, m, r);\n'
            '    tree[v] = unite(tree[v * 2 + 1], tree[v * 2 + 2], r - m);\n'
            '}\n'
            'void change(vector<ll>& tree, int v, int l, int r, int pos, char val) {\n'
            '    if (r - l == 1) {\n'
            '        tree[v] = val;\n'
            '        return;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    if (pos < m) {\n'
            '        change(tree, v * 2 + 1, l, m, pos, val);\n'
            '    }\n'
            '    else {\n'
            '        change(tree, v * 2 + 2, m, r, pos, val);\n'
            '    }\n'
            '    tree[v] = unite(tree[v * 2 + 1], tree[v * 2 + 2], r - m);\n'
            '}\n'
            'void ask(const vector<ll>& tree, vector<pair<ll, int>>& Nodes, int v, int l, int r, int askl, int askr) {\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return;\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        Nodes.push_back({tree[v], r - l});\n'
            '        return;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    ask(tree, Nodes, v * 2 + 1, l, m, askl, askr);\n'
            '    ask(tree, Nodes, v * 2 + 2, m, r, askl, askr);\n'
            '}\n'
            'ask не возвращает хэш, а складывает ответ в массив\n'
            'Это нужно, чтобы получить конечный ответ\n'
            'Получить его можно, просто сделав несколько unite по массиву Nodes (ведь дерево отрезков положит хэши в массив в правильном порядке)\n')


def ternary_search():
    return ('Тернарный/троичный поиск\n'
            '\n'
            'Тернарный поиск применяется для функций с одним экстремумом\n'
            'Тернарный поиск ищет этот экстремум\n'
            'Для этого отрезок делится на 3 части (m1 и m2)\n'
            '\n'
            '// f(m1) < f(m2) => r = m2\n'
            '// f(m1) > f(m2) => l = m1\n'
            '// f(m1) = f(m2) => l = m1 and r = m2\n'
            'double l = -100, r = 100;\n'
            'for (int it = 0; it <= 10; it++) {\n'
            '    double m1 = l + (r - l) / 3;\n'
            '    double m2 = m1 + (r - l) / 3;\n'
            '    if (f(m1) < f(m2)) // если выгнуто вниз, то <, иначе >\n'
            '        r = m2;\n'
            '    else\n'
            '        l = m1;\n'
            '}\n')


def pref_sum():
    return ('Префиксные суммы\n'
            '\n'
            'Префиксные суммы позволяют считать сумму (и не только) на всех отрезках (и не только)\n'
            '\n'
            'Создаётся массив, в котором записаны суммы на всех префиксах (по увеличению длины)\n'
            'Если поступает запрос на отрезок с l по r (0-индексация), то\n'
            'if (l == 0) {\n'
            '    ans = pref[r];\n'
            '}\n'
            'else {\n'
            '    ans = pref[r] - pref[l - 1];\n'
            '}\n'
            '\n'
            'Префиксные суммы могут быть n-мерными\n'
            'Двумерные префиксные суммы:\n'
            'vector<vector<ll>> pref(n, vector<ll>(m));\n'
            'for (int i = 0; i < n; i++) {\n'
            '    for (int j = 0; j < m; j++) {\n'
            '        pref[i][j] = a[i][j];\n'
            '        if (i > 0) {\n'
            '            pref[i][j] += pref[i - 1][j];\n'
            '        }\n'
            '        if (j > 0) {\n'
            '            pref[i][j] += pref[i][j - 1];\n'
            '        }\n'
            '        if (i > 0 && j > 0) {\n'
            '            pref[i][j] -= pref[i - 1][j - 1];\n'
            '        }\n'
            '    }\n'
            '}\n'
            'int l1, r1, l2, r2;\n'
            'cin >> l1 >> r1 >> l2 >> r2;\n'
            'll ans = pref[r1][r2];\n'
            'if (l1 > 0) {\n'
            '    ans -= pref[l1 - 1][r2];\n'
            '}\n'
            'if (l2 > 0) {\n'
            '    ans -= pref[r1][l2 - 1];\n'
            '}\n'
            'if (l1 > 0 && l2 > 0) {\n'
            '    ans += pref[l1 - 1][l2 - 1];\n'
            '}\n')


def sparse_table():
    return ('Sparse table (разреженная таблица)\n'
            'Разреженная таблица (sparse table)\n'
            '\n'
            'Sparse table - структура, позволяющая хранить и получать нужную информацию о всех отрезках массива\n'
            'Sparse table - это двумерный массив, который хранит информацию о всех отрезках, длины которых равны степеням двойки\n'
            '\n'
            'таблица выглядит так:\n'
            '       степени\n'
            '    |0 1 2 3 4 5\n'
            '-----------------\n'
            'и 0 |             \n'
            'н 1 |  ч           \n'
            'д 2 |    и         \n'
            'е 3 |      с       \n'
            'к 4 |        л     \n'
            'с 5 |          а   \n'
            '\n'
            'Сверху - степени двойки, слева - индекс начала отрезка (индекс первого элемента отрезка)\n'
            '\n'
            'int n;\n'
            'cin >> n;\n'
            'vector<int> a(n);\n'
            'cin >> a;\n'
            'vector<int> logs(n + 1);\n'
            'logs[1] = 0;\n'
            'for (int i = 2; i <= n; i++) {\n'
            '    logs[i] = logs[i / 2] + 1;\n'
            '}\n'
            'vector<vector<int>> sparse(logs[n] + 1, vector<int>(n));\n'
            'for (int i = 0; i < n; i++) {\n'
            '    sparse[0][i] = a[i];\n'
            '}\n'
            'for (int level = 1; (1 << level) <= n; level++) {\n'
            '    for (int i = 0; i + (1 << level) <= n; i++) {\n'
            '        sparse[level][i] = min(sparse[level - 1][i], sparse[level - 1][i + (1 << (level - 1))]);\n'
            '    }\n'
            '}\n'
            'int l, r;\n'
            'cin >> l >> r;\n'
            'l--;\n'
            'r--;\n'
            'int len = r - l + 1;\n'
            'int level = logs[len];\n'
            'int ans = min(sparse[level][l], sparse[level][r - (1 << level) + 1]);\n'
            'cout << ans << el;\n'
            '\n'
            'sparse table - неизменяемая структура (для изменения элементов нужно перестравивать всю таблицу)\n')


def sqrt_decomposition():
    return ('Корневая декомпозиция\n'
            '\n'
            'Смысл декомпозиции - разбиение отрезка на блоки\n'
            'Тогда, когда мы получаем запрос, мы можем посчитать значения в блоках, которые полностью входят в отрезок, а на частичных блоках посчитать, просто пройдя по эти частям\n'
            'Блоки равны корню из длины массива\n'
            '\n'
            'Также корневая декомпозиция поддерживает изменения элементов\n'
            'Для этого используются отложенные изменения\n'
            '\n'
            'Минимум на [l, r]:\n'
            'struct Block {\n'
            '    vector<int> arr;\n'
            '    int minElement;\n'
            '    int len;\n'
            '    void build() {\n'
            '        len = arr.size();\n'
            '        minElement = arr[0];\n'
            '        for (int i = 1; i < len; i++) {\n'
            '            minElement = min(arr[i], minElement);\n'
            '        }\n'
            '    }\n'
            '    int fullQuery() {\n'
            '        return minElement;\n'
            '    }\n'
            '    int partQuery(int l, int r) {\n'
            '        int ans = arr[l];\n'
            '        for (int i = l + 1; i <= r; i++) {\n'
            '            ans = min(ans, arr[i]);\n'
            '        }\n'
            '        return ans;\n'
            '    }\n'
            '    void change(int i, int val) {\n'
            '        arr[i] = val;\n'
            '        build();\n'
            '    }\n'
            '};\n'
            'struct SQRT {\n'
            '    vector<Block> bl;\n'
            '    int bSize, len;\n'
            '    SQRT(const vector<int>& a) {\n'
            '        int n = a.size();\n'
            '        bSize = (int)sqrt(n);\n'
            '        len = 0;\n'
            '        for (int i = 0; i < n; i++) {\n'
            '            int b = i / bSize;\n'
            '            if (b == len) {\n'
            '                bl.push_back(Block());\n'
            '                len++;\n'
            '            }\n'
            '            bl[b].arr.push_back(a[i]);\n'
            '        }\n'
            '        for (int i = 0; i < len; i++) {\n'
            '            bl[i].build();\n'
            '        }\n'
            '    }\n'
            '    int ask(int l, int r) {\n'
            '        int posl = l / bSize, posr = r / bSize;\n'
            '        int posinl = l % bSize, posinr = r % bSize;\n'
            '        if (posl == posr) {\n'
            '            return bl[posl].partQuery(posinl, posinr);\n'
            '        }\n'
            '        int ans = INT_MAX;\n'
            '        if (posinl != 0) {\n'
            '            ans = min(ans, bl[posl].partQuery(posinl, bl[posl].len - 1));\n'
            '            posl++;\n'
            '        }\n'
            '        if (posinr != bl[posr].len - 1) {\n'
            '            ans = min(ans, bl[posr].partQuery(0, posinr));\n'
            '            posr--;\n'
            '        }\n'
            '        for (int i = posl; i <= posr; i++) {\n'
            '            ans = min(ans, bl[i].fullQuery());\n'
            '        }\n'
            '        return ans;\n'
            '    }\n'
            '    void change(int i, int val) {\n'
            '        int pos = i / bSize;\n'
            '        int posin = i % bSize;\n'
            '        //int posin = i - pos * bSize;\n'
            '        bl[pos].change(posin, val);\n'
            '    }\n'
            '};\n'
            '\n'
            'Сумма на [l, r] + изменения на [l1, r1]:\n'
            'struct Block {\n'
            '    vector<int> arr;\n'
            '    int summ;\n'
            '    bool has_set;\n'
            '    int set;\n'
            '    int len;\n'
            '    void build() {\n'
            '        len = arr.size();\n'
            '        has_set = false;\n'
            '        set = 0;\n'
            '        summ = 0;\n'
            '        for (int i: arr) {\n'
            '            summ += i;\n'
            '        }\n'
            '    }\n'
            '    void push() {\n'
            '        if (!has_set)\n'
            '            return;\n'
            '        for (int i = 0; i < len; i++) {\n'
            '            arr[i] = set;\n'
            '        }\n'
            '        has_set = false;\n'
            '        summ = len * set;\n'
            '        set = 0;\n'
            '    }\n'
            '    int partQuery(int l, int r) {\n'
            '        push();\n'
            '        int ans = 0;\n'
            '        for (int i = l; i <= r; i++) {\n'
            '            ans += arr[i];\n'
            '        }\n'
            '        return ans;\n'
            '    }\n'
            '    int fullQuery(int l, int r) {\n'
            '        if (has_set)\n'
            '            return len * set;\n'
            '        else\n'
            '            return summ;\n'
            '    }\n'
            '    void partSet(int l, int r, int val) {\n'
            '        push();\n'
            '        for (int i = l ; i < r; i++) {\n'
            '            summ -= arr[i];\n'
            '            arr[i] = val;\n'
            '            summ += val;\n'
            '        }\n'
            '    }\n'
            '    void fullSet(int val) {\n'
            '        has_set = true;\n'
            '        set = val;\n'
            '    }\n'
            '};\n'
            'struct SQRT {\n'
            '    vector<Block> bl;\n'
            '    int bSize, len;\n'
            '    SQRT(const vector<int>& a) {\n'
            '        int n = a.size();\n'
            '        bSize = (int)sqrt(n);\n'
            '        len = 0;\n'
            '        for (int i = 0; i < n; i++) {\n'
            '            int b = i / bSize;\n'
            '            if (b == len) {\n'
            '                bl.push_back(Block());\n'
            '                len++;\n'
            '            }\n'
            '            bl[b].arr.push_back(a[i]);\n'
            '        }\n'
            '        for (int i = 0; i < len; i++) {\n'
            '            bl[i].build();\n'
            '        }\n'
            '    }\n'
            '    int ask(int l, int r) {\n'
            '        int posl = l / bSize, posr = r / bSize;\n'
            '        int posinl = l % bSize, posinr = r % bSize;\n'
            '        if (posl == posr) {\n'
            '            return bl[posl].partQuery(posinl, posinr);\n'
            '        }\n'
            '        int ans = 0;\n'
            '        if (posinl != 0) {\n'
            '            ans += bl[posl].partQuery(posinl, bl[posl].len - 1);\n'
            '            posl++;\n'
            '        }\n'
            '        if (posinr != bl[posr].len - 1) {\n'
            '            ans += bl[posr].partQuery(0, posinr);\n'
            '            posr--;\n'
            '        }\n'
            '        for (int i = posl; i <= posr; i++) {\n'
            '            ans += bl[i].fullQuery();\n'
            '        }\n'
            '        return ans;\n'
            '    }\n'
            '    void change(int l, int r, int val) {\n'
            '        int posl = l / bSize, posr = r / bSize;\n'
            '        int posinl = l % bSize, posinr = r % bSize;\n'
            '        if (posl == posr) {\n'
            '            bl[posl].partSet(posinl, posinr, val);\n'
            '            return;\n'
            '        }\n'
            '        int ans = 0;\n'
            '        if (posinl != 0) {\n'
            '            bl[posl].partSet(posinl, bl[posl].len - 1, val);\n'
            '            posl++;\n'
            '        }\n'
            '        if (posinr != bl[posr].len - 1) {\n'
            '            bl[posr].partSet(0, posinr, val);\n'
            '            posr--;\n'
            '        }\n'
            '        for (int i = posl; i <= posr; i++) {\n'
            '            bl[i].fullSet(val);\n'
            '        }\n'
            '    }\n'
            '};\n'
            '\n'
            'Сколько на отрезке чисел из заданного диапазона + прибавление на отрезке:\n'
            'Для этого требуется хранить в каждом блоке отсортированный блок\n'
            'struct Block {\n'
            '    vector<int> arr, srt;\n'
            '    int add;\n'
            '    int len;\n'
            '    void build() {\n'
            '        len = arr.size();\n'
            '        add = 0;\n'
            '        srt = arr;\n'
            '        sort(srt.begin(), srt.end());\n'
            '    }\n'
            '    void push() {\n'
            '        for (int i = 0; i < len; i++) {\n'
            '            arr[i] += add;\n'
            '            srt[i] += add;\n'
            '        }\n'
            '        add = 0;\n'
            '    }\n'
            '    int partQuery(int l, int r, int numl, int numr) {\n'
            '        push();\n'
            '        int ans = 0;\n'
            '        for (int i = l; i <= r; i++) {\n'
            '            if (arr[i] >= numl && arr[i] <= numr) {\n'
            '                ans++;\n'
            '            }\n'
            '        }\n'
            '        return ans;\n'
            '    }\n'
            '    int fullQuery(int numl, int numr) {\n'
            '        return upper_bound(srt.begin(), srt.end(), numr) - lower_bound(srt.begin(), srt.end(), numl);\n'
            '    }\n'
            '    void partAdd(int l, int r, int val) {\n'
            '        push();\n'
            '        for (int i = l; i <= r; i++) {\n'
            '            arr[i] += val;\n'
            '        }\n'
            '        srt = arr;\n'
            '        sort(srt.begin(), srt.end());\n'
            '    }\n'
            '    void fullAdd(int val) {\n'
            '        add += val;\n'
            '    }\n'
            '};\n'
            'struct SQRT {\n'
            '    vector<Block> bl;\n'
            '    int bSize, len;\n'
            '    SQRT(const vector<int>& a) {\n'
            '        int n = a.size();\n'
            '        bSize = (int)sqrt(n);\n'
            '        len = 0;\n'
            '        for (int i = 0; i < n; i++) {\n'
            '            int b = i / bSize;\n'
            '            if (b == len) {\n'
            '                bl.push_back(Block());\n'
            '                len++;\n'
            '            }\n'
            '            bl[b].arr.push_back(a[i]);\n'
            '        }\n'
            '        for (int i = 0; i < len; i++) {\n'
            '            bl[i].build();\n'
            '        }\n'
            '    }\n'
            '    int ask(int l, int r, int numl, int numr) {\n'
            '        int posl = l / bSize, posr = r / bSize;\n'
            '        int posinl = l % bSize, posinr = r % bSize;\n'
            '        if (posl == posr) {\n'
            '            return bl[posl].partQuery(posinl, posinr, numl, numr);\n'
            '        }\n'
            '        int ans = 0;\n'
            '        if (posinl != 0) {\n'
            '            ans += bl[posl].partQuery(posinl, bl[posl].len - 1, numl, numr);\n'
            '            posl++;\n'
            '        }\n'
            '        if (posinr != bl[posr].len - 1) {\n'
            '            ans += bl[posr].partQuery(0, posinr, numl, numr);\n'
            '            posr--;\n'
            '        }\n'
            '        for (int i = posl; i <= posr; i++) {\n'
            '            ans += bl[i].fullQuery(numl, numr);\n'
            '        }\n'
            '        return ans;\n'
            '    }\n'
            '    void change(int l, int r, int val) {\n'
            '        int posl = l / bSize, posr = r / bSize;\n'
            '        int posinl = l % bSize, posinr = r % bSize;\n'
            '        if (posl == posr) {\n'
            '            bl[posl].partAdd(posinl, posinr, val);\n'
            '            return;\n'
            '        }\n'
            '        int ans = 0;\n'
            '        if (posinl != 0) {\n'
            '            bl[posl].partAdd(posinl, bl[posl].len - 1, val);\n'
            '            posl++;\n'
            '        }\n'
            '        if (posinr != bl[posr].len - 1) {\n'
            '            bl[posr].partAdd(0, posinr, val);\n'
            '            posr--;\n'
            '        }\n'
            '        for (int i = posl; i <= posr; i++) {\n'
            '            bl[i].fullAdd(val);\n'
            '        }\n'
            '    }\n'
            '};\n')


def Mo():
    return ('Алгоритм Мо\n'
            '\n'
            'Смысл алгоритма состоит в заранее отстортированном списке запросов (поэтому только offline)\n'
            'От одного запроса алгоритм перетекает к другому прибавлениями и удалениями элементов на концах текущего отрезка\n'
            'Массив разделён на блоки (корень из длины массива)\n'
            '\n'
            'Мо для суммы на отрезке чисел, которые встречаются хотя бы 3 раза:\n'
            'struct Magic {\n'
            '    unordered_map<int, int> cnt;\n'
            '    int summ;\n'
            '    Magic(): summ(0) {}\n'
            '    int f() {\n'
            '        return summ;\n'
            '    }\n'
            '    void add(int x) {\n'
            '        cnt[x]++;\n'
            '        if (cnt[x] == 3)\n'
            '            summ += x;\n'
            '    }\n'
            '    void del(int x) {\n'
            '        cnt[x]--;\n'
            '        if (cnt[x] == 2)\n'
            '            summ -= x;\n'
            '    }\n'
            '};\n'
            '\n'
            'struct query {\n'
            '    int l, r, num;\n'
            '    query() {}\n'
            '    query(int l, int r, int num): l(l), r(r), num(num) {}\n'
            '};\n'
            '\n'
            'int K;\n'
            '\n'
            'bool operator <(const query& a, const query& b) {\n'
            '    if (a.l / K != b.l / K)\n'
            '        return a.l / K < b.l / K;\n'
            '    if ((a.l / K) % 2 == 0)\n'
            '        return a.r < b.r;\n'
            '    return a.r > b.r;\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    fastIO;\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    vector<int> a(n);\n'
            '    cin >> a;\n'
            '    K = (int)sqrt(n);\n'
            '    int Q;\n'
            '    cin >> Q;\n'
            '    vector<query> qr;\n'
            '    for (int i = 0; i < Q; i++) {\n'
            '        int l, r;\n'
            '        cin >> l >> r;\n'
            '        qr.emplace_back(l - 1, r - 1, i);\n'
            '    }\n'
            '    sort(qr.begin(), qr.end());\n'
            '    Magic m;\n'
            '    int l = 0, r = -1;\n'
            '    vector<int> ans(Q);\n'
            '    for (auto& q: qr) {\n'
            '        while (r < q.r) {\n'
            '            m.add(a[r + 1]);\n'
            '            r++;\n'
            '        }\n'
            '        while (l > q.l) {\n'
            '            m.add(a[l - 1]);\n'
            '            l--;\n'
            '        }\n'
            '        while (r > q.r) {\n'
            '            m.del(a[r]);\n'
            '            r--;\n'
            '        }\n'
            '        while (l < q.l) {\n'
            '            m.del(a[l]);\n'
            '            l++;\n'
            '        }\n'
            '        ans[q.num] = m.f();\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Мо для кол-во различных чисел на отрезке:\n'
            'template <class T> void uniq(vector<T>& a) {sort(a.begin(), a.end()); a.resize(unique(a.begin(), a.end()) - a.begin());}\n'
            '\n'
            'int block_size;\n'
            '\n'
            'struct query {\n'
            '    int l, r, num;\n'
            '    query() {}\n'
            '    query(int l_, int r_, int num_) {\n'
            '        l = l_;\n'
            '        r = r_;\n'
            '        num = num_;\n'
            '    }\n'
            '};\n'
            '\n'
            'bool operator<(const query& a, const query& b) {\n'
            '    if (a.l / block_size != b.l / block_size) {\n'
            '        return a.l / block_size < b.l / block_size;\n'
            '    }\n'
            '    if ((a.l / block_size) % 2 == 0) {\n'
            '        return a.r < b.r;\n'
            '    }\n'
            '    return a.r > b.r;\n'
            '}\n'
            '\n'
            'struct Mo {\n'
            '    int cnt[300000];\n'
            '    int res;\n'
            '    Mo() {\n'
            '        fill(cnt, cnt + 300000, 0);\n'
            '        res = 0;\n'
            '    }\n'
            '    int get_res() {\n'
            '        return res;\n'
            '    }\n'
            '    void add(int x) {\n'
            '        cnt[x]++;\n'
            '        if (cnt[x] == 1) {\n'
            '            res++;\n'
            '        }\n'
            '    }\n'
            '    void del(int x) {\n'
            '        cnt[x]--;\n'
            '        if (cnt[x] == 0) {\n'
            '            res--;\n'
            '        }\n'
            '    }\n'
            '};\n'
            '\n'
            'signed main() {\n'
            '    fastIO;\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    vector<int> a(n), v(n);\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        cin >> a[i];\n'
            '        v[i] = a[i];\n'
            '    }\n'
            '    uniq(v);\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        a[i] = (int)(lower_bound(all(v), a[i]) - v.begin());\n'
            '    }\n'
            '    int q;\n'
            '    cin >> q;\n'
            '    vector<int> ans(q);\n'
            '    vector<query> Q(q);\n'
            '    for (int i = 0; i < q; i++) {\n'
            '        int l, r;\n'
            '        cin >> l >> r;\n'
            '        Q[i] = query(l - 1, r - 1, i);\n'
            '    }\n'
            '    block_size = (int)sqrt(n);\n'
            '    Mo m;\n'
            '    stable_sort(all(Q));\n'
            '    int l = 0, r = -1;\n'
            '    for (int i = 0; i < q; i++) {\n'
            '        int to_l = Q[i].l;\n'
            '        int to_r = Q[i].r;\n'
            '        while (r < to_r) {\n'
            '            m.add(a[r + 1]);\n'
            '            r++;\n'
            '        }\n'
            '        while (l > to_l) {\n'
            '            m.add(a[l - 1]);\n'
            '            l--;\n'
            '        }\n'
            '        while (r > to_r) {\n'
            '            m.del(a[r]);\n'
            '            r--;\n'
            '        }\n'
            '        while (l < to_l) {\n'
            '            m.del(a[l]);\n'
            '            l++;\n'
            '        }\n'
            '        ans[Q[i].num] = m.get_res();\n'
            '    }\n'
            '    for (int& i: ans) {\n'
            '        cout << i << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n')


def Huffman():
    return ('Кодирование Хаффмана\n'
            '\n'
            'Код Хаффмана - алгоритм оптимального префиксного кодирования\n'
            '\n'
            'struct Node {\n'
            '    Node *l, *r;\n'
            '    bool is_leaf;\n'
            '    char c;\n'
            '    Node(): l(nullptr), r(nullptr), is_leaf(false) {}\n'
            '};\n'
            '\n'
            'void dfs(Node* v, unordered_map<char, string>& codes, string cur_code = "") {\n'
            '    if (v->is_leaf) {\n'
            '        codes[v->c] = cur_code;\n'
            '        return;\n'
            '    }\n'
            '    dfs(v->l, codes, cur_code + \'0\');\n'
            '    dfs(v->r, codes, cur_code + \'1\');\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    vector<int> freq(n);\n'
            '    vector<char> let(n);\n'
            '    cin >> freq;\n'
            '    cin >> let;\n'
            '    set<pair<int, Node*>> s;\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        Node* v = new Node();\n'
            '        v->is_leaf = true;\n'
            '        v->c = let[i];\n'
            '        s.insert({freq[i], v});\n'
            '    }\n'
            '    while (s.size() > 1) {\n'
            '        auto fi = *s.begin();\n'
            '        s.erase(s.begin());\n'
            '        auto se = *s.begin();\n'
            '        s.erase(s.begin());\n'
            '        Node* cur = new Node();\n'
            '        cur->l = fi.second;\n'
            '        cur->r = se.second;\n'
            '        s.insert({fi.first + se.first, cur});\n'
            '    }\n'
            '    Node* tree = s.begin()->second;\n'
            '    unordered_map<char, string> codes;\n'
            '    dfs(tree, codes);\n'
            '    for (auto& i: codes) {\n'
            '        cout << i.first << \' \' << i.second << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n')


def graphs2():
    return ('Графы. Часть 2\n'
            '\n'
            'АЛГОРИТМ ФОРДА-БЕЛЛМАНА\n'
            'Алгоритм Форда-Беллмана инщет расстояния от одной вершины (в примере она равняется 0) до остальных\n'
            'Рёбра могут имет отрицательный вес\n'
            'const int INF = 1e9;\n'
            'struct Edge {\n'
            '    int v, u, w;\n'
            '    Edge() {}\n'
            '    Edge(int v_, int u_, int w_): v(v_), u(u_), w(w_) {}\n'
            '};\n'
            'signed main() {\n'
            '    int n, m;\n'
            '    cin >> n >> m;\n'
            '    vector<Edge> edges;\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int v, u, w;\n'
            '        cin >> v >> u >> w;\n'
            '        u--;\n'
            '        v--;\n'
            '        edges.push_back(Edge(v, u, w));\n'
            '    }\n'
            '    vector<int> d(n, INF);\n'
            '    d[0] = 0;\n'
            '    for (int i = 0; i < n - 1; i++) {\n'
            '        for (auto &e: edges) {\n'
            '            if (d[e.v] != INF && d[e.u] > d[e.v] + e.w) {\n'
            '                d[e.u] = d[e.v] + e.w;\n'
            '            }\n'
            '        }\n'
            '    }\n'
            '    // output\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Алгоритмом Форда-Беллмана можно искать отрицательный цикл\n'
            'Для этого нужно повторить код. Если расстояние до каких-то вершин уменьшилось, то цикл есть\n'
            'Восстановить цикл можно с помощью предков\n'
            '(В примере граф вводится матрицей смежности, значение NO_ - отсутствие ребра между вершинами)\n'
            'const int INF = 1e9;\n'
            'const int NO_ = 1e5;\n'
            '\n'
            'struct Edge {\n'
            '    int v, u, w;\n'
            '    Edge() {}\n'
            '    Edge(int v_, int u_, int w_): v(v_), u(u_), w(w_) {}\n'
            '};\n'
            '\n'
            'signed main() {\n'
            '    fastIO;\n'
            '    // fileIO;\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    vector<Edge> edges;\n'
            '    bool self = false;\n'
            '    int ans_for_self = 0;\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        for (int j = 0; j < n; j++) {\n'
            '            int x;\n'
            '            cin >> x;\n'
            '            if (i == j && x < 0) {\n'
            '                self = true;\n'
            '                ans_for_self = i;\n'
            '            }\n'
            '            if (x != NO_) {\n'
            '                edges.push_back(Edge(i, j, x));\n'
            '            }\n'
            '        }\n'
            '    }\n'
            '    if (self) {\n'
            '        Yes;\n'
            '        cout << "2\\n";\n'
            '        cout << ans_for_self + 1 << \' \' << ans_for_self + 1 << el;\n'
            '        return 0;\n'
            '    }\n'
            '    vector<int> d(n, INF);\n'
            '    vector<int> p(n, -1);\n'
            '    d[0] = 0;\n'
            '    for (int i = 0; i < n - 1; i++) {\n'
            '        for (auto &e: edges) {\n'
            '            if (d[e.v] != NO_ && d[e.u] > d[e.v] + e.w) {\n'
            '                d[e.u] = d[e.v] + e.w;\n'
            '                p[e.u] = e.v;\n'
            '            }\n'
            '        }\n'
            '    }\n'
            '    vector<int> old = d;\n'
            '    for (int i = 0; i < n - 1; i++) {\n'
            '        for (auto &e: edges) {\n'
            '            if (d[e.v] != NO_ && d[e.u] > d[e.v] + e.w) {\n'
            '                d[e.u] = d[e.v] + e.w;\n'
            '                p[e.u] = e.v;\n'
            '            }\n'
            '        }\n'
            '    }\n'
            '    if (old == d) {\n'
            '        No;\n'
            '        return 0;\n'
            '    }\n'
            '    Yes;\n'
            '    int cur = -1;\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        if (old[i] != d[i]) {\n'
            '            cur = i;\n'
            '            break;\n'
            '        }\n'
            '    }\n'
            '    vector<int> pos(n, -1);\n'
            '    vector<int> way;\n'
            '    vector<int> cycle;\n'
            '    while (true) {\n'
            '        if (pos[cur] != -1) {\n'
            '            way.push_back(cur);\n'
            '            for (int i = way.size() - 1; i >= pos[cur]; i--) {\n'
            '                cycle.push_back(way[i]);\n'
            '            }\n'
            '            break;\n'
            '        }\n'
            '        pos[cur] = way.size();\n'
            '        way.push_back(cur);\n'
            '        cur = p[cur];\n'
            '    }\n'
            '    cout << cycle.size() << el;\n'
            '    for (int i : cycle) {\n'
            '        cout << i + 1 << \' \';\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Можно проверить, определено ли значение кратчайшего пути для вершины\n'
            'Для этого нужно добавить после алгоритма:\n'
            'int finish;\n'
            'cin >> finish;\n'
            'bool reach = false;\n'
            'vector<bool> used(n);\n'
            'dfs(finish, used, rg, d, old, reach);\n'
            'if (reach) {\n'
            '    cout << "-INF\\n";\n'
            '}\n'
            '\n'
            'rg - перевёрнутый граф (можно создать в процессе ввода)\n'
            'Функция dfs:\n'
            'void dfs(int v, vector<bool>& used, const vector<vector<int>>& g, const vector<int>& d, const vector<int>& old, bool& reach) {\n'
            '    if (d[v] != old[v]) {\n'
            '        reach = true;\n'
            '    }\n'
            '    used[v] = true;\n'
            '    for (int u: g[v]) {\n'
            '        dfs(u, used, g, d, old, reach);\n'
            '    }\n'
            '}\n')


def trie():
    return ('Бор (trie)\n'
            '\n'
            'Бор - это префиксное дерево, хранящее все префиксы нескольких слов\n'
            'Можно добавлять, удалять и ускать строки\n'
            '\n'
            'Код:\n'
            'struct Node {\n'
            '    int cnt;\n'
            '    int sum;\n'
            '    vector<Node*> kids;\n'
            '    Node() {\n'
            '        cnt = 0;\n'
            '        sum = 0;\n'
            '        kids.resize(26, nullptr);\n'
            '    }\n'
            '};\n'
            'void add(Node* v, const string& s, int pos) {\n'
            '    if (pos == s.size()) {\n'
            '        v->cnt++;\n'
            '        v->sum++;\n'
            '        return;\n'
            '    }\n'
            '    v->sum++;\n'
            '    int kid = s[pos] - \'a\';\n'
            '    if (v->kids[kid] == nullptr) {\n'
            '        v->kids[kid] = new Node();\n'
            '    }\n'
            '    add(v->kids[kid], s, pos + 1);\n'
            '}\n'
            'bool del(Node* v, const string& s, int pos) {\n'
            '    if (pos == s.size()) {\n'
            '        if (v->cnt == 0) {\n'
            '            return false;\n'
            '        }\n'
            '        v->cnt--;\n'
            '        v->sum--;\n'
            '        return true;\n'
            '    }\n'
            '    int kid = s[pos] - \'a\';\n'
            '    if (v->kids[kid] == nullptr) {\n'
            '        return false;\n'
            '    }\n'
            '    bool res = del(v->kids[kid], s, pos + 1);\n'
            '    if (res) {\n'
            '         v->sum--;\n'
            '    }\n'
            '    if (v->kids[kid]->sum == 0) {\n'
            '        delete v->kids[kid];\n'
            '        v->kids[kid] = nullptr;\n'
            '    }\n'
            '    return res;\n'
            '}\n'
            'bool find(Node* v, const string& s, int pos) {\n'
            '    if (pos == s.size()) {\n'
            '        return v->cnt > 0;\n'
            '    }\n'
            '    int kid = s[pos] - \'a\';\n'
            '    if (v->kids[kid] == nullptr) {\n'
            '        return false;\n'
            '    }\n'
            '    return find(v->kids[kid], s, pos + 1);\n'
            '}\n'
            'signed main() {\n'
            '    Node* root = new Node();\n'
            '    string s;\n'
            '    cin >> s;\n'
            '    add(root, s, 0);\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'cnt - кол-во строк, заканцивающихся в вершине\n'
            'sum - размер поддерева вершины\n'
            '\n'
            'Существует битовый бор (вместо символов биты чисел)\n'
            'Он позволяет искать mex множества, осуществлять операции xor\n'
            'Для битового бора необходимо, чтобы все числа имели одинаковую длину (нужно дополнять их вещущими нулями до определённой длины)\n'
            'Битовым бором можно сравнивать числа (если где-то первое число пошло налево, а второе направо, то первое число меньше)\n'
            'Можно искать кол-во чисел меньше k. Для этого нужно посчитать сумму поддеревьев левых переходов (число k идёт направо => прибавим к ответу сумму левого перехода)\n'
            '\n'
            'Бором можно посчитать кол-во различных подстрок строки\n'
            'Для этого нужно положить в бор все суффиксы строки\n'
            'Ответ - кол-во вершин в боре\n')


def geometry():
    return ('Геометрия\n'
            '\n'
            'ТОЧКИ, ВЕКТОРА, ОТРЕЗКИ\n'
            'Точку проще всего хранить в структуре\n'
            'struct Point {\n'
            '    int x, y;\n'
            '    Point() {}\n'
            '    Point(int x_, int y_): x(x_), y(y_) {}\n'
            '};\n'
            '\n'
            'Вектор - это сдвиг по двум координатам, поэтому его можно храанить в той же структуре\n'
            'Для того, чтобы создать вектор, можно переопределить оператор -\n'
            'Point operator-(const Point& a, const Point& b) {\n'
            '    return Point(a.x - b.x, a.y - b.y);\n'
            '}\n'
            '\n'
            'Скалярное произведение\n'
            'Скалярное произведение: a.x * b.x + a.y * b.y = |a| * |b| * cos(a^b)\n'
            'int dP(const Point& a, const Point& b) { // скалярное\n'
            '    return a.x * b.x + a.y * b.y;\n'
            '}\n'
            '\n'
            'Векторное произведение\n'
            'Векторное произведение: a.x * b.y - a.y * b.x = |a| * |b| * sin(a^b)\n'
            'int cP(const Point& a, const Point& b) { // векторное\n'
            '    return a.x * b.y - a.y * b.x;\n'
            '}\n'
            '\n'
            'Нахождение угла:\n'
            'double angle(const Point& a, const Point& b) {\n'
            '    return atan2(cP(a, b), dP(a, b));\n'
            '}\n'
            '\n'
            'Сравнивать double - плохо, поэтому надо использовать функцию сравнения\n'
            'const double eps = 1e-6;\n'
            'bool equal(double a, double b) {\n'
            '    return abs(a - b) < eps;\n'
            '}\n'
            '\n'
            'Проверка, лежит ли точка внтури угла\n'
            'bool pointInAngle(const Point& a, const Point& o, const Point& b, const Point& p) {\n'
            '    double aop = abs(angle(a - o, p - o));\n'
            '    double pob = abs(angle(p - o, b - o));\n'
            '    double aob = abs(angle(a - o, b - o));\n'
            '    return equal(aop + pob, aob) || (o.x == p.x && o.y == p.y);\n'
            '}\n'
            '\n'
            'Длина вектора\n'
            'double len(const Point& a) {\n'
            '    return hypot(a.x, a.y);\n'
            '}\n'
            '\n'
            'Проверка, перескаются ли два отрезка\n'
            'int dP(const Point& a, const Point& b) { // скалярное\n'
            '    return a.x * b.x + a.y * b.y;\n'
            '}\n'
            'int cP(const Point& a, const Point& b) { // векторное\n'
            '    return a.x * b.y - a.y * b.x;\n'
            '}\n'
            'bool inter(int a, int b, int c, int d) {\n'
            '    if (a > b) {\n'
            '        swap(a, b);\n'
            '    }\n'
            '    if (c > d) {\n'
            '        swap(c, d);\n'
            '    }\n'
            '    return max(a, c) <= min(b, d);\n'
            '}\n'
            'istream& operator>>(istream& in, Point& p) {\n'
            '    in >> p.x >> p.y;\n'
            '    return in;\n'
            '}\n'
            'signed main() {\n'
            '    Point a, b, c, d;\n'
            '    cin >> a >> b >> c >> d;\n'
            '    if (cP(b - a, c - a) * cP(b - a, d - a) <= 0 && cP(d - c, a - c) * cP(d - c, b - c) <= 0 && inter(a.x, b.x, c.x, d.x) && inter(a.y, b.y, c.y, d.y)) {\n'
            '        Yes;\n'
            '    }\n'
            '    else {\n'
            '        No;\n'
            '    }\n'
            '    return 0;\n'
            '}\n')


def convex_hull():
    # TODO: write convex_hull
    return


def treap():
    return ('Декартово дерево (treap, cartesian tree, дуча, дерамида, курево, пиво...)\n'
            '\n'
            'ДД - сбалансированное дерево поиска\n'
            'В каждой вершине ДД хранятся значения key и prior\n'
            'key - ключи (значения, по которым строится ДД)\n'
            'prior - приорететы (значения, выбираемые случайно)\n'
            'По значениям key ДД - бинарное дерево поиска (l_key < m_key < r_key)\n'
            'По значениям proir ДД - бинарная куча (l_prior < m_prior > r_prior)\n'
            '\n'
            'ДД будет строится на указателях, поэтому нужна структура вершины Node\n'
            '\n'
            'ДД может выполнять операции:\n'
            '* find(x)   - проверка, есть ли x в дереве\n'
            '* add(x)    - добавление элемента x в дерево\n'
            '* remove(x) - удаление элемента x из дерева\n'
            '* next(x)   - наименьшей элемент, который >x\n'
            '* prev(x)   - наибольший элемент, который <x\n'
            '* kth(k)    - k-ый по величине элемент (для этого потребуется храение размеров поддервьев - см. далее)\n'
            '... (другие операции, например, RSQ/RMQ)\n'
            '\n'
            'Но все операции будут основываться на двух: merge и split\n'
            'merge сливает два ДД в одно (предполагается, что их можно слить - есть такой ключ, что левое дерево меньше этого ключа, а правое больше)\n'
            'split(key) делит ДД на два по ключу\n'
            '\n'
            'Реализация ДД (явный ключ):\n'
            'static random_device rd;\n'
            'static mt19937 rng{rd()};\n'
            '\n'
            'int get_rand() {\n'
            '    static uniform_int_distribution<int> uid(0, 2e9 + 7);\n'
            '    return uid(rng);\n'
            '}\n'
            '\n'
            'struct Node {\n'
            '    int key;\n'
            '    int prior;\n'
            '    Node* l;\n'
            '    Node* r;\n'
            '    Node() {\n'
            '        l = nullptr;\n'
            '        r = nullptr;\n'
            '    }\n'
            '    Node(int key_) {\n'
            '        key = key_;\n'
            '        prior = get_rand();\n'
            '        l = nullptr;\n'
            '        r = nullptr;\n'
            '    }\n'
            '};\n'
            '\n'
            'pair<Node*, Node*> split(Node* v, int x) {\n'
            '    if (v == nullptr) {\n'
            '        return {nullptr, nullptr};\n'
            '    }\n'
            '    if (v->key < x) {\n'
            '        pair<Node*, Node*> p = split(v->r, x);\n'
            '        v->r = p.first;\n'
            '        return {v, p.second};\n'
            '    }\n'
            '    pair<Node*, Node*> p = split(v->l, x);\n'
            '    v->l = p.second;\n'
            '    return {p.first, v};\n'
            '}\n'
            '\n'
            'Node* merge(Node* v1, Node* v2) {\n'
            '    if (v1 == nullptr) {\n'
            '        return v2;\n'
            '    }\n'
            '    if (v2 == nullptr) {\n'
            '        return v1;\n'
            '    }\n'
            '    if (v1->prior > v2->prior) {\n'
            '        v1->r = merge(v1->r, v2);\n'
            '        // update(v1);\n'
            '        return v1;\n'
            '    }\n'
            '    v2->l = merge(v1, v2->l);\n'
            '    // update(v2);\n'
            '    return v2;\n'
            '}\n'
            '\n'
            'Node* find(Node* v, int x) {\n'
            '    if (v == nullptr || v->key == x) {\n'
            '        return v;\n'
            '    }\n'
            '    if (x < v->key) {\n'
            '        return find(v->l, x);\n'
            '    }\n'
            '    return find(v->r, x);\n'
            '}\n'
            '\n'
            'Node* add(Node* v, Node* x) {\n'
            '    if (v == nullptr) {\n'
            '        v = x;\n'
            '        // update(v);\n'
            '        return v;\n'
            '    }\n'
            '    if (x->prior > v->prior) {\n'
            '        pair<Node*, Node*> p = split(v, x->key);\n'
            '        x->l = p.first;\n'
            '        x->r = p.second;\n'
            '        // update(x);\n'
            '        return x;\n'
            '    }\n'
            '    if (x->key < v->key) {\n'
            '        v->l = add(v->l, x);\n'
            '    }\n'
            '    else {\n'
            '        v->r = add(v->r, x);\n'
            '    }\n'
            '    // update(v);\n'
            '    return v;\n'
            '}\n'
            '\n'
            'Node* remove(Node* v, int x) {\n'
            '    if (v == nullptr) {\n'
            '        return v;\n'
            '    }\n'
            '    if (v->key == x) {\n'
            '        return merge(v->l, v->r);\n'
            '    }\n'
            '    if (x < v->key) {\n'
            '        v->l = remove(v->l, x);\n'
            '    }\n'
            '    else {\n'
            '        v->r = remove(v->r, x);\n'
            '    }\n'
            '    // update(v);\n'
            '    return v;\n'
            '}\n'
            '\n'
            'Node* prev(Node* v, int x) {\n'
            '    Node* cur = v;\n'
            '    Node* succ = nullptr;\n'
            '    while (cur != nullptr) {\n'
            '        if (cur->key < x) {\n'
            '            succ = cur;\n'
            '            cur = cur->r;\n'
            '        }\n'
            '        else {\n'
            '            cur = cur->l;\n'
            '        }\n'
            '    }\n'
            '    return succ;\n'
            '}\n'
            '\n'
            'Node* next(Node* v, int x) {\n'
            '    Node* cur = v;\n'
            '    Node* succ = nullptr;\n'
            '    while (cur != nullptr) {\n'
            '        if (cur->key > x) {\n'
            '            succ = cur;\n'
            '            cur = cur->l;\n'
            '        }\n'
            '        else {\n'
            '            cur = cur->r;\n'
            '        }\n'
            '    }\n'
            '    return succ;\n'
            '}\n'
            '\n'
            'Строить ДД можно просто последовательным добавлением элементов\n'
            'Но если все ключы известны в начале, то можно построить ДД за O(n)\n'
            'Для этого можно отсортировать все ключи. Тогда следующий элемент будет либо добавлен в конец самой правой ветви, либо разделит её на две части (это делается при помощи stack)\n'
            'void build(vector<Node*>& a) {\n'
            '    Node* root = a[0];\n'
            '    int n = a.size();\n'
            '    stack<Node*> s;\n'
            '    s.push(root);\n'
            '    for (int i = 1; i < n; i++) {\n'
            '        Node* v = a[i];\n'
            '        while (!s.empty() && s.top()->prior > v->prior) {\n'
            '            s.pop();\n'
            '        }\n'
            '        if (s.empty()) {\n'
            '            v->l = root;\n'
            '            root = v;\n'
            '            s.push(root);\n'
            '        }\n'
            '        else {\n'
            '            Node* top = s.top();\n'
            '            v->l = top->r;\n'
            '            top->r = v;\n'
            '            s.push(top);\n'
            '            s.push(v);\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'В основном, запросы выполняются по следующему принципу:\n'
            '1. Разбить дерево по правой границе\n'
            '2. Разбить первую часть по левой границе запроса\n'
            '3. Найти ответ на средней части\n'
            '4. Слить всё обратно\n'
            '\n'
            'Пример для RSQ(x, y) - сумма чисел в диапазоне от x до y (конечно, на отсортированном массиве):\n'
            'll RSQ(Node* v, int l, int r) {\n'
            '    pair<Node*, Node*> p1 = split(v, l);\n'
            '    pair<Node*, Node*> p2 = split(p1.second, r + 1);\n'
            '    ll res = get_sum(p2.first);\n'
            '    p1.second = merge(p2.first, p2.second);\n'
            '    merge(p1.first, p1.second);\n'
            '    return res;\n'
            '}\n'
            '\n'
            'Хранение размеров поддеревьев добавляет возможность поиска k по величине элемента (и множество возможностей для ДД по неявному ключу)\n'
            'Для этого нужны функции update и get_sz\n'
            'update нужно вызывать после каждого изменения вершины\n'
            'int get_sz(Node* v) {\n'
            '    if (v == nullptr) {\n'
            '        return 0;\n'
            '    }\n'
            '    return v->sz;\n'
            '}\n'
            '\n'
            'void update(Node* v) {\n'
            '    if (v != nullptr) {\n'
            '        v->sz = get_sz(v->l) + get_sz(v->r) + 1;\n'
            '    }\n'
            '}\n'
            '\n'
            '// 1-индексация\n'
            'Node* kth(Node* v, int k) {\n'
            '    if (v == nullptr) {\n'
            '        return nullptr;\n'
            '    }\n'
            '    if (get_sz(v->l) + 1 == k) {\n'
            '        return v;\n'
            '    }\n'
            '    if (get_sz(v->l) + 1 > k) {\n'
            '        return kth(v->l, k);\n'
            '    }\n'
            '    return kth(v->r, k - get_sz(v->l) - 1);\n'
            '}\n'
            '\n'
            'Главное: если мы идём в левого сына, k остаётся прежним\n'
            '         если мы идём в правого сына, то из k вычитается get_sz(v->l) + 1 (величина левого сына + текущая вершина)\n'
            '\n'
            'ДД по неявному ключу см. в implicit_treap\n')


def implicit_treap():
    return ('Декартово дерево по неявному ключу\n'
            '\n'
            'Смысл ДД по неявному ключу - отсутствие ключей в вершинах\n'
            'Для получения значений используются размеры поддеревьев\n'
            '\n'
            'Такая структура позволяет хранить любой массив (не только отсортированный, как ДД по явному ключу)\n'
            '\n'
            'split теперь будет отрезать первые k элементов\n'
            'merge не изменится, т.к. в его коде никак не участвуют ключи\n'
            '\n'
            'Теперь можно считать все функции, которые считает ДО (RSQ, RMQ...)\n'
            'Считать можно двумя способами:\n'
            '1. Разрезать, найти, склеить - простой способ, но может работать дольше, чем 2 способ\n'
            '2. Запрос ДО (можно написать такой же запрос, как для ДО)\n'
            'Отличие от ДО во втором способе - значения в ДД не только в листьях, но и в узлах, поэтому нужно добавлять значение в узле в ответ\n'
            '\n'
            'Код предполагает, что для 1 способа в функцию передаются исходные значения l и r ([l, r], l и r в 1-индексации)\n'
            'Во втором способе предполагается, что в функцию передаётся полуинтервал ([l, r), l и r в 0-индексации)\n'
            '\n'
            'Для примера реализация RMQ с добавлением элемента в массив после элемента k:\n'
            'static random_device rd;\n'
            'static mt19937 rng{rd()};\n'
            '\n'
            'int get_rand() {\n'
            '    static uniform_int_distribution<int> uid(0, 2e9 + 7);\n'
            '    return uid(rng);\n'
            '}\n'
            '\n'
            'struct Node {\n'
            '    int val;\n'
            '    int prior;\n'
            '    int sz;\n'
            '    int min;\n'
            '    Node* l;\n'
            '    Node* r;\n'
            '    Node() {\n'
            '        sz = 0;\n'
            '        min = 2e9;\n'
            '        l = nullptr;\n'
            '        r = nullptr;\n'
            '    }\n'
            '    Node(int val_) {\n'
            '        val = val_;\n'
            '        prior = get_rand();\n'
            '        sz = 1;\n'
            '        min = val_;\n'
            '        l = nullptr;\n'
            '        r = nullptr;\n'
            '    }\n'
            '};\n'
            '\n'
            'int get_sz(Node* v) {\n'
            '    if (v == nullptr) {\n'
            '        return 0;\n'
            '    }\n'
            '    return v->sz;\n'
            '}\n'
            '\n'
            'int get_min(Node* v) {\n'
            '    if (v == nullptr) {\n'
            '        return 2e9;\n'
            '    }\n'
            '    return v->min;\n'
            '}\n'
            '\n'
            'void update(Node* v) {\n'
            '    if (v != nullptr) {\n'
            '        v->sz = get_sz(v->l) + get_sz(v->r) + 1;\n'
            '        v->min = min({v->val, get_min(v->l), get_min(v->r)});\n'
            '    }\n'
            '}\n'
            '\n'
            'pair<Node*, Node*> split(Node* v, int k) {\n'
            '    if (v == nullptr) {\n'
            '        return {nullptr, nullptr};\n'
            '    }\n'
            '    if (k <= get_sz(v->l)) {\n'
            '        pair<Node*, Node*> p = split(v->l, k);\n'
            '        v->l = p.second;\n'
            '        update(v);\n'
            '        return {p.first, v};\n'
            '    }\n'
            '    pair<Node*, Node*> p = split(v->r, k - get_sz(v->l) - 1);\n'
            '    v->r = p.first;\n'
            '    update(v);\n'
            '    return {v, p.second};\n'
            '}\n'
            '\n'
            '// merge остаётся таким же\n'
            'Node* merge(Node* v1, Node* v2) {\n'
            '    if (v1 == nullptr) {\n'
            '        return v2;\n'
            '    }\n'
            '    if (v2 == nullptr) {\n'
            '        return v1;\n'
            '    }\n'
            '    if (v1->prior > v2->prior) {\n'
            '        v1->r = merge(v1->r, v2);\n'
            '        update(v1);\n'
            '        return v1;\n'
            '    }\n'
            '    v2->l = merge(v1, v2->l);\n'
            '    update(v2);\n'
            '    return v2;\n'
            '}\n'
            '\n'
            '// медленно\n'
            'int RMQ(Node* v, int l, int r) {\n'
            '    pair<Node*, Node*> p1 = split(v, r);\n'
            '    pair<Node*, Node*> p2 = split(p1.first, l - 1);\n'
            '    int res = p2.second->min;\n'
            '    p1.first = merge(p2.first, p2.second);\n'
            '    merge(p1.first, p1.second);\n'
            '    return res;\n'
            '}\n'
            '\n'
            '// быстрее\n'
            'int RMQ2(Node* v, int l, int r, int askl, int askr) {\n'
            '    if (v == nullptr) {\n'
            '        return 2e9;\n'
            '    }\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return 2e9;\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        return v->min;\n'
            '    }\n'
            '    int k = v->sz;\n'
            '    int l_sz = get_sz(v->l);\n'
            '    int one = (l_sz + l >= askl && l + l_sz < askr ? v->val : 2e9);\n'
            '    return min({RMQ2(v->l, l, l + l_sz, askl, askr), RMQ2(v->r, l + l_sz + 1, r, askl, askr), one});\n'
            '}\n'
            '\n'
            'Node* add(Node* v, Node* x, int k) {\n'
            '    if (v == nullptr) {\n'
            '        v = x;\n'
            '        update(v);\n'
            '        return v;\n'
            '    }\n'
            '    if (x->prior > v->prior) {\n'
            '        pair<Node*, Node*> p = split(v, k);\n'
            '        x->l = p.first;\n'
            '        x->r = p.second;\n'
            '        update(x);\n'
            '        return x;\n'
            '    }\n'
            '    if (get_sz(v->l) < k) {\n'
            '        v->r = add(v->r, x, k - get_sz(v->l) - 1);\n'
            '    }\n'
            '    else {\n'
            '        v->l = add(v->l, x, k);\n'
            '    }\n'
            '    update(v);\n'
            '    return v;\n'
            '}\n'
            '\n'
            'ДД поддерживает и отложенные операции (массовые операции)\n'
            'Для примера код задачи о перевороте отрезка и поиска минимума на отрезке:\n'
            'static random_device rd;\n'
            'static mt19937 rng{rd()};\n'
            '\n'
            'int get_rand() {\n'
            '    static uniform_int_distribution<int> uid(0, 2e9 + 7);\n'
            '    return uid(rng);\n'
            '}\n'
            '\n'
            'struct Node {\n'
            '    int val;\n'
            '    int min;\n'
            '    bool rev;\n'
            '    int prior;\n'
            '    int sz;\n'
            '    Node* l;\n'
            '    Node* r;\n'
            '    Node(int val_) {\n'
            '        val = val_;\n'
            '        prior = get_rand();\n'
            '        sz = 1;\n'
            '        rev = false;\n'
            '        min = val_;\n'
            '        l = nullptr;\n'
            '        r = nullptr;\n'
            '    }\n'
            '};\n'
            '\n'
            'int get_sz(Node* v) {\n'
            '    if (v == nullptr) {\n'
            '        return 0;\n'
            '    }\n'
            '    return v->sz;\n'
            '}\n'
            '\n'
            'int get_min(Node* v) {\n'
            '    if (v == nullptr) {\n'
            '        return 2e9;\n'
            '    }\n'
            '    return v->min;\n'
            '}\n'
            '\n'
            'void update(Node* v) {\n'
            '    if (v != nullptr) {\n'
            '        v->sz = get_sz(v->l) + get_sz(v->r) + 1;\n'
            '        v->min = min({v->val, get_min(v->l), get_min(v->r)});\n'
            '    }\n'
            '}\n'
            '\n'
            'void push(Node* v) {\n'
            '    if (v == nullptr || !v->rev) {\n'
            '        return;\n'
            '    }\n'
            '    swap(v->l, v->r);\n'
            '    v->rev = false;\n'
            '    if (v->l != nullptr) {\n'
            '        v->l->rev ^= true;\n'
            '    }\n'
            '    if (v->r != nullptr) {\n'
            '        v->r->rev ^= true;\n'
            '    }\n'
            '}\n'
            '\n'
            'pair<Node*, Node*> split(Node* v, int k) {\n'
            '    push(v);\n'
            '    if (v == nullptr) {\n'
            '        return {nullptr, nullptr};\n'
            '    }\n'
            '    if (get_sz(v->l) < k) {\n'
            '        pair<Node*, Node*> p = split(v->r, k - get_sz(v->l) - 1);\n'
            '        v->r = p.first;\n'
            '        update(v);\n'
            '        return {v, p.second};\n'
            '    }\n'
            '    pair<Node*, Node*> p = split(v->l, k);\n'
            '    v->l = p.second;\n'
            '    update(v);\n'
            '    return {p.first, v};\n'
            '}\n'
            '\n'
            'Node* merge(Node* v1, Node* v2) {\n'
            '    push(v1);\n'
            '    push(v2);\n'
            '    if (v1 == nullptr) {\n'
            '        return v2;\n'
            '    }\n'
            '    if (v2 == nullptr) {\n'
            '        return v1;\n'
            '    }\n'
            '    if (v1->prior > v2->prior) {\n'
            '        v1->r = merge(v1->r, v2);\n'
            '        update(v1);\n'
            '        return v1;\n'
            '    }\n'
            '    v2->l = merge(v1, v2->l);\n'
            '    update(v2);\n'
            '    return v2;\n'
            '}\n'
            '\n'
            'Node* add(Node* v, Node* x, int k) {\n'
            '    if (v == nullptr) {\n'
            '        v = x;\n'
            '        update(v);\n'
            '        return v;\n'
            '    }\n'
            '    if (x->prior > v->prior) {\n'
            '        pair<Node*, Node*> p = split(v, k);\n'
            '        x->l = p.first;\n'
            '        x->r = p.second;\n'
            '        update(x);\n'
            '        return x;\n'
            '    }\n'
            '    if (get_sz(v->l) < k) {\n'
            '        v->r = add(v->r, x, k - get_sz(v->l) - 1);\n'
            '    }\n'
            '    else {\n'
            '        v->l = add(v->l, x, k);\n'
            '    }\n'
            '    update(v);\n'
            '    return v;\n'
            '}\n'
            '\n'
            'void reverse(Node* v, int l, int r) {\n'
            '    pair<Node*, Node*> p1 = split(v, r);\n'
            '    pair<Node*, Node*> p2 = split(p1.first, l - 1);\n'
            '    p2.second->rev ^= true;\n'
            '    p1.first = merge(p2.first, p2.second);\n'
            '    merge(p1.first, p1.second);\n'
            '}\n'
            '\n'
            'int RMQ(Node* v, int l, int r) {\n'
            '    pair<Node*, Node*> p1 = split(v, r);\n'
            '    pair<Node*, Node*> p2 = split(p1.first, l - 1);\n'
            '    int res = p2.second->min;\n'
            '    p1.first = merge(p2.first, p2.second);\n'
            '    merge(p1.first, p1.second);\n'
            '    return res;\n'
            '}\n')


def mergesort_tree():
    return ('Дерево mergesort\n'
            '\n'
            'Дерево mergesort - ДО, в каждой вершине которого хранится отсортированный подмассив\n'
            '\n'
            'Такая структура позволяет решать задачу о нахождении кол-во числе в диапазоне [x, y] на отрезке [l, r]\n'
            'Если есть отсортированный массив, то такая задача решается двумя бинпоисками\n'
            '\n'
            'Вершины дерева сливаются, как в сортировке слиянием\n'
            '\n'
            'Код:\n'
            'struct Node {\n'
            '    vector<int> a;\n'
            '    Node() {}\n'
            '};\n'
            '\n'
            'vector<Node> t;\n'
            'vector<int> in;\n'
            '\n'
            'void build(int v, int l, int r) {\n'
            '    if (r - l == 1) {\n'
            '        t[v].a.push_back(in[l]);\n'
            '        return;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    build(v * 2 + 1, l, m);\n'
            '    build(v * 2 + 2, m, r);\n'
            '    t[v].a.resize(t[v * 2 + 1].a.size() + t[v * 2 + 2].a.size());\n'
            '    merge(t[v * 2 + 1].a.begin(), t[v * 2 + 1].a.end(), t[v * 2 + 2].a.begin(), t[v * 2 + 2].a.end(), t[v].a.begin());\n'
            '}\n'
            '\n'
            'int ask(int v, int l, int r, int askl, int askr, int x, int y) {\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return 0;\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        int first = lower_bound(t[v].a.begin(), t[v].a.end(), x) - t[v].a.begin();\n'
            '        int last = upper_bound(t[v].a.begin(), t[v].a.end(), y) - t[v].a.begin();\n'
            '        return last - first;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    return ask(v * 2 + 1, l, m, askl, askr, x, y) + ask(v * 2 + 2, m, r, askl, askr, x, y);\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n, m;\n'
            '    cin >> n >> m;\n'
            '    in.resize(n);\n'
            '    t.resize(4 * n);\n'
            '    cin >> in;\n'
            '    build(0, 0, n);\n'
            '    REP(m) {\n'
            '        int l, r, x, y;\n'
            '        cin >> l >> r >> x >> y;\n'
            '        cout << ask(0, 0, n, l - 1, r, x, y) << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Если также поступают запросы об изменении элемента, то в каждой вершине нужно хранить не массив, а декартово дерево\n'
            'Это декартово дерево должно поддерживать split как по ключу, так и по кол-ву отрезаемых элементов (чтобы изменить значение одного элемента)\n'
            '\n'
            'При помощи дерева mergesort можно решить задачу о нахождении кол-во различных чисел на отрезке массива\n'
            'Для этого сначала нужно создать массив Prev\n'
            'Prev[i] - такой индекс j, что i < j (j максимально), и a[i] = a[j] (если это первое вхождение, то Prev[i] = -1)\n'
            'Заметим, что кол-во различных чисел на отрезке будет равно кол-ву значений Prev[i] (l <= i <= r), которые меньше, чем l (до таких элементов в отрезке нет таких же)\n'
            'На такие запросы можно отвечать, построив дерево mergesort по массиву Prev\n'
            'struct Node {\n'
            '    vector<int> a;\n'
            '    Node() {}\n'
            '};\n'
            '\n'
            'vector<int> Prev;\n'
            'vector<Node> t;\n'
            '\n'
            'void build(int v, int l, int r) {\n'
            '    if (r - l == 1) {\n'
            '        t[v].a = {Prev[l]};\n'
            '        return;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    build(v * 2 + 1, l, m);\n'
            '    build(v * 2 + 2, m, r);\n'
            '    t[v].a.resize(t[v * 2 + 1].a.size() + t[v * 2 + 2].a.size());\n'
            '    merge(t[v * 2 + 1].a.begin(), t[v * 2 + 1].a.end(), t[v * 2 + 2].a.begin(), t[v * 2 + 2].a.end(), t[v].a.begin());\n'
            '}\n'
            '\n'
            'int ask(int v, int l, int r, int askl, int askr) {\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return 0;\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        int firstNo = lower_bound(t[v].a.begin(), t[v].a.end(), askl) - t[v].a.begin();\n'
            '        return firstNo;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    return ask(v * 2 + 1, l, m, askl, askr) + ask(v * 2 + 2, m, r, askl, askr);\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    fastIO;\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    vector<int> in(n);\n'
            '    t.resize(4 * n);\n'
            '    Prev.resize(n, -1);\n'
            '    cin >> in;\n'
            '    unordered_map<int, int> d;\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        if (d[in[i]] == 0) {\n'
            '            Prev[i] = -1;\n'
            '        }\n'
            '        else {\n'
            '            Prev[i] = d[in[i]] - 1;\n'
            '        }\n'
            '        d[in[i]] = i + 1;\n'
            '    }\n'
            '    build(0, 0, n);\n'
            '    int m;\n'
            '    cin >> m;\n'
            '    REP(m) {\n'
            '        int l, r;\n'
            '        cin >> l >> r;\n'
            '        cout << ask(0, 0, n, l - 1, r) << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Быстрее эта задача решается при помощи алгоритма Мо (см. Mo)\n')


def Fenwick():
    return ('Дерево Фенвика (Bit Indexed Tree)\n'
            '\n'
            'Дерево Фенвика - структура, которая позволяет решать задачу о сумме на отрезке с изменением элемента\n'
            'Дерево Фенвика пишется быстрее, чем ДО, и занимает меньше памяти\n'
            '\n'
            'Запрос суммы и запрос изменения работает за O(logn)\n'
            '\n'
            'Каждый элемент массива дерева хранит сумму на каком-то отрезке (этот отрезок заканчивается в этом элементе)\n'
            'Ответ на запрос получается из разности сумм на двух префиксах\n'
            'Сумма на префиксе получается из сумм на нескольких отрезках\n'
            '\n'
            'Переход от текущего конца отрезка к предыдущему - i & (i + 1) - 1\n'
            'Переход от текущего конца отрезка к следующему - i | (i + 1)\n'
            '\n'
            'Изменение элемента - это изменение всех отрезков, в которых дежит этот элемент\n'
            'Важно, что изменение - это не операция присваивания, а операция прибавления (можно прибавлять разность нового и старого значения)\n'
            '\n'
            'Дерево Фенвика можно строить за O(nlogn) (просто изменить каждый элемент) и за O(n)\n'
            'Для построения за O(n) нужно пройти по массиву с начала и прибавить к концам отрезков значения\n'
            '\n'
            'Код:\n'
            'int n;\n'
            'vector<ll> t;\n'
            '\n'
            'void change(int i, ll delta) {\n'
            '    for (int pos = i; pos < n; pos = pos | (pos + 1)) {\n'
            '        t[pos] += delta;\n'
            '    }\n'
            '}\n'
            '\n'
            'll ask(int i) {\n'
            '    ll res = 0;\n'
            '    for (int pos = i; pos >= 0; pos = (pos & (pos + 1)) - 1) {\n'
            '        res += t[pos];\n'
            '    }\n'
            '    return res;\n'
            '}\n'
            '\n'
            'll ask(int l, int r) {\n'
            '    return ask(r) - (l == 0 ? 0 : ask(l - 1));\n'
            '}\n'
            '\n'
            'void build(const vector<ll>& a) {\n'
            '    t = a;\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        int j = i | (i + 1);\n'
            '        if (j < n) {\n'
            '            t[j] += t[i];\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    cin >> n;\n'
            '    vector<ll> a(n);\n'
            '    cin >> a;\n'
            '    build(a);\n'
            '    int q;\n'
            '    cin >> q;\n'
            '    REP(q) {\n'
            '        char mode;\n'
            '        cin >> mode;\n'
            '        if (mode == \'s\') {\n'
            '            int l, r;\n'
            '            cin >> l >> r;\n'
            '            cout << ask(l - 1, r - 1) << \' \';\n'
            '        }\n'
            '        else {\n'
            '            int pos;\n'
            '            ll nval;\n'
            '            cin >> pos >> nval;\n'
            '            change(pos - 1, nval - a[pos - 1]);\n'
            '            a[pos - 1] = nval;\n'
            '        }\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Дерево Фенвика обобщается на многомерные случаи\n'
            'Двумерное дерево Фенвика (поиск суммы на прямоугольнике с изменением элемента):\n'
            'int n, m;\n'
            'vector<vector<ll>> t;\n'
            '\n'
            'll ask(int x, int y) {\n'
            '    ll res = 0;\n'
            '    for (int i = x; i >= 0; i = (i & (i + 1)) - 1) {\n'
            '        for (int j = y; j >= 0; j = (j & (j + 1)) - 1) {\n'
            '            res += t[i][j];\n'
            '        }\n'
            '    }\n'
            '    return res;\n'
            '}\n'
            '\n'
            'll ask(int x1, int y1, int x2, int y2) {\n'
            '    ll res = ask(x2, y2);\n'
            '    if (x1 > 0) {\n'
            '        res -= ask(x1 - 1, y2);\n'
            '    }\n'
            '    if (y1 > 0) {\n'
            '        res -= ask(x2, y1 - 1);\n'
            '    }\n'
            '    if (x1 > 0 && y1 > 0) {\n'
            '        res += ask(x1 - 1, y1 - 1);\n'
            '    }\n'
            '    return res;\n'
            '}\n'
            '\n'
            'void change(int x, int y, ll delta) {\n'
            '    for (int i = x; i < n; i = (i | (i + 1))) {\n'
            '        for (int j = y; j < m; j = (j | (j + 1))) {\n'
            '            t[i][j] += delta;\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'void build(const vector<vector<ll>>& a) {\n'
            '    t.resize(n, vector<ll>(m, 0));\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        for (int j = 0; j < m; j++) {\n'
            '            change(i, j, a[i][j]);\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    fastIO;\n'
            '    cin >> n >> m;\n'
            '    vector<vector<ll>> a(n, vector<ll>(m));\n'
            '    cin >> a;\n'
            '    build(a);\n'
            '    int q;\n'
            '    cin >> q;\n'
            '    REP(q) {\n'
            '        char mode;\n'
            '        cin >> mode;\n'
            '        if (mode == \'s\') {\n'
            '            int x1, y1, x2, y2;\n'
            '            cin >> x1 >> y1 >> x2 >> y2;\n'
            '            cout << ask(x1 - 1, y1 - 1, x2 - 1, y2 - 1) << el;\n'
            '        }\n'
            '        else {\n'
            '            int x, y;\n'
            '            ll nval;\n'
            '            cin >> x >> y >> nval;\n'
            '            change(x - 1, y - 1, nval - a[x - 1][y - 1]);\n'
            '            a[x - 1][y - 1] = nval;\n'
            '        }\n'
            '    }\n'
            '    return 0;\n'
            '}\n')


def segment_tree_2Dproblems():
    return ('Двумерные задачи на дерево отрезков\n'
            '\n'
            'Один из метод решения двумерных задач - сканлайн + ДО\n'
            'Сканлайн идёт по оси OX, а ДО по оси OY\n'
            '\n'
            'Пример задачи, решаемой таким способом - точка, покрытая максимальным кол-вом прямоугольников\n'
            'Есть несколько вариаций этой задачи. Код ниже решает задачу, в которой вводятся только прямоугольники\n'
            '\n'
            'template <class T> void uniq(vector<T>& a) {sort(a.begin(), a.end()); a.resize(unique(a.begin(), a.end()) - a.begin());}\n'
            '\n'
            'struct Val {\n'
            '    ll Max;\n'
            '    int index;\n'
            '    Val() {\n'
            '        Max = 0;\n'
            '        index = -1;\n'
            '    }\n'
            '    Val(ll Max_, int index_) {\n'
            '        Max = Max_;\n'
            '        index = index_;\n'
            '    }\n'
            '};\n'
            '\n'
            'Val unite(const Val a, const Val b) {\n'
            '    if (a.Max < b.Max) {\n'
            '        return b;\n'
            '    }\n'
            '    if (a.Max > b.Max) {\n'
            '        return a;\n'
            '    }\n'
            '    if (a.index < b.index) {\n'
            '        return b;\n'
            '    }\n'
            '    return a;\n'
            '}\n'
            '\n'
            'vector<Val> t;\n'
            'vector<ll> c;\n'
            '\n'
            'void push(int v) {\n'
            '    c[v * 2 + 1] += c[v];\n'
            '    c[v * 2 + 2] += c[v];\n'
            '    c[v] = 0;\n'
            '}\n'
            '\n'
            'Val add_c(Val a, ll add) {\n'
            '    a.Max += add;\n'
            '    return a;\n'
            '}\n'
            '\n'
            'void build(int v, int l, int r) {\n'
            '    if (r - l == 1) {\n'
            '        t[v] = Val(0, l);\n'
            '        return;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    build(v * 2 + 1, l, m);\n'
            '    build(v * 2 + 2, m, r);\n'
            '    t[v] = unite(t[v * 2 + 1], t[v * 2 + 2]);\n'
            '}\n'
            '\n'
            'void change(int v, int l, int r, int askl, int askr, int delta) {\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return;\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        c[v] += delta;\n'
            '        return;\n'
            '    }\n'
            '    push(v);\n'
            '    int m = (l + r) / 2;\n'
            '    change(v * 2 + 1, l, m, askl, askr, delta);\n'
            '    change(v * 2 + 2, m, r, askl, askr, delta);\n'
            '    t[v] = unite(add_c(t[v * 2 + 1], c[v * 2 + 1]), add_c(t[v * 2 + 2], c[v * 2 + 2]));\n'
            '}\n'
            '\n'
            'Val ask(int v, int l, int r, int askl, int askr) {\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return Val(-1e9, -1);\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        return add_c(t[v], c[v]);\n'
            '    }\n'
            '    push(v);\n'
            '    int m = (l + r) / 2;\n'
            '    Val x = ask(v * 2 + 1, l, m, askl, askr);\n'
            '    Val y = ask(v * 2 + 2, m, r, askl, askr);\n'
            '    t[v] = unite(add_c(t[v * 2 + 1], c[v * 2 + 1]), add_c(t[v * 2 + 2], c[v * 2 + 2]));\n'
            '    return unite(x, y);\n'
            '}\n'
            '\n'
            'struct Event {\n'
            '    int type;\n'
            '    int x;\n'
            '    int y_up;\n'
            '    int y_down;\n'
            '    Event() {}\n'
            '    Event(int type_, int x_, int y_up_, int y_down_) {\n'
            '        type = type_;\n'
            '        x = x_;\n'
            '        y_up = y_up_;\n'
            '        y_down = y_down_;\n'
            '    }\n'
            '};\n'
            '\n'
            'bool operator < (const Event& a, const Event& b) {\n'
            '    if (a.x == b.x) {\n'
            '        return a.type < b.type;\n'
            '    }\n'
            '    return a.x < b.x;\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    vector<Event> evs(n * 2);\n'
            '    vector<int> Y;\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        int x1, y1, x2, y2;\n'
            '        cin >> x1 >> y1 >> x2 >> y2;\n'
            '        Y.push_back(y1);\n'
            '        Y.push_back(y2);\n'
            '        evs[i * 2] = Event(0, x1, y1, y2);\n'
            '        evs[i * 2 + 1] = Event(1, x2, y1, y2);\n'
            '    }\n'
            '    uniq(Y);\n'
            '    sort(all(evs));\n'
            '    int nY = Y.size();\n'
            '    t.resize(4 * nY);\n'
            '    c.resize(4 * nY);\n'
            '    build(0, 0, nY);\n'
            '    ll ans = -1;\n'
            '    int x_ans = -1, y_ans = -1;\n'
            '    for (int i = 0; i < n * 2; i++) {\n'
            '        Event e = evs[i];\n'
            '        int y1 = lower_bound(all(Y), e.y_up) - Y.begin();\n'
            '        int y2 = lower_bound(all(Y), e.y_down) - Y.begin();\n'
            '        if (e.type == 0) {\n'
            '            change(0, 0, nY, y1, y2 + 1, 1);\n'
            '            Val res = ask(0, 0, nY, y1, y2 + 1);\n'
            '            if (res.Max > ans) {\n'
            '                ans = res.Max;\n'
            '                x_ans = e.x;\n'
            '                y_ans = Y[res.index];\n'
            '            }\n'
            '        }\n'
            '        else {\n'
            '            change(0, 0, nY, y1, y2 + 1, -1);\n'
            '        }\n'
            '    }\n'
            '    cout << ans << el << x_ans << \' \' << y_ans << el;\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Как работает этот код: когда открывается прямоугольник, в ДО на отрезке [Y_up, Y_down] прибавляется 1\n'
            'Когда прямоугольник закрывается, на отрезке происходит вычитание 1\n'
            'Чтобы найти ответ, можно после обработки события прибавления делать запрос максимума на отрезке, который только что был обработан\n'
            '(наверное, можно и лучше)\n'
            'В коде используется сжатие координат (хранятся только события x и y событий)\n'
            '\n'
            'ДВУМЕРНОЕ ДО\n'
            'ДО может быть многомерным\n'
            'Для этого в каждой вершине ДО нужно заводить ещё одно ДО\n'
            'Например, для двумерного случая внешнее ДО будет считать ответ по OX (вершина отвечает за несколько строк), а внутреннее ДО по OY (вершина отвечает за несколько столбцов)\n')


def lca():
    return ('LCA (Least Common Ancestor) - Наименьший Общий Предок\n'
            '\n'
            'Задача LCA - нахождение для вершин дерева v, u предка с наибольшей высотой (высота считается от корня дерева)\n'
            '\n'
            'Задача LCA решается несколькими способами:\n'
            '1. Двоичные подъёмы\n'
            '2. LCA -> RMQ\n'
            '3. Алгоритм Тарьяна\n'
            '\n'
            '1. ДВОИЧНЫЕ ПОДЪЁМЫ: O(nlogn) препроцессинга, O(logn) на запрос\n'
            'Будем хранить массив up, где up[v][k] - в какую вершину можно попасть из вершины v, поднявшись на 2^k вверх\n'
            'Массив up будет считаться в dfs, в котором также будут считаться времена входв и выхода из вершины\n'
            'up[v][k] = up[up[v][k - 1][k - 1] (делим отрезок на две части)\n'
            '\n'
            'Даются вершины v, u\n'
            'Сначала проверим, является ли какая-нибудь из них предком другой (для этого мы считали времена в dfs)\n'
            'Теперь будем подниматься из v по степеням двойки (массив up), следя за тем, чтобы v не стала предком u\n'
            'Ответ на задачу - up[v][0], т.е. непосредственный предок вершины v\n'
            '\n'
            'Код:\n'
            'vector<vector<int>> g;\n'
            'vector<int> tin, tout;\n'
            'vector<vector<int>> up;\n'
            'int Log;\n'
            'int timer;\n'
            '\n'
            'void dfs(int v, int p = 0) {\n'
            '    tin[v] = ++timer;\n'
            '    up[v][0] = p;\n'
            '    for (int i = 1; i <= Log; i++) {\n'
            '        up[v][i] = up[up[v][i - 1]][i - 1];\n'
            '    }\n'
            '    for (int to: g[v]) {\n'
            '        if (to != p) {\n'
            '            dfs(to, v);\n'
            '        }\n'
            '    }\n'
            '    tout[v] = ++timer;\n'
            '}\n'
            '\n'
            'bool is_parent(int v, int u) {\n'
            '    return tin[v] <= tin[u] && tout[v] >= tout[u];\n'
            '}\n'
            '\n'
            'int lca(int v, int u) {\n'
            '    if (is_parent(v, v)) {\n'
            '        return v;\n'
            '    }\n'
            '    if (is_parent(v, u)) {\n'
            '        return v;\n'
            '    }\n'
            '    for (int i = Log; i >= 0; i--) {\n'
            '        if (!is_parent(up[v][i], u)) {\n'
            '            v = up[v][i];\n'
            '        }\n'
            '    }\n'
            '    return up[v][0];\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    g.resize(n);\n'
            '    tin.resize(n);\n'
            '    tout.resize(n);\n'
            '    REP(n - 1) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        g[v].push_back(u);\n'
            '        g[u].push_back(v);\n'
            '    }\n'
            '    Log = 1;\n'
            '    timer = 0;\n'
            '    while ((1 << Log) <= n) {\n'
            '        Log++;\n'
            '    }\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        up[i].resize(Log + 1);\n'
            '    }\n'
            '    dfs(0);\n'
            '    int m;\n'
            '    cin >> m;\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        cout << lca(v, u) + 1 << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Чтобы найти длину пути между двумя вершинами в дереве, из высоты вершины v и высоты вершины u вычесть высоту их lca\n'
            '\n'
            'Метод двоичных подъёмов позволяет считать функции на пути из одной вершины до другой\n'
            'Например, можно найти минмальное ребро на пути между двумя вершинами\n'
            'Для этого нужно считать массив, похожий на массив up\n'
            'Код:\n'
            'vector<vector<int>> up, Min;\n'
            'vector<vector<pair<int, int>>> g;\n'
            'vector<int> tin, tout;\n'
            'int timer = 0;\n'
            'int Log;\n'
            '\n'
            'void dfs(int v, int p = 0, int M = 1e9) {\n'
            '    tin[v] = ++timer;\n'
            '    up[v][0] = p;\n'
            '    Min[v][0] = M;\n'
            '    for (int i = 1; i <= Log; i++) {\n'
            '        up[v][i] = up[up[v][i - 1]][i - 1];\n'
            '        Min[v][i] = min(Min[v][i - 1], Min[up[v][i - 1]][i - 1]);\n'
            '    }\n'
            '    for (auto pa: g[v]) {\n'
            '        int u = pa.first;\n'
            '        int w = pa.second;\n'
            '        if (u != p) {\n'
            '            dfs(u, v, w);\n'
            '        }\n'
            '    }\n'
            '    tout[v] = ++timer;\n'
            '}\n'
            '\n'
            'bool is_parent(int v, int u) {\n'
            '    return tin[v] <= tin[u] && tout[v] >= tout[u];\n'
            '}\n'
            '\n'
            'int get_min(int v, int u) {\n'
            '    int res = 1e9;\n'
            '    for (int i = Log; i >= 0; i--) {\n'
            '        if (!is_parent(up[v][i], u)) {\n'
            '            res = min(res, Min[v][i]);\n'
            '            v = up[v][i];\n'
            '        }\n'
            '    }\n'
            '    if (!is_parent(v, u)) {\n'
            '        res = min(res, Min[v][0]);\n'
            '    }\n'
            '    for (int i = Log; i >= 0; i--) {\n'
            '        if (!is_parent(up[u][i], v)) {\n'
            '            res = min(res, Min[u][i]);\n'
            '            u = up[u][i];\n'
            '        }\n'
            '    }\n'
            '    if (!is_parent(u, v)) {\n'
            '        res = min(res, Min[u][0]);\n'
            '    }\n'
            '    return res;\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    g.resize(n);\n'
            '    tin.resize(n);\n'
            '    tout.resize(n);\n'
            '    up.resize(n);\n'
            '    Min.resize(n);\n'
            '    // формат ввода - (предок вершины i, вес ребра между вершиной i и её предком)\n'
            '    for (int i = 1; i < n; i++) {\n'
            '        int v, w;\n'
            '        cin >> v >> w;\n'
            '        v--;\n'
            '        g[v].push_back({i, w});\n'
            '        g[i].push_back({v, w});\n'
            '    }\n'
            '    Log = 1;\n'
            '    while ((1 << Log) <= n) {\n'
            '        Log++;\n'
            '    }\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        up[i].resize(Log + 1);\n'
            '        Min[i].resize(Log + 1);\n'
            '    }\n'
            '    dfs(0);\n'
            '    int m;\n'
            '    cin >> m;\n'
            '    REP(m) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        cout << get_min(v, u) << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Двоичные подъёмы позволяют считать функции и на массивах (сумма, минимум...)\n'
            'Вводится запрос [L, R]\n'
            'Для ответа нужно пройти по степеням двойки от L до R и собрать ответ\n'
            '\n'
            '2. LCA -> RMQ\n'
            'LCA можно свести к задаче RMQ\n'
            'Для этого нужно совершить эйлеров обход дерева (выписать веришину при заходе в неё)\n'
            'Но сам массив вершин понадобится только для поиска номера вершины\n'
            'Важен массив высот вершин, соответсвующий массиву выписанных вершин\n'
            'На массиве нужно построить структуру данных, позволяющую искать RMQ на отрезке (ДО, Sparse Table, SQRT-decomposition...)\n'
            '\n'
            'Для каждой вершины нужно хранить её индекс в массиве обхода (индекс любого вхождения)\n'
            'Чтобы найти LCA(v, u), нужно найти минимум на отрезке [ind[v], ind[u]] массива высот\n'
            '\n'
            'Реализация с ДО:\n'
            'vector<vector<int>> g;\n'
            'vector<int> d;\n'
            'vector<int> a;\n'
            'vector<int> indexes;\n'
            'vector<bool> used;\n'
            'vector<pair<int, int>> t;\n'
            'int sz;\n'
            '\n'
            'void dfs(int v, int depth) {\n'
            '    a.push_back(v);\n'
            '    d.push_back(depth);\n'
            '    indexes[v] = d.size() - 1;\n'
            '    used[v] = true;\n'
            '    for (int u: g[v]) {\n'
            '        if (!used[u]) {\n'
            '            dfs(u, depth + 1);\n'
            '            a.push_back(v);\n'
            '            d.push_back(depth);\n'
            '            indexes[v] = d.size() - 1;\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'void build(int v, int l, int r) {\n'
            '    if (r - l == 1) {\n'
            '        t[v] = {d[l], l};\n'
            '        return;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    build(v * 2 + 1, l, m);\n'
            '    build(v * 2 + 2, m, r);\n'
            '    t[v] = min(t[v * 2 + 1], t[v * 2 + 2]);\n'
            '}\n'
            '\n'
            'pair<int, int> ask(int v, int l, int r, int askl, int askr) {\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return {1e9, -1};\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        return t[v];\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    return min(ask(v * 2 + 1, l, m, askl, askr), ask(v * 2 + 2, m, r, askl, askr));\n'
            '}\n'
            '\n'
            'int lca(int v, int u) {\n'
            '    int vi = indexes[v];\n'
            '    int ui = indexes[u];\n'
            '    if (vi > ui) {\n'
            '        swap(vi, ui);\n'
            '    }\n'
            '    pair<int, int> res = ask(0, 0, sz, vi, ui + 1);\n'
            '    return a[res.second];\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    g.resize(n);\n'
            '    indexes.resize(n);\n'
            '    used.resize(n);\n'
            '    REP(n - 1) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        g[v].push_back(u);\n'
            '        g[u].push_back(v);\n'
            '    }\n'
            '    dfs(0, 0);\n'
            '    sz = d.size();\n'
            '    t.resize(4 * sz);\n'
            '    build(0, 0, sz);\n'
            '    int m;\n'
            '    cin >> m;\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        cout << lca(v, u) + 1 << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Реализация с Sparse Table:\n'
            'vector<vector<int>> g;\n'
            'vector<int> d, a, indexes;\n'
            'vector<bool> used;\n'
            'vector<vector<pair<int, int>>> sparse;\n'
            'vector<int> logs;\n'
            'int sz;\n'
            '\n'
            'void dfs(int v, int depth) {\n'
            '    used[v] = true;\n'
            '    a.push_back(v);\n'
            '    d.push_back(depth);\n'
            '    indexes[v] = d.size() - 1;\n'
            '    for (int u: g[v]) {\n'
            '        if (!used[u]) {\n'
            '            dfs(u, depth + 1);\n'
            '            a.push_back(v);\n'
            '            d.push_back(depth);\n'
            '            indexes[v] = d.size() - 1;\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'void build_sparse() {\n'
            '    logs.resize(sz + 1);\n'
            '    logs[1] = 0;\n'
            '    for (int i = 2; i <= sz; i++) {\n'
            '        logs[i] = logs[i / 2] + 1;\n'
            '    }\n'
            '    sparse.resize(logs[sz] + 1, vector<pair<int, int>>(sz));\n'
            '    for (int i = 0; i < sz; i++) {\n'
            '        sparse[0][i] = {d[i], i};\n'
            '    }\n'
            '    for (int level = 1; (1 << level) <= sz; level++) {\n'
            '        for (int i = 0; i + (1 << level) <= sz; i++) {\n'
            '            sparse[level][i] = min(sparse[level - 1][i], sparse[level - 1][i + (1 << (level - 1))]);\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'pair<int, int> ask(int l, int r) {\n'
            '    int len = r - l + 1;\n'
            '    int level = logs[len];\n'
            '    pair<int, int> ans = min(sparse[level][l], sparse[level][r - (1 << level) + 1]);\n'
            '    return ans;\n'
            '}\n'
            '\n'
            'int lca(int v, int u) {\n'
            '    int vi = indexes[v];\n'
            '    int ui = indexes[u];\n'
            '    if (vi > ui) {\n'
            '        swap(vi, ui);\n'
            '    }\n'
            '    pair<int, int> res = ask(vi, ui);\n'
            '    return a[res.second];\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    g.resize(n);\n'
            '    used.resize(n);\n'
            '    indexes.resize(n);\n'
            '    REP(n - 1) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        g[v].push_back(u);\n'
            '        g[u].push_back(v);\n'
            '    }\n'
            '    dfs(0, 0);\n'
            '    sz = d.size();\n'
            '    build_sparse();\n'
            '    int m;\n'
            '    cin >> m;\n'
            '    REP(m) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        cout << lca(v, u) + 1 << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            '3. АЛГОРИТМ ТАРЬЯНА\n'
            'Алгоритм Тарьяна решает задачу LCA в оффлайне (все запросы должны быть даны в начале, алгоритм отвечает на запросы не по порядку)\n'
            'Пройдём по дереву при помощи dfs\n'
            'Допустим мы стоим в врешине v, а нам нужно найти LCA(v, u)\n'
            'Пусть вершина u уже посещена\n'
            'Тогда LCA(v, u) - это какой-то предок вершины v, для которого u является потомком\n'
            'Пусть p - какой-нибудь предок вершины v; тогда LCA(v, i), где i - все вершины лежащие в поддеревьях вершины p (кроме того дерева, в котором лежит v), будет равно p\n'
            'Т.е. все предки вершины v - это какие-то представители классов вершин, у которых LCA с v одинаков\n'
            'Получается, нам всего лишь нужно найти представителя класса, в котором лежит вершина u\n'
            'Это делается при помощи СНМ\n'
            'Важно также хранить массив ancestor, в котором будет лежать правильная вершина (ведь представитель класса может быть любым при ранговой эвристике)\n'
            'Код:\n'
            'vector<vector<int>> g, Q;\n'
            'vector<int> p, d, ancestor;\n'
            'vector<bool> used;\n'
            'map<pair<int, int>, int> ans;\n'
            'vector<pair<int, int>> Q_pair;\n'
            '\n'
            'int get_par(int v) {\n'
            '    if (v == p[v]) {\n'
            '        return v;\n'
            '    }\n'
            '    return p[v] = get_par(p[v]);\n'
            '}\n'
            '\n'
            'void unite(int v, int u, int new_ancestor) {\n'
            '    v = get_par(v);\n'
            '    u = get_par(u);\n'
            '    if (v != u) {\n'
            '        if (d[u] > d[v]) {\n'
            '            swap(v, u);\n'
            '        }\n'
            '        p[u] = v;\n'
            '        if (d[v] == d[u]) {\n'
            '            d[v]++;\n'
            '        }\n'
            '        ancestor[v] = new_ancestor;\n'
            '    }\n'
            '}\n'
            '\n'
            'void dfs(int v) {\n'
            '    p[v] = v;\n'
            '    ancestor[v] = v;\n'
            '    used[v] = true;\n'
            '    for (int u: g[v]) {\n'
            '        if (!used[u]) {\n'
            '            dfs(u);\n'
            '            unite(v, u, v);\n'
            '        }\n'
            '    }\n'
            '    for (int u: Q[v]) {\n'
            '        if (used[u]) {\n'
            '            int lca = ancestor[get_par(u)];\n'
            '            ans[{v, u}] = lca;\n'
            '            ans[{u, v}] = lca;\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    fastIO;\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    g.resize(n);\n'
            '    used.resize(n);\n'
            '    ancestor.resize(n);\n'
            '    p.resize(n);\n'
            '    d.resize(n);\n'
            '    Q.resize(n);\n'
            '    int v, u;\n'
            '    REP(n - 1) {\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        g[v].push_back(u);\n'
            '        g[u].push_back(v);\n'
            '    }\n'
            '    int m;\n'
            '    cin >> m;\n'
            '    REP(m) {\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        Q[v].push_back(u);\n'
            '        Q[u].push_back(v);\n'
            '        Q_pair.emplace_back(v, u);\n'
            '    }\n'
            '    dfs(0);\n'
            '    for (auto pa: Q_pair) {\n'
            '        v = pa.first;\n'
            '        u = pa.second;\n'
            '        cout << ans[{v, u}] + 1 << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n')


def maxmatch():
    return ('Максимальное паросочетание\n'
            '\n'
            'Паросочетание - это набор ребёр графа, в котором никакие два ребра не имеют общей вершины\n'
            '\n'
            'Максимальное паросочетание - это паросочетание, состоящее из максимального кол-ва ребёр (для невзвешенного графа) или имеющее максимальный суммарный вес (для взвешенного графа)\n'
            '\n'
            'Паросочетание ищется по-разному для разных видов графа:\n'
            '1. Для дерева\n'
            '2. Для произвольного графа\n'
            '3. Для двудольного графа\n'
            '\n'
            '1. ДЕРЕВО\n'
            'Для поиска максимального паросочетания в дереве используется ДП по поддеревьям\n'
            'dp[v][0] - вершина v не соединена в просочетании с каким-либо из сыновей\n'
            'dp[v][1] - вершина v соединена в просочетании с каким-либо из сыновей\n'
            '\n'
            'Если вершина не соединена с каким-лио сыном, то dp[v][0] = max(dp[ui][0], dp[ui][1]) (не важны состояния сыновей)\n'
            'Но если вершина соединена с каким-либо из сыновей, то dp[v][0] = max(dp[uk][0] + max(dp[ui][0], dp[ui][1]), ui != uk)\n'
            '\n'
            'Код:\n'
            'vector<vector<pair<int, int>>> g;\n'
            'vector<vector<int>> dp;\n'
            '\n'
            'void dfs(int v, int pr) {\n'
            '    for (pair<int, int> p: g[v]) {\n'
            '        int u = p.first;\n'
            '        if (u != pr) {\n'
            '            dfs(u, v);\n'
            '            dp[v][0] += max(dp[u][0], dp[u][1]);\n'
            '        }\n'
            '    }\n'
            '    for (pair<int, int> p: g[v]) {\n'
            '        int u = p.first;\n'
            '        int w = p.second;\n'
            '        if (u != pr) {\n'
            '            dp[v][1] = max(dp[v][1], dp[u][0] + dp[v][0] - max(dp[u][0], dp[u][1]) + w);\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    g.resize(n);\n'
            '    dp.resize(n, vector<int>(2));\n'
            '    REP(n - 1) {\n'
            '        int v, u, w;\n'
            '        cin >> v >> u >> w;\n'
            '        v--;\n'
            '        u--;\n'
            '        g[v].push_back({u, w});\n'
            '        g[u].push_back({v, w});\n'
            '    }\n'
            '    dfs(0, -1);\n'
            '    cout << max(dp[0][0], dp[0][1]) << el;\n'
            '    return 0;\n'
            '}\n'
            '\n'
            '2. ПРОИЗВОЛЬНЫЙ ГРАФ\n'
            'Здесь будет рассматриваться медленный, но простой алгоритм для произвольного графа\n'
            '\n'
            'В алгоритме используется ДП по подмножествам\n'
            'dp[mask] - ответ, если все вершины подмножества находятся в паросочетании\n'
            'Если из всех вершин подмножества нельзя составить паросочетание, то dp[mask] = -1\n'
            '\n'
            'В текущем подмножестве выберем любую вершину v и посмотрим на всех её сыновей\n'
            'Пусть мы сейчас рассматривает сына u\n'
            'Если dp[mask без вершин u и v] не равен -1, то обновим dp[mask]\n'
            '\n'
            'Код:\n'
            'vector<vector<pair<int, int>>> g;\n'
            'vector<int> dp;\n'
            '\n'
            'int get_last1_bit(int mask) {\n'
            '    int ind = 0;\n'
            '    while (true) {\n'
            '        if (mask & 1) {\n'
            '            return ind;\n'
            '        }\n'
            '        ind++;\n'
            '        mask >> 1;\n'
            '    }\n'
            '}\n'
            '\n'
            'int get_bit(int mask, int i) {\n'
            '    return (mask >> i) & 1;\n'
            '}\n'
            '\n'
            'int bit_to0(int mask, int i) {\n'
            '    return mask & ~(1 << i);\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    g.resize(n);\n'
            '    dp.resize((1 << n), -1);\n'
            '    int m;\n'
            '    cin >> m;\n'
            '    REP(m) {\n'
            '        int v, u, w;\n'
            '        cin >> v >> u >> w;\n'
            '        v--;\n'
            '        u--;\n'
            '        g[v].push_back({u, w});\n'
            '        g[u].push_back({v, w});\n'
            '    }\n'
            '    dp[0] = 0;\n'
            '    int ans = 0;\n'
            '    for (int mask = 1; mask < (1 << n); mask++) {\n'
            '        int v = get_last1_bit(mask);\n'
            '        for (pair<int, int> p: g[v]) {\n'
            '            int u = p.first;\n'
            '            int w = p.second;\n'
            '            if (get_bit(mask, u)) {\n'
            '                int nmask = bit_to0(mask, u);\n'
            '                if (dp[nmask] != -1) {\n'
            '                    dp[mask] = max(dp[mask], dp[nmask] + w);\n'
            '                    ans = max(ans, dp[mask]);\n'
            '                }\n'
            '            }\n'
            '        }\n'
            '    }\n'
            '    cout << ans << el;\n'
            '    return 0;\n'
            '}\n'
            '\n'
            '3. ДВУДОЛЬНЫЙ ГРАФ\n'
            'См. Kuhn (там же применение паросочетаний)\n')


def Kuhn():
    return ('Алгоритм Куна\n'
            '\n'
            'Алгоритм Куна - это алгоритм поиска максимального по размеру паросочетания в двудольном графе\n'
            '\n'
            'Пусть граф уже разбит на две доли\n'
            'Будем по порядку добавлять вершины первой доли\n'
            'Если мы можем найти свободную пару для новой вершины, то создадим пару и закончим вызов алгоритма\n'
            'Еслм мы не можем найти свободную пару, то попробуем отобрать вершину, соединённую с предыдущей добавленной вершиной\n'
            'Будем делать это рекурсивно\n'
            '\n'
            'Код:\n'
            'int n, m; // размеры долей графа\n'
            'vector<vector<int>> g; // len = n, хранить только для первой доли\n'
            'vector<int> used; // used[i] - номер последнего запуска алгоритма, в котором i было true\n'
            'vector<int> pairs; // len = m, сначала заполнен -1\n'
            '\n'
            '\n'
            '// Если граф задан как обычно\n'
            'int N;\n'
            'vector<vector<int>> G;\n'
            'vector<int> col;\n'
            'vector<int> col1, col2;\n'
            '\n'
            'void color(int v, int c) {\n'
            '    col[v] = c;\n'
            '    for (int u: G[v]) {\n'
            '        if (col[u] == -1) {\n'
            '            color(u, (c + 1) % 2);\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            '\n'
            'bool kuhn(int v, int timer) {\n'
            '    used[v] = timer;\n'
            '    for (int u: g[v]) {\n'
            '        if (pairs[m] == -1 || (used[pairs[u]] != timer && kuhn(pairs[u], timer))) {\n'
            '            pairs[u] = m;\n'
            '            return true;\n'
            '        }\n'
            '    }\n'
            '    return false;\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    // input\n'
            '    // Если input ненормальный (граф задан как обычно):\n'
            '    col.resize(N, -1);\n'
            '    color(0, 0);\n'
            '    for (int i = 0; i < N; i++) {\n'
            '        if (col[i] == 0) {\n'
            '            col1.push_back(i);\n'
            '        }\n'
            '        else {\n'
            '            col2.push_back(i);\n'
            '        }\n'
            '    }\n'
            '    n = col1.size();\n'
            '    m = col2.size();\n'
            '    g.resize(n);\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        g[i] = G[col1[i]];\n'
            '    }\n'
            '\n'
            '\n'
            '    pairs.resize(m, -1);\n'
            '    used.resize(n, -1);\n'
            '    for (int v = 0; v < n; v++) {\n'
            '        kuhn(v, v);\n'
            '    }\n'
            '    // ответ можно восстановить по pairs\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Применение паросочетаний:\n'
            'Построим паросочетание на графе\n'
            'Теперь ориентируем рёбра (если есть в парсоче, то <-, иначе ->)\n'
            'Запустим dfs из всех ненасыщенных вершин (т.е. из тих, которые не затрагивает паросочетание)\n'
            'Все вершины разобьются на 4 группы:\n'
            'L+ - левая доля, посещены dfs\n'
            'L- - левая доля, не посещены dfs\n'
            'R+ - правая доля, посещены dfs\n'
            'R- - правая доля, не посещены dfs\n'
            '\n'
            'Рёбра между этими группами могут быть только такие:\n'
            '   ---->\n'
            'L+ <---- R+\n'
            '         ^\n'
            '      /\n'
            '   /\n'
            'L- ----> R-\n'
            '   <----\n'
            '\n'
            '1) Минимальное вершинное покрытие = min(L, R, L- + R+) (Мощность мин. покрытия равна мощности макс. паросочетания)\n'
            '2) Максимальное независимое множество = L+ + R-\n'
            'Поэтому 1 + 2 = кол-во вершин\n'
            '\n'
            'ПОКРЫТИЕ ОРИЕНТИРОВАННОГО ГРАФА МИНИМАЛЬНЫМ КОЛ-ВОМ ПУТЕЙ\n'
            'Продублируем вершины графа (правая доля - копия всех вершин)\n'
            'Проведём рёбра из левой доли в правую (те рёбра, которые были в исходном графе)\n'
            'Построим парсоч на этом графе\n'
            'Теперь проведём обратные рёбра (из вершины 1 правой доли в вершину 1 левой доли, из вершины 2 правой доли в вершину 2 левой доли...)\n'
            '\n'
            'Будем запускаться из вершин правой доли, которые не покрыты парсочем\n'
            'Алгоритм таков: переходим по обратному ребру в левую долю,\n'
            '                если есть ребро паросочетания, то переходим по нему и повторяем алгоритм (так мы считаем один из путей)\n'
            '                если ребра парсоча нет, то заканчиваем\n'
            '\n'
            'Код:\n'
            'vector<vector<int>> graph;\n'
            'vector<int> used;\n'
            'vector<int> pairs;\n'
            'int n;\n'
            '\n'
            'bool Kuhn(int v, int timer) {\n'
            '    used[v] = timer;\n'
            '    for (int u : graph[v]) {\n'
            '        if (pairs[u] == -1 || (used[pairs[u]] != timer && Kuhn(pairs[u], timer))) {\n'
            '            pairs[u] = v;\n'
            '            return true;\n'
            '        }\n'
            '    }\n'
            '    return false;\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int m;\n'
            '    cin >> n >> m;\n'
            '    graph.resize(n);\n'
            '    pairs.resize(n, -1);\n'
            '    used.resize(n, -1);\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        graph[v].push_back(u);\n'
            '    }\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        Kuhn(i, i);\n'
            '    }\n'
            '    int cnt_paths = 0;\n'
            '    vector<vector<int>> paths;\n'
            '    int cur_path = -1;\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        if (pairs[i] == -1) {\n'
            '            cnt_paths++;\n'
            '            int v = i;\n'
            '            paths.push_back({});\n'
            '            cur_path++;\n'
            '            bool was_edge = false;\n'
            '            while (true) {\n'
            '                paths[cur_path].push_back(v + 1);\n'
            '                was_edge = false;\n'
            '                for (int u : graph[v]) {\n'
            '                    if (pairs[u] == v) {\n'
            '                        v = u;\n'
            '                        was_edge = true;\n'
            '                        break;\n'
            '                    }\n'
            '                }\n'
            '                if (!was_edge) {\n'
            '                    break;\n'
            '                }\n'
            '            }\n'
            '        }\n'
            '    }\n'
            '    cout << cnt_paths << el;\n'
            '    cout << paths << el;\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Антицепь - макс. множество вершин, в котором от любой вершины нельзя добраться до любой другой (в ориентированном графе)\n'
            'Кол-во вершин в антицепи равно минимальному кол-ву путей, на которые можно разбить граф\n')


def prefix_function():
    return ('Префикс-функция\n'
            '\n'
            'Префикс-функция элемента i строки s - это длина наибольшой подстроки, совпадающей с префиксом строки s и заканчивающейся в позиции i\n'
            'Другими словами, префикс функция элемента i строки s - это длина максиального бордера строки s[0..i]\n'
            '\n'
            'Для построения переберём бордеры в порядке уменьшения (просто будем брать бордер от текущего бордера) и посмотрим, какой из них мы можем дополнить новым символом\n'
            'Код:\n'
            'int n = s.size();\n'
            'vector<int> p(n);\n'
            'int k = 0;\n'
            'for (int i = 1; i < n; i++) {\n'
            '    while (k > 0 && s[i] != s[k]) {\n'
            '        k = p[k - 1];\n'
            '    }\n'
            '    if (s[i] == s[k]) {\n'
            '        k++;\n'
            '    }\n'
            '    p[i] = k;\n'
            '}\n'
            '\n'
            'Применения:\n'
            '# Поиск подстроки в строке\n'
            '  Запишем две строки через специальный символ (сначала та строка, которую мы ищем) и посчитаем префикс-функцию от получившейся строки\n'
            '  Если в каком-то элементе (после спец. символа) значение функции будет равно длине искомой строки, то мы нашли её вхождение\n'
            '\n'
            '# Период строки (требуется найти минимальную по длине строку t такую, что строку s можно представить в виде конкатенации нескольких строк t)\n'
            '  Посчитаем префикс-функцию от строки и возьмём последнее значение (p_last)\n'
            '  Если n делится на n - p_last, то ответ n - p_last\n'
            '  Иначе ответ n\n')


def bridges_cutpoints():
    return ('Мосты и точки сочленения\n'
            '\n'
            'Мост - ребро, при удалении которого граф распадается (число компонент связности увеличивается)\n'
            'Запустим dfs\n'
            'Из вершины могут идти прямые рёбра (ребра вниз), а также обратные рёбра (рёбра, которые ведут в вершины выше предка)\n'
            'Если у вершины есть обратные рёбра, то ребро (предок - текущая вершина) не является мостом\n'
            '\n'
            'struct Edge {\n'
            '    int u;\n'
            '    int index;\n'
            '    bool isbridge;\n'
            '    Edge* back;\n'
            '    Edge() {}\n'
            '    Edge(int u_, int index_) {\n'
            '        isbridge = false;\n'
            '        u = u_;\n'
            '        index = index_;\n'
            '    }\n'
            '};\n'
            '\n'
            'vector<vector<Edge*>> graph;\n'
            'vector<bool> used;\n'
            'vector<int> depth;\n'
            'vector<int> up;\n'
            'vector<int> ans;\n'
            '\n'
            'void dfs(int v, int d = 0, Edge* p = nullptr) {\n'
            '    used[v] = true;\n'
            '    depth[v] = d;\n'
            '    up[v] = d;\n'
            '    for (Edge* e : graph[v]) {\n'
            '        if (!used[e->u]) {\n'
            '            dfs(e->u, d + 1, e);\n'
            '            up[v] = min(up[v], up[e->u]);\n'
            '        }\n'
            '        else if (p && p->back != e) {\n'
            '            up[v] = min(up[v], depth[e->u]);\n'
            '        }\n'
            '    }\n'
            '    if (p && up[v] == depth[v]) {\n'
            '        p->isbridge = true;\n'
            '        p->back->isbridge = true;\n'
            '        ans.push_back(p->index + 1);\n'
            '    }\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n, m;\n'
            '    cin >> n >> m;\n'
            '    graph.resize(n);\n'
            '    depth.resize(n);\n'
            '    used.resize(n);\n'
            '    up.resize(n);\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        Edge* e1 = new Edge(u, i);\n'
            '        Edge* e2 = new Edge(v, i);\n'
            '        e1->back = e2;\n'
            '        e2->back = e1;\n'
            '        graph[v].push_back(e1);\n'
            '        graph[u].push_back(e2);\n'
            '    };\n'
            '    for (int v = 0; v < n; v++) {\n'
            '        if (!used[v]) {\n'
            '            dfs(v);\n'
            '        }\n'
            '    }\n'
            '    cout << ans.size() << el;\n'
            '    cout << ans << el;\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Точка сочленения - вершина, при удалении которой граф распадается (кол-во компонент связности увеличивается)\n'
            'Поиск точек сочленения похож на поиск мостов, однако есть отличия\n'
            'Во-первых, если хотя бы у одного сына нет обратного ребра, то текущая вершина является точкой сочленения\n'
            'Во-вторых, нужно отдельно проверить корень обхода: если у корня больше 1 сына, то он точка сочленения\n'
            '\n'
            'vector<vector<int>> graph;\n'
            'vector<bool> used;\n'
            'vector<int> depth;\n'
            'vector<int> up;\n'
            'vector<bool> is_cutpoint;\n'
            '\n'
            'void dfs(int v, int d = 0, int p = -1) {\n'
            '    used[v] = true;\n'
            '    depth[v] = d;\n'
            '    int children = 0;\n'
            '    up[v] = d;\n'
            '    for (int u : graph[v]) {\n'
            '        if (!used[u]) {\n'
            '            dfs(u, d + 1, v);\n'
            '            children++;\n'
            '            up[v] = min(up[v], up[u]);\n'
            '            if (p != -1 && up[u] >= depth[v]) {\n'
            '                is_cutpoint[v] = true;\n'
            '            }\n'
            '        }\n'
            '        else if (p != u) {\n'
            '            up[v] = min(up[v], depth[u]);\n'
            '        }\n'
            '    }\n'
            '    if (p == -1 && children > 1) {\n'
            '        is_cutpoint[v] = true;\n'
            '    }\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n, m;\n'
            '    cin >> n >> m;\n'
            '    graph.resize(n);\n'
            '    depth.resize(n);\n'
            '    used.resize(n);\n'
            '    up.resize(n);\n'
            '    is_cutpoint.resize(n);\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        graph[v].push_back(u);\n'
            '        graph[u].push_back(v);\n'
            '    };\n'
            '    for (int v = 0; v < n; v++) {\n'
            '        if (!used[v]) {\n'
            '            dfs(v);\n'
            '        }\n'
            '    }\n'
            '    vector<int> ans;\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        if (is_cutpoint[i]) {\n'
            '            ans.push_back(i + 1);\n'
            '        }\n'
            '    }\n'
            '    cout << ans.size() << el;\n'
            '    cout << ans << el;\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'С мостами и точками сочленения связаны компоненты двусвязности\n'
            'Две вершины рёберно двусвязны, если существуют хотя бы два непересекающихся по рёбрам пути между ними\n'
            'Два ребра вершинно двусвязны, если существуют хотя бы два непересекающихся по вершинам пути, соединяющие концы этих рёбер\n'
            '\n'
            'Компоненты рёберной двусвязности ищутся довольно просто\n'
            'Можно просто запустить dfs и не ходить по мостам\n'
            'Компоненты можно сжимать в вершины (полученный граф - дерево)\n'
            '\n'
            'Сжатие компонент рёберной двусвязности:\n'
            'vector<vector<int>> graph2;\n'
            'vector<int> comp;\n'
            '\n'
            'void dfs_comp(int v, int cur_comp) {\n'
            '    used[v] = true;\n'
            '    comp[v] = cur_comp;\n'
            '    for (Edge* e : graph[v]) {\n'
            '        if (!used[e->u] && !e->isbridge) {\n'
            '            dfs_comp(e->u, cur_comp);\n'
            '        }\n'
            '        else if (used[e->u] && e->isbridge) {\n'
            '            graph2[cur_comp].push_back(comp[e->u]);\n'
            '            graph2[comp[e->u]].push_back(cur_comp);\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    // ввод, нахождение мостов\n'
            '    used.assign(n, false);\n'
            '    int cur_comp = 0;\n'
            '    for (int v = 0; v < n; v++) {\n'
            '        if (!used[v]) {\n'
            '            graph2.push_back(vector<int>());\n'
            '            dfs_comp(v, cur_comp);\n'
            '            cur_comp++;\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'Нахождение компонент вершинной двусвязности:\n'
            'struct Edge {\n'
            '    int u;\n'
            '    int index;\n'
            '    Edge() {}\n'
            '    Edge(int u_, int index_) {\n'
            '        u = u_;\n'
            '        index = index_;\n'
            '    }\n'
            '};\n'
            '\n'
            'vector<vector<Edge>> graph;\n'
            'vector<bool> used;\n'
            'vector<int> depth;\n'
            'vector<int> up;\n'
            'vector<int> col;\n'
            'int maxcol = 0;\n'
            '\n'
            'void dfs(int v, int d = 0, int p = -1) {\n'
            '    used[v] = true;\n'
            '    depth[v] = d;\n'
            '    up[v] = d;\n'
            '    for (Edge e : graph[v]) {\n'
            '        int u = e.u;\n'
            '        if (!used[u]) {\n'
            '            dfs(u, d + 1, v);\n'
            '            up[v] = min(up[v], up[u]);\n'
            '        }\n'
            '        else if (p != u) {\n'
            '            up[v] = min(up[v], depth[u]);\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'void dfs_comp(int v, int color, int e_index) {\n'
            '    used[v] = true;\n'
            '    for (Edge e : graph[v]) {\n'
            '        int u = e.u;\n'
            '        if (e.index == e_index) {\n'
            '            continue;\n'
            '        }\n'
            '        if (!used[u]) {\n'
            '            if (up[u] >= depth[v]) {\n'
            '                maxcol++;\n'
            '                col[e.index] = maxcol;\n'
            '                dfs_comp(u, maxcol, e.index);\n'
            '            }\n'
            '            else {\n'
            '                col[e.index] = color;\n'
            '                dfs_comp(u, color, e.index);\n'
            '            }\n'
            '        }\n'
            '        else {\n'
            '            if (depth[u] < depth[v]) {\n'
            '                col[e.index] = color;\n'
            '            }\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n, m;\n'
            '    cin >> n >> m;\n'
            '    graph.resize(n);\n'
            '    depth.resize(n);\n'
            '    used.resize(n);\n'
            '    up.resize(n);\n'
            '    col.resize(m);\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        graph[v].push_back(Edge(u, i));\n'
            '        graph[u].push_back(Edge(v, i));\n'
            '    };\n'
            '    for (int v = 0; v < n; v++) {\n'
            '        if (!used[v]) {\n'
            '            dfs(v);\n'
            '        }\n'
            '    }\n'
            '    used.assign(n, false);\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        if (!used[i]) {\n'
            '            dfs_comp(i, maxcol, -1);\n'
            '        }\n'
            '    }\n'
            '    cout << maxcol << el;\n'
            '    cout << col << el;\n'
            '    return 0;\n'
            '}\n')


def dsu():
    return ('СНМ (Система Непересекающихся Множеств)\n'
            '\n'
            'СНМ - структура данных, позволяющая объединять множества и считать функции на их объединении\n'
            'СНМ можно представить в виде графа\n'
            'У каждого множества есть лидер (к которому напрямую или серез другие элементы) подвешиваются элементы множества\n'
            'Тогда объединение двух множеств - это просто подвешивание лидера одного множества к другому множеству\n'
            '\n'
            'В приведённом ниже коде используются ранговая эвристика и эвристика сжатия путей\n'
            '1) Ранговая эвристика: подвешивать лучше меньшее к большему (здесь это производится не по размерам множеств, а по рангам, но сути не меняет)\n'
            '2) Эвристика сжатия путей: хорошо, когда все вершины подвешены к лидеру напрямую\n'
            '\n'
            'vector<int> p, d;\n'
            '\n'
            'void init(int n) {\n'
            '    d.assign(n, 0);\n'
            '    p.resize(n);\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        p[i] = i;\n'
            '    }\n'
            '}\n'
            '\n'
            'int get_par(int v) {\n'
            '    if (v == p[v]) {\n'
            '        return v;\n'
            '    }\n'
            '    return p[v] = get_par(p[v]);\n'
            '}\n'
            '\n'
            'void unite(int v, int u) {\n'
            '    u = get_par(u);\n'
            '    v = get_par(v);\n'
            '    if (u != v) {\n'
            '        if (d[u] > d[v]) {\n'
            '            swap(u, v);\n'
            '        }\n'
            '        p[u] = v;\n'
            '        if (d[u] == d[v]) {\n'
            '            d[v]++;\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'Функции на объединении можно считать в unite (можно завести массив значений функций для элементов, как массив d)\n'
            'Тогда если мы хотим узнать значение функции в множестве, где лежит элемент v, нам нужно найти значение в массиве функции для get_par(v)\n'
            '\n'
            'СНМ используется в алгоритме Тарьяна (см. lca) и для построения минимального остовного дерева (см. mst)\n')


def mst():
    return ('Минимальное остовное дерево\n'
            '\n'
            'Минимальное остовное дерево (в взвешенном графе) - это граф, соединяющий все вершины исходного графа и имеющий наименьшую длину\n'
            'В невзвешенном графе дерево должно иметь наименьшее кол-во рёбер (n - 1)\n'
            '\n'
            'Алгоритм Прима:\n'
            'Алгоритм Прима каждый раз выбирает минимальное ребро, не ведущее в уже построенную компоненту\n'
            'Код с восстановлением ответа (список рёбер):\n'
            'const int INF = 1e9;\n'
            'signed main() {\n'
            '    int n, m;\n'
            '    cin >> n >> m;\n'
            '    vector<vector<pair<int, int>>> g(n);\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int v, u, w;\n'
            '        cin >> v >> u >> w;\n'
            '        v--;\n'
            '        u--;\n'
            '        g[v].push_back({u, w});\n'
            '        g[u].push_back({v, w});\n'
            '    }\n'
            '    vector<int> d(n, INF);\n'
            '    d[0] = 0;\n'
            '    set<pair<int, int>> s;\n'
            '    s.insert({0, 0});\n'
            '    vector<bool> added(n);\n'
            '    added[0] = true;\n'
            '    ll minost = 0;\n'
            '    vector<int> p(n, -1);\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        int v = s.begin()->second;\n'
            '        minost += s.begin()->first;\n'
            '        s.erase(s.begin());\n'
            '        added[v] = true;\n'
            '        for (auto& k: g[v]) {\n'
            '            int u = k.first, w = k.second;\n'
            '            if (added[u]) {\n'
            '                continue;\n'
            '            }\n'
            '            if (d[u] > w) {\n'
            '                s.erase({d[u], u});\n'
            '                d[u] = w;\n'
            '                p[u] = v;\n'
            '                s.insert({d[u], u});\n'
            '            }\n'
            '        }\n'
            '    }\n'
            '    cout << minost << el;\n'
            '    vector<pair<int, int>> ans;\n'
            '    for (int i = 1; i < n; i++) {\n'
            '        ans.push_back({i + 1, p[i] + 1});\n'
            '    }\n'
            '    for (pair<int, int> p: ans) {\n'
            '        cout << p.first << \' \' << p.second << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Алгоритм Краскала:\n'
            'Алгоритм Краскала объединяет ещё не объединённые вершины\n'
            'Рёбра сортируются по весу и добавляются по одному в СНМ\n'
            'Код с восстановлением ответа:\n'
            'vector<int> p, d;\n'
            '\n'
            'void init(int n) {\n'
            '    d.assign(n, 0);\n'
            '    p.resize(n);\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        p[i] = i;\n'
            '    }\n'
            '}\n'
            '\n'
            'int get_par(int v) {\n'
            '    if (v == p[v]) {\n'
            '        return v;\n'
            '    }\n'
            '    return p[v] = get_par(p[v]);\n'
            '}\n'
            '\n'
            'void unite(int v, int u) {\n'
            '    u = get_par(u);\n'
            '    v = get_par(v);\n'
            '    if (u != v) {\n'
            '        if (d[u] > d[v]) {\n'
            '            swap(u, v);\n'
            '        }\n'
            '        p[u] = v;\n'
            '        if (d[u] == d[v]) {\n'
            '            d[v]++;\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'struct Edge {\n'
            '    int v, u, w;\n'
            '    Edge() {}\n'
            '    Edge(int v_, int u_, int w_): v(v_), u(u_), w(w_) {}\n'
            '    bool operator<(const Edge& a) const {\n'
            '        return w < a.w;\n'
            '    }\n'
            '};\n'
            '\n'
            'signed main() {\n'
            '    int n, m;\n'
            '    cin >> n >> m;\n'
            '    vector<Edge> edges;\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int v, u, w;\n'
            '        cin >> v >> u >> w;\n'
            '        v--;\n'
            '        u--;\n'
            '        edges.push_back(Edge(v, u, w));\n'
            '    }\n'
            '    init(n);\n'
            '    sort(edges.begin(), edges.end());\n'
            '    ll minost = 0;\n'
            '    vector<Edge> ans;\n'
            '    for (const Edge& e: edges) {\n'
            '        if (get_par(e.v) != get_par(e.u)) {\n'
            '            unite(e.v, e.u);\n'
            '            minost += e.w;\n'
            '            ans.push_back(e);\n'
            '        }\n'
            '    }\n'
            '    cout << minost << el;\n'
            '    for (const Edge& e: ans) {\n'
            '        cout << e.v + 1 << \' \' << e.u + 1 << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'В конце нужно проверить, сколько ребёр в структуре. Если кол-во рёбер != n - 1, то граф несвязный, остовное дерево не построено\n'
            '\n'
            'Также можно строить несколько минимальных остовных деревьев\n'
            'Сначала нужно постороить минимальное дерево, а потом в цикле убирать по одному (или больше, если нужно много деревьев) ребру из дерева и заменять его другим в списке рёбер\n'
            'В конце нужно проверять существование нового остовного дерева (написано выше)\n')


def Floyd():
    return ('Алгоритм Флойда-Уоршелла\n'
            '\n'
            'Алгоритм Флойда-Уоршелла ищет кратчайшие расстояния между всеми парами вершин (веса могут быть отрицательными)\n'
            'Алгоритм использует матрицу смежности\n'
            'Алгоритм перибирает все пары вершин, а так же некоторую серединную вершину (путь между двумя вершинами обязан пройти через эту вершину)\n'
            '\n'
            'vector<vector<int>> m(n, vector<int>(n));\n'
            'cin >> m\n'
            'vector<vector<int>> dp = m;\n'
            'for (int k = 0; k < n; k++) {\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        for (int j = 0; j < n; j++) {\n'
            '            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);\n'
            '        }\n'
            '    }\n'
            '}\n'
            'cout << dp[start][finish] << el;\n')


def top_sort():
    return ('Топологическая сортировка\n'
            '\n'
            'Топологическая сортировка применяется на ориентированных графах'
            'Результат сортировки - массив вершин, в котором выполняется условие "рёбра идут только вправо" (рёбра идут от вершин в начале к вершинам в конце)\n'
            'Сортировка невозможна в графе с циклами\n'
            '\n'
            'Сортировка пишется с использованием dfs\n'
            'Код:\n'
            'int n;\n'
            'vector<bool> used;\n'
            'vector<int> ts;\n'
            '\n'
            'void dfs_ts(int v) {\n'
            '    used[v] = true;\n'
            '    for (int u : g[v]) {\n'
            '        if (!used[u])\n'
            '            dfs_ts(u);\n'
            '    }\n'
            '    ts.push_back(v);\n'
            '\n'
            'void top_sort() {\n'
            '    used.assign(n, false);\n'
            '    for (int v = 0; v < n; v++)\n'
            '        if (!used[v])\n'
            '            dfs_ts(v);\n'
            '    reverse(ts.begin(), ts.end());\n')


def dfs():
    return ('DFS - поиск в глубину\n'
            '\n'
            'dfs - это стандартный обход графа\n'
            '\n'
            'void dfs(int v, int d = 0) {\n'
            '    used[v] = true;\n'
            '    depth[v] = d;\n'
            '    for (int u : g[v]) {\n'
            '        if (!used[u]) {\n'
            '            dfs(u, d + 1);\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'Обычно dfs используется для прохода по графу и подсчёта какого-нибудь дп, функции и т.д.\n'
            '\n'
            'Некоторые задачи:\n'
            '1. Раскраска графа в 2 цвета\n'
            '   Граф можно раскрасить в 2 цвета, если он двудолен\n'
            '   Эту задачу можно решить жадным алгоритмом (просто попробовать раскрасить в 2 цвета)\n'
            '   Если мы встречаем вершину, которая уже покрашена, а сейчас мы знаем, что она должна быть покрашены в другой цвет, то граф не двудолен (есть цикл нечётной длины)\n'
            '2. Нахождение цикла в неориентрированном графе\n'
            '   Чтобы найти цикл можно запустить dfs\n'
            '   Если мы находим вершину, которая уже посещена, и мы не пришли из неё, то цикл найден\n'
            '3. Нахождение цикла в ориентированном графе\n'
            '   Красим граф в 3 цвета:\n'
            '   Заходим в вершину, её цвет равен 1\n'
            '   Проходим по всем смежным вершинам\n'
            '   Если цвет смежной вершины равен 0, то запускаем dfs из неё\n'
            '   Если цвет равен 1, то мы нашли цикл\n'
            '   После цикла присваиваем вершине цвет 2\n'
            '4. Нахождение диаметра дерева (самый длинный путь)\n'
            '   Функция maxlen:\n'
            '      Будем запускать dfs и запоминать расстояния от начальной вершины до всех остальных\n'
            '      Потом выведем позизицию максимума в списке этих расстояний\n'
            '   Теперь два раза запустим функцию\n'
            '   Первый раз (v1) от 0\n'
            '   Второй раз (v2) от v1\n'
            '   (v1, v2) - это ответ (пара вершин)\n'
            '5. Поиск компонент связности\n'
            '   Компонента связности - множество вершин, между каждой парой которых есть путь\n'
            '   Запустим dfs\n'
            '   Все вершины, которые он посетил - одна компонента связности\n'
            '   Запустим из непосещённой вершины, получим ещё одну компоненту\n'
            '6. Проверка, является ли одна вершина в дереве предком другой\n'
            '   Для этого будем сохранять времена входа и выхода для каждой вершины\n'
            '   Вершина v является предком u, если tin[v] <= tin[u] && tout[v] >= tout[u]\n')


def bfs():
    return ('BFS - поиск в ширину\n'
            '\n'
            'bfs ищет кратчайшие расстояния от одной вершины до остальных\n'
            'Код bfs (поиск кратчайшего пути между вершинами a и b + восстановление пути):\n'
            'const int INF = 1e9;\n'
            'signed main() {\n'
            '    int n, m, a, b;\n'
            '    cin >> n >> m >> a >> b;\n'
            '    a--;\n'
            '    b--;\n'
            '    vector<vector<pair<int, int>>> g(n);\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int u, v, w;\n'
            '        cin >> u >> v >> w;\n'
            '        u--;\n'
            '        v--;\n'
            '        g[u].push_back({v, w});\n'
            '        g[v].push_back({u, w});\n'
            '    }\n'
            '    vector<int> d(n, INF);\n'
            '    vector<int> p(n, -1);\n'
            '    queue<int> q;\n'
            '    q.push(a);\n'
            '    d[a] = 0;\n'
            '    while (!q.empty()) {\n'
            '        int v = q.front();\n'
            '        q.pop();\n'
            '        for (pair<int, int> pair: g[v]) {\n'
            '            int u = pair.first;\n'
            '            int w = pair.second;\n'
            '            if (d[u] > d[v] + w) {\n'
            '                d[u] = d[v] + w;\n'
            '                q.push(u);\n'
            '                p[u] = v;\n'
            '            }\n'
            '        }\n'
            '    }\n'
            '    if (d[b] == INF) {\n'
            '        cout << "-1\\n";\n'
            '    }\n'
            '    else {\n'
            '        cout << d[b] << el;\n'
            '        vector<int> ans;\n'
            '        int cur = b;\n'
            '        while (cur != -1) {\n'
            '            ans.push_back(cur + 1);\n'
            '            cur = p[cur];\n'
            '        }\n'
            '        reverse(ans.begin(), ans.end());\n'
            '        cout << ans << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'У bfs есть модификации:\n'
            '1. 0-1 BFS\n'
            '   Если рёбра имеют вес только 0 или 1, то нужно использовать не queue, a deque\n'
            '   Если ребро имеет вес 0, то нужно добавлять его в начало (push_front), иначе в конец (push_back)\n'
            '2. 0-k BFS\n'
            '   BFS может заменить Дейкстру при небольших k\n'
            '   Мы имеем k+1 очередь, одна из них текущая (расстояние d)\n'
            '   Если мы находим вершину c расстоянием x, то мы кладём её в очердь с вершинами d+x\n'
            '   Когда текущая очередь заканчивается, мы переходим в очередь d+1, а прошлая очередь становится максимальной\n'
            '   Пример:\n'
            '   Максимум был d+5\n'
            '   Текущая очередь d закончилась\n'
            '   Мы переходим в очередь d+1, а прошлая очередь теперь равна d+6\n')


def persistent_st():
    return ('Персистентное дерево отрезков\n'
            '\n'
            'Персистентное ДО сохраняет все свои версии (версии появляются в процессе запросов изменения)\n'
            '\n'
            'Чтобы сохранять версии, при запросе изменения нужно менять не сами вершины, а их копии\n'
            'Для этого ДО будет построено на указателях\n'
            'Когда мы заходим в вершину в запросе изменения, мы сначала копируем её, а потом делаем изменение в копии\n'
            'Сам запрос будет возвращать указатель - корень новой версии дерева\n'
            'Чтобы иметь доступ ко всем версиям дерева, можно класть все корни в массив\n'
            '\n'
            'Пример (персистентное ДО на сумму):\n'
            'vector<int> a;\n'
            '\n'
            'struct Node {\n'
            '    int sum;\n'
            '    Node* l;\n'
            '    Node* r;\n'
            '    Node() {\n'
            '        sum = 0;\n'
            '        l = nullptr;\n'
            '        r = nullptr;\n'
            '    }\n'
            '    Node(const Node* v) {\n'
            '        sum = v->sum;\n'
            '        l = v->l;\n'
            '        r = v->r;\n'
            '    }\n'
            '};\n'
            '\n'
            'Node* build(Node* v, int l, int r) {\n'
            '    if (r - l == 1) {\n'
            '        v->sum = a[l];\n'
            '        return v;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    v->l = new Node();\n'
            '    v->r = new Node();\n'
            '    v->l = build(v->l, l, m);\n'
            '    v->r = build(v->r, m, r);\n'
            '    v->sum = v->l->sum + v->r->sum;\n'
            '    return v;\n'
            '}\n'
            '\n'
            'int ask(Node* v, int l, int r, int askl, int askr) {\n'
            '    if (l >= askr || r <= askl) {\n'
            '        return 0;\n'
            '    }\n'
            '    if (l >= askl && r <= askr) {\n'
            '        return v->sum;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    return ask(v->l, l, m, askl, askr) + ask(v->r, m, r, askl, askr);\n'
            '}\n'
            '\n'
            'Node* change(const Node* v, int l, int r, int pos, int val) {\n'
            '    Node* u = new Node(v);\n'
            '    if (r - l == 1) {\n'
            '        u->sum = val;\n'
            '        return u;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    if (pos < m) {\n'
            '        u->l = change(u->l, l, m, pos, val);\n'
            '    }\n'
            '    else {\n'
            '        u->r = change(u->r, m, r, pos, val);\n'
            '    }\n'
            '    u->sum = u->l->sum + u->r->sum;\n'
            '    return u;\n'
            '}\n'
            '\n'
            'Персистентое ДО может применяться для решения различных задач за хорошую асимтотику и в онлайне:\n'
            '1. K-ая порядковая статитстика на отрезке (нужно найти число, которое будет на k-ом месте, если отрезок отсортировать)\n'
            '   Эту задачу можно решить при помощи merge-sort tree за O(log(n) ^ 2) на запрос, решение с персистентным ДО лучше\n'
            '   Сначала сожмём числа (отсортируем массив, удалим повторения и каждому числу из исходного массива сопоставим индекс в сжатом массиве)\n'
            '   Сделаем ДО на сумму, в листе i будет хранить кол-во чисел i в массиве в текущий момент\n'
            '   Заметим, что не применяя персистентность мы можем искать ответ на префиксе (для этого нужно спуститься по дереву и найти позицию k-ого числа)\n'
            '   Сделаем дерево персистентным. Пройдём по массиву (по не сжатому) и каждую версию будем добавлять по одному числу в ДО (увеличиваем значение в листе на 1)\n'
            '   Сделав дерево персистентным, мы можем искать ответ на отрезке: будем одновременно спускаться по версии r и версии l - 1\n'
            '   Тогда при проверке суммы левого сына во время спуска мы будем брать разность сумм двух версий\n'
            '   Так мы получаем реальное кол-во чисел на отрезке, поэтому можем найти ответ\n'
            'Код:\n'
            'template <class T> void uniq(vector<T>& a) {sort(a.begin(), a.end()); a.resize(unique(a.begin(), a.end()) - a.begin());}\n'
            '\n'
            'struct Node {\n'
            '    int sum;\n'
            '    Node* l;\n'
            '    Node* r;\n'
            '    Node() {\n'
            '        sum = 0;\n'
            '        l = nullptr;\n'
            '        r = nullptr;\n'
            '    }\n'
            '    Node(const Node* v) {\n'
            '        sum = v->sum;\n'
            '        l = v->l;\n'
            '        r = v->r;\n'
            '    }\n'
            '};\n'
            '\n'
            'vector<int> a;\n'
            'vector<int> uniq_a;\n'
            'vector<Node*> roots;\n'
            '\n'
            'Node* build(Node* v, int l, int r) {\n'
            '    if (r - l == 1) {\n'
            '        v->sum = 0;\n'
            '        return v;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    v->l = new Node();\n'
            '    v->r = new Node();\n'
            '    v->l = build(v->l, l, m);\n'
            '    v->r = build(v->r, m, r);\n'
            '    v->sum = v->l->sum + v->r->sum;\n'
            '    return v;\n'
            '}\n'
            '\n'
            'Node* change(const Node* v, int l, int r, int pos, int delta) {\n'
            '    Node* u = new Node(v);\n'
            '    if (r - l == 1) {\n'
            '        u->sum += delta;\n'
            '        return u;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    if (pos < m) {\n'
            '        u->l = change(u->l, l, m, pos, delta);\n'
            '    }\n'
            '    else {\n'
            '        u->r = change(u->r, m, r, pos, delta);\n'
            '    }\n'
            '    u->sum = u->l->sum + u->r->sum;\n'
            '    return u;\n'
            '}\n'
            '\n'
            'int kth(Node* v_r, Node* v_l, int l, int r, int k) {\n'
            '    if (r - l == 1) {\n'
            '        return l;\n'
            '    }\n'
            '    int m = (l + r) / 2;\n'
            '    int val = v_r->l->sum - v_l->l->sum;\n'
            '    if (val >= k) {\n'
            '        return kth(v_r->l, v_l->l, l, m, k);\n'
            '    }\n'
            '    return kth(v_r->r, v_l->r, m, r, k - val);\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    a.resize(n);\n'
            '    cin >> a;\n'
            '    uniq_a = a;\n'
            '    uniq(uniq_a);\n'
            '    int N = uniq_a.size();\n'
            '    Node* root = new Node();\n'
            '    root = build(root, 0, N);\n'
            '    roots.push_back(root);\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        int index = lower_bound(all(uniq_a), a[i]) - uniq_a.begin();\n'
            '        Node* nroot = change(root, 0, N, index, 1);\n'
            '        roots.push_back(nroot);\n'
            '        root = nroot;\n'
            '    }\n'
            '    int q;\n'
            '    cin >> q;\n'
            '    REP(q) {\n'
            '        int l, r, k;\n'
            '        cin >> l >> r >> k;\n'
            '        cout << uniq_a[kth(roots[r], roots[l - 1], 0, N, k)] << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            '2. Кол-во различных чисел на отрезке\n'
            '   Для позиции i массива будем хранить 1, если это последнее вхождение числа a[i] на префиксе [0, i]\n'
            '   При переходе к следующему префиксу, мы должны занулить предыдущее вхождение и поставить 1 на новую позицию\n'
            '   Построим на этом массиве персистентное ДО\n'
            '   Построим на этом массиве персистентное ДО\n'
            '   Тогда для запроса [l, r] идём версию в r и сситает сумму на [l, r] вэтой версии\n'
            '   Код не привожу, потому что на больших тестах мой код не работает (не знаю, почему)\n'
            '   Если задачу можно решить в оффлайне, то лучшее решение - алгоритм Мо (описано в Mo)\n'
            '   Также можно решить с использованием merge-sort tree (см. mergesort_tree)\n')


def euler():
    return ('Эйлеровость\n'
            '\n'
            'Эйлеров путь - путь в графе, проходящий по всем рёбрам один раз\n'
            'Эйлеров цикл - эйлеров путь, начинающийся и заканчивающийся в одной вершине\n'
            '\n'
            'Условие существования эйлерова пути: степени всех вершин чётные или есть две вершины с нечётными степенями\n'
            'Условие существования эйлерова цикла: степени всех вершин чётные\n'
            '\n'
            'Для ориентированных графов:\n'
            'Цикл есть, если условие "кол-во ребёр, входящих в вершину равно кол-во рёбер исходящих из вершины" выполняется для всех вершин\n'
            'Путь есть, если выполняется условие для всех вершин, кроме двух: у одной кол-во входящих рёбер больше кол-ва исходящих на 1, у второй наоборот\n'
            '\n'
            'Для построения пути будем просто ходить по рёбрам графа ровно по одному разу\n'
            'Для этого заведём массив first[v], в котором будет храниться индекс первого непосещённого ребра из данной вершины\n'
            'Конечно, если есть две вершины с нечётными степенями, нужно запускать алгоритм из одной из них\n'
            'В конце каждого запуска алгоритма (для одной вершины) добавляем вершину в ответ, потому что мы прошли все рёбра из этой вершины и больше в неё не вернёмся\n'
            'Для ориентированных графов нужно запускаться из вершины, у которой кол-во исходящих рёбер больше кол-ва входящих (если такая есть, иначе из любой вершины)\n'
            '\n'
            'Код:\n'
            'struct Edge {\n'
            '    int u;\n'
            '    int index;\n'
            '\n'
            '    Edge() {}\n'
            '    Edge(int u_, int index_) {\n'
            '        u = u_;\n'
            '        index = index_;\n'
            '    }\n'
            '};\n'
            '\n'
            'vector<vector<Edge>> graph;\n'
            'vector<bool> used;\n'
            'vector<int> first;\n'
            'vector<int> ans;\n'
            '\n'
            'void euler(int v) {\n'
            '    for (int i = first[v]; i < graph[v].size(); i++) {\n'
            '        first[v]++;\n'
            '        int u = graph[v][i].u;\n'
            '        int e = graph[v][i].index;\n'
            '        if (!used[e]) {\n'
            '            used[e] = true;\n'
            '            euler(u);\n'
            '        }\n'
            '    }\n'
            '    ans.push_back(v + 1);\n'
            '}\n'
            '\n'
            'ПОКРЫТИЕ НЕОРИЕНТИРОВАННОГО ГРАФА МИНИМАЛЬНЫМ КОЛ-ВОМ ПУТЕЙ\n'
            'Для покрытия путями для начала найдём все вершины с нечётными степенями\n'
            'Соединим их в пары (мы нашли 4 вершины, проведём рёбра 1 - 2 и 3 - 4)\n'
            'Запишем эти пары куда-нибудь\n'
            'Теперь построим эйлеров цикл (мы можем это сделать, потому что все степени вершин чётные)\n'
            'Разобьём цикл по рёбрам, которые мы добавили в начале\n'
            'Мы получаем пути. Надо не забыть склеить псоледний путь с первым (потому что это один путь)\n'
            'Единственная проблема заключается в том, что мы можем разрезать по рёбрам, которые были в графе изначально\n'
            'Пример - граф отрезок. После считывания мы добавим КРАТНОЕ ребро, соединяя две вершины с нечётными степенями\n'
            'Избежать это можно, храня кол-во рёбер между двумя соседними вершинами (мы должны разрезать только одно ребро)\n'
            '\n'
            'Код функции main (не претендует на идеальность, работает не особо быстро из-за map):\n'
            'signed main() {\n'
            '    int n, m;\n'
            '    cin >> n >> m;\n'
            '    map<pair<int, int>, int> edges;\n'
            '    graph.resize(n);\n'
            '    first.resize(n);\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        graph[v].push_back(Edge(u, i));\n'
            '        graph[u].push_back(Edge(v, i));\n'
            '        edges[{v, u}]++;\n'
            '        edges[{u, v}]++;\n'
            '    }\n'
            '    vector<int> n_vertex;\n'
            '    map<pair<int, int>, bool> to_del;\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        if (graph[i].size() % 2) {\n'
            '            n_vertex.push_back(i);\n'
            '        }\n'
            '    }\n'
            '    int cnt_edges = m;\n'
            '    for (int i = 1; i < n_vertex.size(); i += 2) {\n'
            '        int v = n_vertex[i - 1];\n'
            '        int u = n_vertex[i];\n'
            '        graph[v].push_back(Edge(u, cnt_edges));\n'
            '        graph[u].push_back(Edge(v, cnt_edges));\n'
            '        cnt_edges++;\n'
            '        to_del[{v + 1, u + 1}] = true;\n'
            '        to_del[{u + 1, v + 1}] = true;\n'
            '        edges[{v, u}]++;\n'
            '        edges[{u, v}]++;\n'
            '    }\n'
            '    used.resize(cnt_edges);\n'
            '    euler(0);\n'
            '    vector<vector<int>> paths;\n'
            '    paths.push_back({ans[0]});\n'
            '    for (int i = 1; i < ans.size(); i++) {\n'
            '        if (to_del.find({ans[i], ans[i - 1]}) != to_del.end()) {\n'
            '            if (edges[{ans[i] - 1, ans[i - 1] - 1}] <= 1) {\n'
            '                paths.push_back({});\n'
            '            }\n'
            '            paths[paths.size() - 1].push_back(ans[i]);\n'
            '            edges[{ans[i] - 1, ans[i - 1] - 1}]--;\n'
            '            edges[{ans[i - 1] - 1, ans[i] - 1}]--;\n'
            '        }\n'
            '        else {\n'
            '            paths[paths.size() - 1].push_back(ans[i]);\n'
            '        }\n'
            '    }\n'
            '    if (paths.size() > 1) {\n'
            '        cout << paths.size() - 1 << el;\n'
            '        for (int i : paths.back()) {\n'
            '            cout << i << \' \';\n'
            '        }\n'
            '        for (int i = 1; i < paths[0].size(); i++) {\n'
            '            cout << paths[0][i] << \' \';\n'
            '        }\n'
            '        cout << el;\n'
            '        for (int i = 1; i < paths.size() - 1; i++) {\n'
            '            for (int j : paths[i]) {\n'
            '                cout << j << \' \';\n'
            '            }\n'
            '            cout << el;\n'
            '        }\n'
            '    }\n'
            '    else {\n'
            '        cout << "1\\n";\n'
            '        for (int i : paths[0]) {\n'
            '            cout << i << \' \';\n'
            '        }\n'
            '        cout << el;\n'
            '    }\n'
            '    return 0;\n'
            '}\n')


def mitm():
    return ('Meet-in-the-middle\n'
            '\n'
            'MITM - это оптимизация перебора в множестве\n'
            'Вместо полного перебора всех значений производится перебор в половинах множества, а потом полученные значения совмещаются\n'
            '\n'
            'Примеры задач:\n'
            '1) Задача о рюкзаке (какой максимальный вес можно набрать) с огромными весами\n'
            '2) Разделить массив на два множества, стобы разница сумм множеств была минимальной\n'
            '3) Найти в массиве множество, сумма которого, взятая по модулю Mod, максимальна\n'
            '\n'
            '1:\n'
            'Разобьём все предметы на две равные части (разница +-1)\n'
            'Для каждой части посчитаем все возможные суммы, которые мы может набрать, используя преметы этой части (перебор масок с проверкой, что сумма меньше, чем вместимость рюкзака)\n'
            'Отсортируем обе части (можно также сделать uniq)\n'
            'Теперь будем идти по суммам, полученным из первой части и искать максимальную сумму, котроую мы можем взять из второй части (бинпоиск)\n'
            'Можно поддерживать и стоимости предметов, для этого нужно в процессе получения всех сумм делать пары (вес, стоимость)\n'
            'После получения всех сумм нужно отсортировать массив и удалить все пары, для которых мы можем набрать такой же вес, но бОльшую стоимость\n'
            'Тогда пары будут отсортированы и по весу, и по стоимости\n'
            'Код не привожу, но он очень похож на код второй и третьей задачи (только не надо забывать о проверке на то, что сумма весов не больше вместимости рюкзака)\n'
            '\n'
            '2:\n'
            'Опять же разобьём массив на две части\n'
            'Мы хотим набрать сумму наиболее близкую к sum / 2 (sum - сумма всех чисел массива)\n'
            'Для этого посчитаем для каждой части все возможные суммы, не превосходящие sum / 2\n'
            'Отсортируем и для каждой суммы первой части найдём максиальную сумму из второй части\n'
            'Код:\n'
            'll get_sum(int mask, const vector<int>& a) {\n'
            '    int cur = 1;\n'
            '    ll sum = 0;\n'
            '    int n = a.size();\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        if (cur & mask) {\n'
            '            sum += a[i];\n'
            '        }\n'
            '        cur = cur << 1;\n'
            '    }\n'
            '    return sum;\n'
            '}\n'
            '\n'
            'vector<ll> get_all_w(const vector<int>& a, ll w) {\n'
            '    vector<ll> res;\n'
            '    int n = a.size();\n'
            '    res.push_back(0);\n'
            '    for (int mask = 1; mask < (1 << n); mask++) {\n'
            '        ll sum = get_sum(mask, a);\n'
            '        if (sum <= w) {\n'
            '            res.push_back(sum);\n'
            '        }\n'
            '    }\n'
            '    return res;\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n;\n'
            '    cin >> n;\n'
            '    vector<int> w1, w2;\n'
            '    ll sum = 0;\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        int x;\n'
            '        cin >> x;\n'
            '        if (i < n / 2) {\n'
            '            w1.push_back(x);\n'
            '        }\n'
            '        else {\n'
            '            w2.push_back(x);\n'
            '        }\n'
            '        sum += x;\n'
            '    }\n'
            '    ll half = sum / 2;\n'
            '    vector<ll> all_w1 = get_all_w(w1, half);\n'
            '    vector<ll> all_w2 = get_all_w(w2, half);\n'
            '    sort(all_w2.begin(), all_w2.end());\n'
            '    ll ans = 1e18;\n'
            '    for (ll sum1 : all_w1) {\n'
            '        ll need_sum = half - sum1;\n'
            '        ll sum2;\n'
            '        int ind = lower_bound(all_w2.begin(), all_w2.end(), need_sum) - all_w2.begin();\n'
            '        if (ind == all_w2.size() || all_w2[ind] > need_sum) {\n'
            '            ind--;\n'
            '        }\n'
            '        if (ind == -1) {\n'
            '            continue;\n'
            '        }\n'
            '        sum2 = all_w2[ind];\n'
            '        ans = min(abs(sum - 2 * (sum2 + sum1)), ans);\n'
            '    }\n'
            '    cout << ans << el;\n'
            '    return 0;\n'
            '}\n'
            '\n'
            '3:\n'
            'Разбиваем массив на две части\n'
            'Для каждой части считаем все возможные суммы по модулю Mod\n'
            'Сортируем суммы, делаем uniq\n'
            'Для каждой суммы из первой части ищем наибольшую возможную сумму из второй части (очевидно, она должна быть меньше или равна, чем Mod - sum1 - 1)\n'
            'Код:\n'
            'll Mod;\n'
            '\n'
            'll get_sum(int mask, const vector<ll>& a) {\n'
            '    ll sum = 0;\n'
            '    int n = a.size();\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        if ((1 << i) & mask) {\n'
            '            sum += (a[i] % Mod);\n'
            '            sum %= Mod;\n'
            '        }\n'
            '    }\n'
            '    return sum;\n'
            '}\n'
            '\n'
            'vector<ll> get_all_sums(const vector<ll>& a) {\n'
            '    vector<ll> res;\n'
            '    int n = a.size();\n'
            '    res.reserve((1 << n));\n'
            '    for (int mask = 0; mask < (1 << n); mask++) {\n'
            '        res.push_back(get_sum(mask, a));\n'
            '    }\n'
            '    return res;\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int n;\n'
            '    cin >> n >> Mod;\n'
            '    vector<ll> a1, a2;\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        ll x;\n'
            '        cin >> x;\n'
            '        if (i < n / 2) {\n'
            '            a1.push_back(x);\n'
            '        }\n'
            '        else {\n'
            '            a2.push_back(x);\n'
            '        }\n'
            '    }\n'
            '    vector<ll> all1 = get_all_sums(a1);\n'
            '    vector<ll> all2 = get_all_sums(a2);\n'
            '    uniq(all1);\n'
            '    uniq(all2);\n'
            '    ll ans = 0;\n'
            '    for (ll cur : all1) {\n'
            '        int index = upper_bound(all(all2), Mod - cur - 1) - all2.begin() - 1;\n'
            '        if (index == -1) {\n'
            '            continue;\n'
            '        }\n'
            '        ans = max(ans, (cur + all2[index]) % Mod);\n'
            '    }\n'
            '    cout << ans << el;\n'
            '    return 0;\n'
            '}\n')


def condensation():
    return ('Конденсация\n'
            '\n'
            'Конденсация - это выделение в графе компонент сильной связности\n'
            'Компонента сильной связности (в ориентированном графе) - множество вершин, в котором от каждой вершины можно добраться до любой другой\n'
            '\n'
            'Чтобы выделить компоненты, нужно сначала сделать top_sort (граф может быть с циклами, но это не важно)\n'
            'Теперь нужно транспонировать граф (развернуть все рёбра). Это можно сделать ещё при вводе\n'
            'После этого пройдём по транспонированному графу в порядке top_sort\n'
            'Все вершины, котороые мы прошли за один запуск dfs - это одна компоента сильной связности\n'
            '\n'
            'По конденсации можно построить граф (сжать каждую компоненту в вершину)\n'
            'Такой граф - дерево\n'
            'Если требуется, чтобы в конденсации не было кратных рёбер, можно хранить map для добавленных рёбер между компонентами\n'
            '\n'
            'Код с сжатием в вершины:\n'
            'vector<vector<int>> graph, r_graph, comp_graph;\n'
            'vector<int> comp;\n'
            'vector<int> ts;\n'
            'vector<bool> used;\n'
            'int n;\n'
            '\n'
            'void dfs(int v) {\n'
            '    used[v] = true;\n'
            '    for (int u : graph[v]) {\n'
            '        if (!used[u]) {\n'
            '            dfs(u);\n'
            '        }\n'
            '    }\n'
            '    ts.push_back(v);\n'
            '}\n'
            '\n'
            'void top_sort() {\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        if (!used[i]) {\n'
            '            dfs(i);\n'
            '        }\n'
            '    }\n'
            '    reverse(ts.begin(), ts.end());\n'
            '}\n'
            '\n'
            'void dfs_cond(int v, int cur_comp) {\n'
            '    used[v] = true;\n'
            '    comp[v] = cur_comp;\n'
            '    for (int u : r_graph[v]) {\n'
            '        if (!used[u]) {\n'
            '            dfs_cond(u, cur_comp);\n'
            '        }\n'
            '        else if (comp[u] != cur_comp) {\n'
            '            comp_graph[comp[u]].push_back(cur_comp);\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    int m;\n'
            '    cin >> n >> m;\n'
            '    graph.resize(n);\n'
            '    r_graph.resize(n);\n'
            '    comp.resize(n);\n'
            '    used.resize(n);\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int v, u;\n'
            '        cin >> v >> u;\n'
            '        v--;\n'
            '        u--;\n'
            '        graph[v].push_back(u);\n'
            '        r_graph[u].push_back(v);\n'
            '    }\n'
            '    top_sort();\n'
            '    used.assign(n, false);\n'
            '    int cur_comp = 0;\n'
            '    for (int i : ts) {\n'
            '        if (!used[i]) {\n'
            '            comp_graph.push_back({});\n'
            '            dfs_cond(i, cur_comp);\n'
            '            cur_comp++;\n'
            '        }\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'Задача о минимальном достижимом числе для каждой вершины:\n'
            'int n, m;\n'
            'vector<vector<int>> g;\n'
            'vector<int> used;\n'
            'vector<int> ts;\n'
            'vector<vector<int>> rg;\n'
            'vector<int> comp;\n'
            'vector<vector<int>> cg;\n'
            'vector<int> num; // числа в исходных вершинах\n'
            'vector<int> numcond; // числа в сжатых вершинах\n'
            'vector<int> dp; // ответ для сжатых\n'
            'vector<int> ans; // ответ для исходных\n'
            '\n'
            'void dfs(int v) {\n'
            '    used[v] = 1;\n'
            '    for (int u: g[v]) {\n'
            '        if (!used[u]) {\n'
            '            dfs(u);\n'
            '        }\n'
            '    }\n'
            '    used[v] = 2;\n'
            '    ts.push_back(v);\n'
            '}\n'
            '\n'
            'void dfscond(int v, int cur_comp) {\n'
            '    used[v] = 1;\n'
            '    comp[v] = cur_comp;\n'
            '    for (int u: rg[v]) {\n'
            '        if (!used[u]) {\n'
            '            dfscond(u, cur_comp);\n'
            '        }\n'
            '        else if (cur_comp != comp[u]) {\n'
            '            cg[comp[u]].push_back(cur_comp);\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'signed main() {\n'
            '    cin >> n >> m;\n'
            '    g.resize(n);\n'
            '    rg.resize(n);\n'
            '    used.resize(n);\n'
            '    comp.resize(n);\n'
            '    num.resize(n);\n'
            '    ans.resize(n);\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int u, v;\n'
            '        cin >> u >> v;\n'
            '        g[u - 1].push_back(v - 1);\n'
            '        rg[v - 1].push_back(u - 1);\n'
            '    }\n'
            '    cin >> num;\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        if (!used[i]) {\n'
            '            dfs(i);\n'
            '        }\n'
            '    }\n'
            '    reverse(ts.begin(), ts.end());\n'
            '    used.assign(n, false);\n'
            '    int cur_comp = 0;\n'
            '    for (int v: ts) {\n'
            '        if (!used[v]) {\n'
            '            cg.push_back(vector<int>());\n'
            '            dfscond(v, cur_comp);\n'
            '            cur_comp++;\n'
            '        }\n'
            '    }\n'
            '    numcond.resize(cur_comp, INT_MAX);\n'
            '    dp.resize(cur_comp);\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        numcond[comp[i]] = min(numcond[comp[i]], num[i]);\n'
            '    }\n'
            '    for (int i = cur_comp - 1; i >= 0; i--) {\n'
            '        dp[i] = numcond[i];\n'
            '        for (int v: cg[i]) {\n'
            '            dp[i] = min(dp[i], dp[v]);\n'
            '        }\n'
            '    }\n'
            '    for (int i = 0; i < n; i++) {\n'
            '        ans[i] = dp[comp[i]];\n'
            '    }\n'
            '    return 0;\n'
            '}\n')


def no(a):
    global list_com
    global list_names
    list_names = [
        '\nМАТЕМАТИКА:',
        '\nЧТО-ТО:',
        '\nСТРОКИ:'
        '\nДП:',
        '\nСТРУКТУРЫ ДАННЫХ:',
        # '\nАЛГОРИТМЫ:',
        '\nГРАФЫ:',
        '\nГЕОМЕТРИЯ:'
    ]
    # 1) математика (но не геометрия)
    # 2) хрень, которую нельзя ни к чему отнести и надо удалить (или дополнить)
    # 3) строки
    # 4) дп (пока почти ничего нет)
    # 5) структуры данных
    # СПОРНО: 6) алгоритмы, которые не структуры данных (lca, например) - хотя lca можно отнести к графам
    # 7) всё, что связано с графами (СНМ ВЫДЕЛИТЬ В ОТДЕЛЬНЫЙ РАЗДЕЛ И ОТПРАВИТЬ В 5)
    # 8) геометрия
    list_com = ['all',

                '\nМАТЕМАТИКА:',
                'quick_pow',
                'bit_operations',
                'f_Euler',
                'gcdex',
                'eratosthenes_sieve',
                'check_for_simplicity',
                'factorize',
                'gcd_lcm',

                '\nЧТО-ТО:',
                'date_time',
                'combinations_enumeration', # bullshit
                'two_pointers', # add (from cf)
                'testing',
                'binsearch',
                'ternary_search',
                'sorts', # bullshit (rewrite + add)

                '\nСТРОКИ:',
                'hashes',
                'z_function',
                'prefix_function',
                'Manacher',
                'trie',
                'suffix_automaton',
                'Huffman',

                '\nДП:',
                'LCS',
                'LIS',
                'knapsack', # no
                'Levenshtein', # no
                'dp_trees', # no
                'dp_masks', # no
                'cht_opt', # no
                'matrix_opt', # no
                'mitm',

                '\nСТРУКТУРЫ ДАННЫХ:',
                'segment_tree',
                'persistent_st',
                'sparse_table',
                'sqrt_decomposition',
                'Mo',
                'dsu',
                'mergesort_tree',
                'segment_tree_2Dproblems',
                'pref_sum',
                'Fenwick',
                'treap',
                'implicit_treap',

                '\nГРАФЫ:',
                'dfs',
                'bfs',
                'Ford_Bellman', # no
                'Floyd',
                'Dijkstra',
                'mst',
                'top_sort',
                'condensation',
                '2sat', # no
                'euler',
                'bridges_cutpoints',
                'lca',
                'maxmatch',
                'Kuhn',
                'graphs', # delete
                'graphs2', # delete


                '\nГЕОМЕТРИЯ:',
                'geometry', # rewrite and rename
                'intersections', # no
                'polygons', # no
                'convex_hull' # no
                ]
    if a in list_names:
        return False
    if a not in list_com:
        return False
    else:
        return True


def all():
    for i in range(len(list_com)):
        if i != len(list_com) - 1:
            print(list_com[i], end='\n')
        else:
            print(list_com[i])
    return ''


a = '1'
while a != 'exit':
    a = input(colored('>>>', 'green'))
    if a == 'q':
        sys.exit()
    else:
        if not no(a):
            print('Такого раздела не существует!')
        else:
            a += '()'
            print(eval(a))

# TODO: SECTIONS REVOLUTION: разделить graphs2
# TODO: SECTIONS REVOLUTION: разделить geometry (пока делить нечего)

# COMPLETE 1) приколы с парсочем (вершинное покрытие, покрытие путями...)
# COMPLETE 2) Эйлеров путь, Эйлеров цикл + приколы (покрытие путями, например)
# TODO: 3) Геометрия (пересечения всякие, многоугольники, выпуклая оболочка (оба алгоритма))
# TODO: 4) Z-функция с кф
# TODO: 5) Приколы с декомпозицией (всё, что было в ЛКШ)
# COMPLETE 6) Персистентное ДО + задачи на него (k-ая порядковая статистика, кол-во различных...)
# TODO: 7) Приколы с рюкзаком
# TODO: 8) Дп по подмножествам и по поддеревьям (примеры: гамильтонов путь, максимальное паросочетание в дереве, минимальное покрытие...)
# TODO: 9) Convex Hull Trick, матричная оптимизация
# TODO: 10) Расстояние Левенштейна (со стоимостями)
# COMPLETE 11) MITM
# COMPLETE 12) МОСТЫ ПЕРЕДЕЛАТЬ!!!!! + точки сочленения, компоненты вершинной двусвязности
# TODO: 13) 2-SAT
# TODO: 14) Комбинаторику надо написать (а сначала узнать)
# TODO: ~15) Мб, переделать отрицательный цикл
# TODO: ~16) Можно изучить лестничную декомпозицию (не, не надо)
# TODO: ~17) Можно изучить HLD (не, не надо)
# TODO: ~18) Понять DSU on tree (оно же small to large)

