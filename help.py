#-*-coding: utf-8-*-
import sys
from termcolor import colored


def date_time():
    return ('Задачи на дату/время\n'
            '\n'
            'ВРЕМЯ\n'
            '\n'
            'Считывание при вводе:\n'
            'P: h, m, s = [int(i) for i in input().split(\':\')]\n'
            'C: scanf("%d:%d:%d", &h, &m, &s)\n'
            '\n'
            'Перевод из строки в число:\n'
            'P: int(s[0] + s[1])\n'
            'C: (s[0] - \'0\') * 10 + (s[1] - \'0\') # char является числом (кодом символв в ASCII)\n'
            '\n'
            'проще перевести всё в секунды: sec = h * 3600 + m * 60 + s\n'
            '\n'
            'ДАТЫ\n'
            '\n'
            'Считывание, такое же, как во времени\n'
            '\n'
            'Перевод в дни:\n'
            'days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] # можно сделать префиксные суммы\n'
            'd = sum(days[mm - 2]) + dd # может возникнуть проблема с месяцем (если введён первый месяц)\n'
            '\n'
            'Перевод из дней в месяц:\n'
            'i = 0\n'
            'while x > 0:\n'
            '    if x <= days[i]:\n'
            '         print(i + 1)\n'
            '         break\n'
            '    else:\n'
            '         x -= days[i]\n'
            '         i += 1\n'
            '\n'
            'Полный код переводов в C/C++ (високосный год не учитывается):)\n'
            '#include <iostream>\n'
            'using namespace std;\n'
            'int prefDays[12];\n'
            'int days[12] = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n'
            'int dateToDays(int m, int d) {\n'
            '\tint ans = 0;\n'
            '\tif (m > 1) {\n'
            '\t\tint ans = prefDays[m - 2];\n'
            '\t}\n'
            '\tans += d;\n'
            '\t/*for (int i = 0; i <= m - 2; ++i) {\n'
            '\t\tans += days[i];*/\n'
            '\treturn ans;\n'
            '}\n'
            'pair <int, int> daysToDate(int x) {\n'
            '\tint m = 1, d = 0;\n'
            '\tfor (int i = 0; i < 12; ++i) {\n'
            '\t\tif (x <= days[i]) {\n'
            '\t\t\td = x;\n'
            '\t\t\treturn {m, x};\n'
            '\t\t}\n'
            '\t\telse {\n'
            '\t\t\tm++;\n'
            '\t\t\tx -= days[i];\n'
            '\t\t}\n'
            '\t}\n'
            '}\n'
            'int main() {\n'
            '\tprefDays[0] = days[0];\n'
            '\tfor (int i = 1; i < 12; ++i) {\n'
            '\t\tprefDays[i] = prefDays[i - 1] + days[i];\n'
            '\t}\n'
            '}\n'
            '\n'
            'Проверка на високосность года:\n'
            'if year % 400 == 0 or (year % 4 == 0 and year % 100 != 0):\n'
            '    print(\'Yes\')\n'
            'else:\n'
            '    print(\'No\')\n'
            '\n'
            'Посчитать кол-во високосных лет с одного заданного года до другого можно так:\n'
            '(year1 - year2) // 4 - (year1 - year2) // 100 + (year1 - year2) // 400\n'
            '\n'
            'Определение дня недели по номеру дня в году (n - номер дня, ng - день недели 1 января)\n'
            'dn = (ng - 2 + n) % 7 + 1\n')


def combinations_enumeration():
    return ('Один из способов перевода - битовые маски\n'
            'Следующий код выводит все сочетания из 0 и 1 длиной n\n'
            '\n'
            '#include <iostream>\n'
            '\n'
            'using namespace std;\n'
            '\n'
            'int main() {\n'
            '\tint n;\n'
            '\tcin >> n;\n'
            '\tfor (int i = 0; i < (1 << n); ++i) {\n'
            '\t\tfor (int q = 0; q < n; ++q) {\n'
            '\t\t\tif (i & (1 << q)) {\n'
            '\t\t\t\tcout << 1;\n'
            '\t\t\t}\n'
            '\t\t\telse {\n'
            '\t\t\t\tcout << 0;\n'
            '\t\t\t}\n'
            '\t\t}\n'
            '\t\tcout << endl;\n'
            '\t}\n'
            '}\n'
            '\n'
            'Следующий код свыводит все сочетания чисел от start до end длиной n в лексикографическом порядке\n'
            'Python:\n'
            'def gen(left, cur):\n'
            '    if left == 0:\n'
            '        print(*cur)\n'
            '        return\n'
            '    for i in range(start, end + 1):\n'
            '        gen(left - 1, cur + [i])\n'
            '\n'
            '\n'
            'n, start, end = map(int, input().split())\n'
            'gen(n, [])\n'
            '\n'
            'C++:\n'
            '#include <iostream>\n'
            '#include <vector>\n'
            '\n'
            'using namespace std;\n'
            '\n'
            'int n, start, end_;\n'
            '\n'
            'void gen(int left, vector<int> cur) {\n'
            '\tif (left == 0) {\n'
            '\t\tfor (int i : cur) {\n'
            '\t\t\tcout << i << \' \';\n'
            '\t\t}\n'
            '\t\tcout << endl;\n'
            '\t\treturn;\n'
            '\t}\n'
            '\tfor (int i = start; i <= end_; ++i) {\n'
            '\t\tcur.push_back(i);\n'
            '\t\tgen(left - 1, cur);\n'
            '\t\tcur.pop_back();\n'
            '\t}\n'
            '}\n'
            '\n'
            'int main() {\n'
            '\tcin >> n >> start >> end_;\n'
            '\tgen(n, vector<int>{});\n'
            '}\n'
            '\n'
            'Следующий код имеет функцию gen, которая делает то же самое, что и предыдущий код (только без повторений чисел)\n'
            'Также код имеет функию n_permutation (аналог встроенной next_permutation), которая выводит следующую последовательность из цифр в лексикографическом порядке\n'
            '\n'
            '#include <iostream>\n'
            '#include <vector>\n'
            '#include <algorithm>\n'
            '\n'
            'using namespace std;\n'
            '\n'
            'int n;\n'
            '\n'
            'void gen(int left, vector<int> cur, vector<int> been) {\n'
            '\tif (left == 0) {\n'
            '\t\tfor (int i : cur) {\n'
            '\t\t\tcout << i << \' \';\t\t\t\n'
            '\t\t}\n'
            '\t\tcout << endl;\n'
            '\t\treturn;\n'
            '\t}\n'
            '\tfor (int i = 0; i < n; ++i) {\n'
            '\t\tif (!been[i]) {\n'
            '\t\t\tbeen[i] = 1;\n'
            '\t\t\tcur.push_back(i + 1);\n'
            '\t\t\tgen(left - 1, cur, been);\n'
            '\t\t\tcur.pop_back();\n'
            '\t\t\tbeen[i] = 0;\n'
            '\t\t}\n'
            '\t}\n'
            '}\n'
            '\n'
            'void n_permutation(vector<int>& p) {\n'
            '\tint n = p.size();\n'
            '\tfor (int i = n - 1; i > 0; --i) {\n'
            '\t\tif (p[i] > p[i - 1]) {\n'
            '\t\t\tint pos;\n'
            '\t\t\tfor (int j = n - 1; j >= i; --j) {\n'
            '\t\t\t\tif (p[j] > p[i - 1]) {\n'
            '\t\t\t\t\tpos = j;\n'
            '\t\t\t\t\tbreak;\n'
            '\t\t\t\t}\n'
            '\t\t\t}\n'
            '\t\t\tswap(p[pos], p[i - 1]);\n'
            '\t\t\tsort(p.begin() + i, p.end());\n'
            '\t\t\tbreak;\n'
            '\t\t}\n'
            '\t}\n'
            '}\n'
            '\n'
            'int main() {\n'
            '\tcin >> n;\n'
            '\tgen(n, vector<int>{}, vector<int>(n, 0));\n'
            '\t/*vector<int> a = { 3, 1, 5, 2, 7, 6, 4 };\n'
            '\tn_permutation(a);\n'
            '\tfor (int i : a) {\n'
            '\t\tcout << i << \' \';\n'
            '\t}*/\n'
            '}\n')


def binsearch():
    return ('Бинпоиск\n'
            '\n'
            'Смысл бинпоиска - поиск элемента в отсортированном массиве путём деления массива на две части\n'
            'Поэтому сложность бинпоиска - log2(n)\n'
            '\n'
            'Код бинпоиска:\n'
            'l = 0\n'
            'r = 10 ** 100\n'
            'while r - l > 1:\n'
            '    m = (l + r) // 2\n'
            '    if f(m) >= x:\n'
            '        r = m\n'
            '    else:\n'
            '        l = m\n'
            'print(r)\n'
            '\n'
            'f - какая-то функция, x - заданное число\n'
            '\n'
            'При вещественном бинпоиске (с нецелыми числами, заданная точность) можно заменить while на for\n'
            'for будет выполняться math.ceil(math.log2((r - l) * 10000000000))\n'
            'кол-во нулей в последнем числе - точность ответа\n'
            '\n'
            'Всторенный бинпоиск\n'
            'Python:\n'
            'from bisect import bisect_right, bisect_left\n'
            '\n'
            'a = [1, 2, 4, 5, 6, 6, 7, 9]\n'
            'ind = bisect_left(a, 5)\n'
            'ind1 = bisect_right(a, 6)\n'
            'print(ind, ind1)\n'
            ''
            'C++:\n'
            '#include <iostream>\n'
            '#include <algorithm>\n'
            '#include <vector>\n'
            '\n'
            'using namespace std;\n'
            '\n'
            'int main() {\n'
            '\tvector<int> a {1, 2, 4, 5, 6, 6, 7, 9};\n'
            '\tint b[7] = { 2, 4, 4, 6, 8, 8, 9 };\n'
            '\tauto it = lower_bound(a.begin(), a.end(), 5);\n'
            '\tcout << *it << \' \' << it - a.begin() << endl;\n'
            '\tauto it1 = upper_bound(b, b + 7, 6);\n'
            '\tcout << *it1 << \' \' << it1 - b << endl;\n'
            '}\n'
            '\n'
            'bisect_left и lower_bound ищут первый элемент >= заданного\n'
            'bisect_right и upper_bound ищут первый элемент > заданного\n')


def two_pointers():
    return ('Метод двух указателей\n'
            '\n'
            'Смысл метода заключается в закреплении одного элемента отсортированного массива и передвижения второго\n'
            'Стандартный код метода двух указателей:\n'
            'for (int first_point = 0; first_point < len_array; first_point++) {\n'
            '    while (second_point < len_array && <условие>) {\n'
            '        second_point++;\n'
            '    }\n'
            '}\n'
            '\n'
            'Указатели могут относится к разным массивам\n'
            'Указателей может быть больше двух, тогда добавляются циклы while в цикле for (один указатель - один цикл while)\n')


def testing():
    return ('Тестирование\n'
            '\n'
            'В основном, тестирование - это генерация тестов\n'
            'В Python за генерацию отвечает модуль random\n'
            'Основные функции:\n'
            'randint(start, end)      # случайное целое число от start до end включительно\n'
            'choice(l)                # случайный элемент списка l\n'
            'normalvariate(mu, sigma) # нормальное распределение\n'
            'random()                 # случайное число от 0 до 1\n'
            '\n'
            'Некоторые генерации:\n'
            '1. Правильная скобочная последовательность\n'
            'n = int(input())\n'
            'l = 0\n'
            'bal = 0\n'
            's = \'\'\n'
            'for i in range(n):\n'
            '    if not bal:\n'
            '        s += \'(\'\n'
            '        l += 1\n'
            '        bal += 1\n'
            '    elif bal + 1 > n - l - 1:\n'
            '        s += \')\'\n'
            '        l += 1\n'
            '        bal -= 1\n'
            '    else:\n'
            '        par = randint(0, 1)\n'
            '        if not par:\n'
            '            s += \'(\'\n'
            '            l += 1\n'
            '            bal += 1\n'
            '        else:\n'
            '            s += \')\'\n'
            '            l += 1\n'
            '            bal -= 1\n'
            'print(s)\n'
            '\n'
            '2. Массив заданной длины и суммы элементов\n'
            'n = int(input())\n'
            's = int(input())\n'
            'border = []\n'
            'for i in range(n - 1):\n'
            '    border.append(randint(0, s))\n'
            'border.sort()\n'
            'border = [0] + border + [s]\n'
            'a = []\n'
            'for i in range(1, n + 1):\n'
            '    a.append(border[i] - border[i - 1])\n'
            'print(a)\n'
            '\n'
            '3. Массив заданной длины из чисел от 1 до k без повторений\n'
            'n = int(input())\n'
            'k = int(input())\n'
            'if k < 5 * n:\n'
            '    a = list(range(1, k + 1))\n'
            '    shuffle(a)\n'
            '    a = a[:n]\n'
            '    print(a)\n'
            'else:\n'
            '    s = set()\n'
            '    while len(s) < n:\n'
            '        s.add(randint(1, k))\n'
            '    l = list(s)\n'
            '    shuffle(l)\n'
            '    print(l)\n'
            '\n'
            'ТЕСТИРОВНИЕ НЕПРАВИЛЬНОГО РЕШЕНИЯ ПРИ НАЛИЧИИ МЕДЛЕННОГО ПРАВИЛЬНОГО\n'
            'Правильное, но медленное решение - slow.py. Неработающее решение - testme.py\n'
            '\n'
            'Для начала пишем генератор для программ в отдельном файле (например, gen3.py)\n'
            '\n'
            'Теперь нужно написать программу, котрая свяжет всё (генератор, два решения и проверку правильности ответа)\n'
            'Например, run.py\n'
            'Тогда программа run.py будет выглядеть так:\n'
            'import os\n'
            '\n'
            'test = 1\n'
            'while True:\n'
            '    os.system(\'python gen3.py > input\')\n'
            '    os.system(\'python testme.py < input > output\')\n'
            '    os.system(\'python slow.py < input > correct\')\n'
            '    output = [i.strip() for i in open(\'output\').readlines()]\n'
            '    correct = [i.strip() for i in open(\'correct\').readlines()]\n'
            '    if output != correct:\n'
            '        print(\'Error at test\', test)\n'
            '        break\n'
            '    print(\'Test\', test, \'is OK\')\n'
            '    print(\'--------------------\')\n'
            '    test += 1\n'
            '\n'
            '< и > перенаправляют вывод в файл\n'
            'Тест, неправильный и правильный ответ можно будет посмотреть после тестирования в файлах input, output и correct\n')


def hashes():
    return ('Хэши\n'
            '\n'
            'Идеальный хэш - это тот хэш, который удовлетворяет равенствам:\n'
            'x = y => H(x) = H(y)\n'
            'x ≠ y => H(x) ≠ H(y)\n'
            'Но представленный ниже алгоритм - это неидеальный хэш\n'
            '\n'
            'Один из алгоритмов хэширования:\n'
            'Присутствуют два параметра: p и mod\n'
            'p <= 300\n'
            'mod ** 2 должен влезать в long long и желательно быть простым числом\n'
            'популярные mod: 10 ** 9 + 7; 10 ** 9 + 9; 2 * 10 ** 9 + 11\n'
            'но популярные mod лучше не использовать\n'
            'Также лучше в начале программы выбирать параметры из списка, используя random\n'
            '\n'
            'Номер каждого элемента в ASCII умножается на соответствующую степень числа p, затем произведения складываются, и находится остаток от деления на mod\n'
            'Example:\n'
            'H(\'abac\') = (ord(\'a\') * p ** 3 + ord(\'b\') * p ** 2 + ord(\'a\') * p ** 1 + ord(\'c\')) % mod\n'
            '\n'
            'Но, т.к. данный хэш неидеален, можно делать двойной, тройной и т.д. хэш (деать к одной строке несколько хэшей с разными p и mod)\n'
            '\n'
            'Код такого хэширования на C++:\n'
            'long long getHash(const string& s, int p, long long mod) {\n'
            '    long long H = 0;\n'
            '    for (auto& c : s) {\n'
            '        H = (H * p + c) % mod;\n'
            '    }\n'
            '    return H;\n'
            '}\n'
            '\n'
            'Гораздо полезнее хранить хэши префиксов строки. Код на C++:\n'
            'vector <long long> getHash(const string& s, int p, long long mod) {\n'
            '\tvector<long long> ans(s.size());\n'
            '\tans[0] = s[0];\n'
            '\tfor (size_t i = 1; i < s.size(); ++i) {\n'
            '\t\tans[i] = (ans[i - 1] * p + s[i]) % mod;\n'
            '\t}\n'
            '\treturn ans;\n'
            '}\n'
            '\n'
            'Благодаря нахождению хэшей префиксов, можно искать хэши подстрок\n'
            'Код:\n'
            'long long subHash(int l, int r, long long mod) {\n'
            '\tlong long big = H[r];\n'
            '\tlong long small = 0;\n'
            '\tif (l != 0) {\n'
            '\t\tsmall = (H[l - 1] * st[r - l + 1]) % mod;\n'
            '\t}\n'
            '\treturn (big - small + mod) % mod;\n'
            '}\n'
            'st - список степеней p, H - список хэшей префиксов\n'
            '\n'
            'Что можно делать с хэшами:\n'
            '# Можно найти подстроку в строке (найти её хэш и посмотреть все хэши подстрок такой же длины)\n'
            '\n'
            '# Найти циклический сдвиг\n'
            '  Дано две строки. Вторая - циклический сдвиг первой\n'
            '  n - длина строки, k - сдвиг\n'
            '  Можно умножить первую строку на две, тогда она будет выглядеть так:\n'
            '  n - k   k   n - k   k\n'
            '  Вторая строка выглядит так:\n'
            '  k   n - k\n'
            '  Теперь можно найти вхождение второй строки в первую\n'
            '\n'
            '# Проверка подстроки на палиндром\n'
            '  Для этого нужно найти хэш подстроки и её обратный хэш (хэш перевёрнутой строки)\n'
            '  После этого проверить равенство хэшей\n'
            '\n'
            '# Проверка на период (можно ли разбить на одинаковые блоки длиной k)\n'
            '  Сначала нужно проверить, делится ли длина строки на k\n'
            '  Дальше нужно сравнить хэши строк от второго до последнего блока и от первого до предпоследнего\n'
            '  s[:n - k] и s[k + 1:]\n'
            '\n'
            '# Минимальный период строки\n'
            '  Нужно разложить длину строки на множители и увеличивать значение, пока строка яаляется периодом (делить на всё большее значение)\n'
            '\n'
            '# Сравнение строк\n'
            '  Нужно найти самый большой общий префикс, а потом сравнить символы после него\n'
            '  Длину префикса можно найти бинпоиском\n'
            '\n'
            '# Поиск подпалиндромов\n'
            '  Палиндром может быть нечётной длины (центр - символ) и чётной (центр между символами)\n'
            '  Можно пройти по строке, смотря на символы и промежутки между символами. Таким образом мы перебираем центр палиндрома\n'
            '  От каждого центра мы будем расширять строку, пока эта строка является палиндромом (проверка делается хэшами)\n'
            '\n'
            '  Но поиск палиндромов можно осуществить быстрее, проще и без хэшей с использованием Алгоритма Манакера\n'
            '  (раздел Manacher)\n'
            '\n'
            '# z-функция\n'
            '  z-функция - это поиск максимального числа l, такого, что подстрока, начинающаяся в i и длиной l, равна префиксу длины l\n'
            '  l можно искать бинпоиском, а сравнивать строки - хэшами\n'
            '\n'
            '  Но z-функцию можно написать проще и без хэшей\n'
            '  (раздел z_function)\n')


def z_function():
    return ('Z-функция\n'
            '\n'
            'Z-функция для индекса i ищет максимальное число l, такое, что подстрока, начинающаяся в i и длиной l, равна префиксу длины l\n'
            '\n'
            'Z-функция может быть использована для проверки вхождения подстроки в строку (нужно дописать к меньшей строке символ, которого нет в обоих строках, и большую строку)\n'
            'тогда, посчитав z-функцию от получившейся строки можно будет найти все вхождения первой строки во вторую\n'
            '\n'
            'Z-функция может быть реализована по-разному\n'
            'Основные способы:\n'
            '1. Хэши (описано в hashes)\n'
            '2. Алгоритм, вычисляющий следующие значения, используя уже вычисленные значения\n'
            '\n'
            'Рассмотрим второй алгоритм\n'
            '\n'
            'Следующие значения вычисляются на основе предыдущих\n'
            'Хранятся границы такого z-блока, правая граница которого максимальна\n'
            '(z-блок - подстрока с началом в i и максимальной длиной l (значение z-функции для i))\n'
            '\n'
            'Есть два случая:\n'
            '1. i не лежит в сохранённом блоке (тогда нужно наивно пройти по строке и сравнить)\n'
            '2. i лежит в сохранённом блоке (тогда есть два случая)\n'
            '   2.1 z[i - left] + i > right (тогда нужно наивно пройти по строке от r и сравнить)\n'
            '   2.2. z[i - left] + i <= right (тогда уже известно значение, оно равно z[i - left])\n'
            '\n'
            'Реализация такого алгоритма:\n'
            'C++:\n'
            'vector<int> z_f(string s) {\n'
            '\ts += \'$\';\n'
            '\tint l = 0;\n'
            '\tint r = 0;\n'
            '\tvector <int>z(s.size(), 0);\n'
            '\tfor (int i = 1; i < s.size(); ++i) {\n'
            '\t\tz[i] = max(0, min(z[i - l], r - i));\n'
            '\t\twhile (s[z[i]] == s[i + z[i]]) {\n'
            '\t\t\tz[i]++;\n'
            '\t\t}\n'
            '\t\tif (z[i] + i > r) {\n'
            '\t\t\tl = i;\n'
            '\t\t\tr = z[i] + i;\n'
            '\t\t}\n'
            '\t}\n'
            '\tz.pop_back();\n'
            '\treturn z;\n'
            '}\n'
            '\n'
            'Python:\n'
            'def z_f(s):\n'
            '    s += \'$\'\n'
            '    l, r = 0, 0\n'
            '    z = [0] * len(s)\n'
            '    for i in range(1, len(s)):\n'
            '        z[i] = max(0, min(z[i - l], r - i))\n'
            '        while s[z[i]] == s[i + z[i]]:\n'
            '            z[i] += 1\n'
            '        if i + z[i] > r:\n'
            '            l, r = i, i + z[i]\n'
            '    return z[:-1]\n')


def Manacher():
    return ('Алгоритм Манакера\n'
            '\n'
            'Алгоритм Манакера позволяет находить для каждого элемента строки максимальную длину подстроки-палиндрома с центром в этом элементе\n'
            '\n'
            'Алгоритм возвращает два массива половин длин палиндромов (для чётных и нечётных палиндромов)\n'
            'Благодаря этому можно легко найти общее кол-во палиндромов в строке, сложив все значения двух массивов\n'
            '\n'
            'Реализация Алгоритма Манакера схожа с реализацией оптимального алгоритма нахождения z-функции\n'
            'Следующие значения вычисляются на основе предыдущих и хранятся границы палиндрома, правая граница которого максимальна\n'
            '\n'
            'Есть 2 случая:\n'
            '1. Следующий элемент лежит в сохранённом палиндроме (тогда находится зеркальное значение и выполняется наивный алгоритм)\n'
            '2. Слудующий элемент не лежит в сохранённом палиндроме (наивный алгоритм)\n'
            '\n'
            'Реализация на C++:\n'
            'vector<int> one(string s) {\n'
            '\tint n = s.length();\n'
            '\tvector<int> d1(n);\n'
            '\tfor (int i = 0, l = 0, r = -1; i < n; i++) {\n'
            '\t\tint k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\n'
            '\t\twhile (0 <= i - k && i + k < n && s[i - k] == s[i + k]) {\n'
            '\t\t\tk++;\n'
            '\t\t}\n'
            '\t\td1[i] = k--;\n'
            '\t\tif (i + k > r) {\n'
            '\t\t\tl = i - k;\n'
            '\t\t\tr = i + k;\n'
            '\t\t}\n'
            '\t}\n'
            '\treturn d1;\n'
            '}\n'
            '\n'
            'vector<int> two(string s) {\n'
            '\tint n = s.length();\n'
            '\tvector<int> d2(n);\n'
            '\tfor (int i = 0, l = 0, r = -1; i < n; i++) {\n'
            '\t\tint k = (i > r) ? 0 : min(d2[l + r - i + 1], r - i + 1);\n'
            '\t\twhile (0 <= i - k - 1 && i + k < n && s[i - k - 1] == s[i + k]) {\n'
            '\t\t\tk++;\n'
            '\t\t}\n'
            '\t\td2[i] = k--;\n'
            '\t\tif (i + k > r) {\n'
            '\t\t\tl = i - k - 1;\n'
            '\t\t\tr = i + k;\n'
            '\t\t}\n'
            '\t}\n'
            '\treturn d2;\n'
            '}\n'
            '\n')


def segment_tree():
    return ('Дерево отрезков\n'
            '\n'
            'Внимание! В данном разделе представлена не вся информация о дереве отрезков.\n'
            'Здесь не описаны нерекурсивное создание дерва и запросы, массовые операции, persistent-структуры и некоторые методы.\n'
            '\n'
            'Дерево отрезков - это мощная структура, позволяющая хранить нужную информацию о всех отрезках массива.\n'
            '\n'
            'Хранение информации производится следующим образом:\n'
            'корень дерева - весь отрезок\n'
            'от корня отходят два сына (отрезок от 0 до n // 2 и отрезок от n // 2 + 1 до n)\n'
            'от каждого сына отходят два таких же сына - первая и вторая половина отрезка\n'
            'отрезки в листьях имеют длину 1\n'
            '\n'
            'Ответ на одном отрезке складывается из ответов на его сыновьях, ответы в которых складываются из их сыновей и т.д.\n'
            '\n'
            'Для удобства будем хранить дерево в виде массива, где сыновья вершины v находятся в индексах v * 2 и v * 2 + 1\n'
            '\n'
            'НЕКОТОРЫЕ МЕТОДЫ:\n'
            'запускать построение из основной программы нужно так: build(a, 1, 0, len(a) - 1)\n'
            '\n'
            '# Построение для суммы\n'
            'def build1(a, v, tl, tr):\n'
            '    if tl == tr:\n'
            '        t[v] = a[tl]\n'
            '    else:\n'
            '        tm = (tl + tr) // 2\n'
            '        build1(a, v * 2, tl, tm)\n'
            '        build1(a, v * 2 + 1, tm + 1, tr)\n'
            '        t[v] = t[v * 2] + t[v * 2 + 1]\n'
            '\n'
            '\n'
            '# Сумма элементов отрезка\n'
            'def sum(v, tl, tr, l, r):\n'
            '    if l > r:\n'
            '        return 0\n'
            '    if tl == l and tr == r:\n'
            '        return t[v]\n'
            '    tm = (tl + tr) // 2\n'
            '    return sum(v * 2, tl, tm, l,  min(r, tm)) + sum(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r)\n'
            '\n'
            '\n'
            '# Обновление одного элемента\n'
            'def update1(v, tl, tr, pos, new_val):\n'
            '    if tl == tr:\n'
            '        t[v] = new_val\n'
            '    else:\n'
            '        tm = (tl + tr) // 2\n'
            '        if pos <= tm:\n'
            '            update1(v * 2, tl, tm, pos, new_val)\n'
            '        else:\n'
            '            update1(v * 2 + 1, tm + 1, tr, pos, new_val)\n'
            '        t[v] = t[v * 2] + t[v * 2 + 1]\n'
            '\n'
            '\n'
            '# Построение для нахождения минимума/максимума (min или max)\n'
            'def build2(a, v, tl, tr):\n'
            '    if tl == tr:\n'
            '        t[v] = a[tl]\n'
            '    else:\n'
            '        tm = (tl + tr) // 2\n'
            '        build2(a, v * 2, tl, tm)\n'
            '        build2(a, v * 2 + 1, tm + 1, tr)\n'
            '        t[v] = min(t[v * 2], t[v * 2 + 1])\n'
            '\n'
            '\n'
            '# Минимум на отрезке (при build2)\n'
            'def min_(v, tl, tr, l, r):\n'
            '    if l > r:\n'
            '        return 1000000\n'
            '    if tl == l and tr == r:\n'
            '        return t[v]\n'
            '    tm = (tl + tr) // 2\n'
            '    return min(min_(v * 2, tl, tm, l,  min(r, tm)), min_(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r))\n'
            '\n'
            '\n'
            '# Максимум на отрезке (при build2)\n'
            'def max_(v, tl, tr, l, r):\n'
            '    if l > r:\n'
            '        return -1000000\n'
            '    if tl == l and tr == r:\n'
            '        return t[v]\n'
            '    tm = (tl + tr) // 2\n'
            '    return max(max_(v * 2, tl, tm, l,  min(r, tm)), max_(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r))\n'
            '\n'
            '\n'
            '# Функция для построения и запроса (можно изменить для своих нужд)\n'
            'def combine(a, b):\n'
            '    if a[0] > b[0]:\n'
            '        return a\n'
            '    else:\n'
            '        return b\n'
            '\n'
            '\n'
            '# Построение для нахождения минимума/максимума и его индекса\n'
            'def build3(a, v, tl, tr):\n'
            '    if tl == tr:\n'
            '        t[v] = [a[tl], tl]\n'
            '    else:\n'
            '        tm = (tl + tr) // 2\n'
            '        build3(a, v * 2, tl, tm)\n'
            '        build3(a, v * 2 + 1, tm + 1, tr)\n'
            '        t[v] = combine(t[v * 2], t[v * 2 + 1])\n'
            '\n'
            '\n'
            '# Нахождение минимума/максимума и его индекса (при build3)\n'
            'def get_max(v, tl, tr, l, r):\n'
            '    if l > r:\n'
            '        return [-1000000, 0]\n'
            '    if l == tl and r == tr:\n'
            '        return t[v]\n'
            '    tm = (tl + tr) // 2\n'
            '    return combine(get_max(v * 2, tl, tm, l,  min(r, tm)), get_max(v * 2 + 1, tm + 1, tr, max(l, tm + 1), r))\n'
            '\n'
            'Обновление одного элемента для разных методов построения очень похоже (нужно просто заменить на нужную функцию)\n'
            '\n'
            'Дерево отрезков - структура, поддерживающая обновление. Существует структура, работающая за меньшее время, но не поддерживающая обновление - разреженная таблица (см. раздел sparse_table)\n')


def sparse_table():
    return ('Разреженная таблица (sparse table)\n'
            '\n'
            'Sparse table - структура, позволяющая хранить и получать нужную информацию о всех отрезках массива\n'
            'Sparse table - это двумерный массив, который хранит информацию о всех отрезках, длины которых равны степеням двойки\n'
            '\n'
            'таблица выглядит так:\n'
            '       степени\n'
            '    |0 1 2 3 4 5\n'
            '-----------------\n'
            'и 0 |             \n'
            'н 1 |  ч           \n'
            'д 2 |    и         \n'
            'е 3 |      с       \n'
            'к 4 |        л     \n'
            'с 5 |          а   \n'
            '\n'
            'Сверху - степени двойки, слева - индекс начала отрезка (индекс первого элемента отрезка)\n'
            '\n'
            'ПОСТРОЕНИЕ SPARSE TABLE ДЛЯ RMQ\n'
            'Sparse table хорошо использовать для решения задачи RMQ (Range Minimum Query) (off-line!!!)\n'
            '\n'
            'Для построения потребуются логарифмы, их можно предпосчитать\n'
            'int log[n + 1];\n'
            'log[1] = 0;\n'
            'for (int i = 2; i <= n; i++)\n'
            '    log[i] = log[i / 2] + 1;\n'
            '\n'
            'Теперь само построение\n'
            'Сначала мы присваиваем таблице значения первого столбца (2 ^ 0)\n'
            'Поиск следующих значений производится через сравнение предыдущих\n'
            'K - это число, примерно равное log2 из n (25 - хорошее значение)\n'
            'int st[n][K];\n'
            '\n'
            'for (int i = 0; i < n; i++)\n'
            '    st[i][0] = array[i];\n'
            '\n'
            'for (int j = 1; j <= K; j++)\n'
            '    for (int i = 0; i + (1 << j) <= n; i++)\n'
            '        st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n'
            '\n'
            'Теперь сам запрос (за O(1))\n'
            'Мы находим два пересекающихся отрезка, которые покрывают весь нужный нам отрезок, и находим минимум из минимумов на этих отрезках\n'
            'int j = log[R - L + 1];\n'
            'int minimum = min(st[L][j], st[R - (1 << j) + 1][j]);\n'
            '\n'
            'У нас получилось ответить на RMQ быстро, потому что min - идемпотентая функция\n'
            'f называется идемпотентой, если f(a, a) == a\n'
            '\n')


def bit_operations():
    return ('Битовые операции\n'
            '\b'
            'битовые операции значительно упрощают и ускоряют написание и работу некоторых алгоритмов, функций\n'
            '\n'
            '| - or\n'
            '& - and\n'
            '~ - not\n'
            '^ - xor\n'
            '>>, << - битовый сдвиги\n'
            'в основном биты считаютя справа налево\n'
            '\n'
            '1 << c                  # 2 в степени c\n'
            'x | (1 << n)            # установление n-ого бита в 1\n'
            'x & ~(1 << n)           # установление n-ого бита в 0\n'
            'x ^ (1 << n)            # инвертирование n-ого бита\n'
            'n << 1                  # умножение на 2\n'
            'n >> 1                  # целая часть от деления на 2\n'
            'n << m                  # умножение на 2^m\n'
            'n >> m                  # целая часть от деления на 2^m\n'
            '(a ^ b) == 0            # проверка на равенство\n'
            '(n & 1) == 1            # проверка на чётность\n'
            'int(bool(x & (1 << n))) # определение n-ого бита\n'
            '(x + y) >> 1            # среднее арифметическое (целое)\n')


def f_Euler():
    return ('Функия Эйлера\n'
            '\n'
            'Функция Эйлера вычисляет кол-во чисел от 1 до n, взаимно простых с n\n'
            '\n'
            'def fi(n):\n'
            '    ans = n\n'
            '    i = 2\n'
            '    while i * i <= n:\n'
            '        if n % i == 0:\n'
            '            while n % i == 0:\n'
            '                n //= i\n'
            '            ans -= ans // i\n'
            '        i += 1\n'
            '    if n > 1:\n'
            '        ans -= ans // n\n'
            '    print(ans)\n'
            '\n'
            'Асимптотика - O(sqrt(n))\n')


def quick_pow():
    return ('Быстрое возведение в степень\n'
            '\n'
            'def quick_pow(x, y):\n'
            '    if not y:\n'
            '        return 1\n'
            '    if not y % 2:\n'
            '        ans = quick_pow(x, y // 2)\n'
            '        return ans * ans\n'
            '    return quick_pow(x, y - 1) * x\n'
            '\n'
            'Асимптотика - O(log n)\n')

def graphs():
    return ('Графы\n'
            '\n'
            'ХРАНЕНИЕ\n'
            'Графы можно хранить 3 способами:\n'
            '1. Матрица смежности (таблица из 0 и 1 (или из длин ребёр), где\n'
            '                     m[i][j] = 1, если есть ребро между i и j\n'
            '                     m[i][j] = 0, если нет ребра между i и j\n'
            '2. Список ребёр (пара (i, j) означает, что есть ребро между i и j)\n'
            '3. Список смежности (каждый элемент списка i - это список вершин j1, j2..., у которых есть ребро с i\n'
            '\n'
            'BFS\n'
            'BFS - это обход графа в ширину\n'
            'Из одной вершины алгоритм идёт во все вершины, у которых есть ребро с этой вершиной\n'
            '\n'
            'Код:\n'
            'def bfs(g, s):\n'
            '    """\n'
            '    Algorithm BFS\n'
            '    :param g: graph (list of adjacencies)\n'
            '    :param s: start vertex\n'
            '    :return: p: list required to restore the path\n'
            '             d: list of shortest paths\n'
            '             used: list of used vertex\n'
            '    """\n'
            '    n = len(g)\n'
            '    q = deque()\n'
            '    used = [False] * n\n'
            '    used[s] = True\n'
            '    p = [0] * n\n'
            '    d = [0] * n\n'
            '    p[s] = -1\n'
            '    q.append(s)\n'
            '    while q:\n'
            '        v = q.popleft()\n'
            '        for i in range(len(g[v])):\n'
            '            to = g[v][i]\n'
            '            if not used[to]:\n'
            '                used[to] = True\n'
            '                q.append(to)\n'
            '                d[to] = d[v] + 1\n'
            '                p[to] = v\n'
            '    return p, d, used\n'
            '\n'
            '\n'
            'def path(p, s, to, used):\n'
            '    """\n'
            '    Restore the shortest path\n'
            '    :param p: list required to restore the path\n'
            '    :param s: start vertex\n'
            '    :param to: finish vertex\n'
            '    :param used: list of used vertex\n'
            '    :return: the shortest path (list)\n'
            '    """\n'
            '    if not used[to]:\n'
            '        return [-1]\n'
            '    else:\n'
            '        path_list = []\n'
            '        v = to\n'
            '        while v != -1:\n'
            '            v = p[v]\n'
            '            path_list.append(v)\n'
            '        path_list = path_list[::-1]\n'
            '        # Mb return path_list[1:] + [to] ([to + 1])\n'
            '        return [s + 1] + path_list[1:-1] + [to + 1]\n'
            '\n'
            'Функция path восстанавливает кратчайший путь между двумя вершинами\n'
            '\n'
            'DFS\n'
            'DFS - это обход графа в глубину\n'
            'Алгоритм спускается вниз по графу, пока может, потом поднимается и снова пытается спуститься\n'
            '\n'
            'Код:\n'
            'def dfs(v):\n'
            '    time_in[v] = dfs_timer\n'
            '    dfs_timer += 1\n'
            '    color[v] = 1\n'
            '    for i in graph[v]:\n'
            '        if not color[i]:\n'
            '            dfs(i)\n'
            '    color[v] = 2\n'
            '    time_out[v] = dfs_timer\n'
            '    dfs_timer += 1\n'
            'time_in = [0] * N\n'
            'time_out = [0] * N\n'
            'color = [0] * N\n'
            'dfs_timer = 0\n'
            '\n'
            'color хранит цвета вершин (0 - непосещённая, 1 - текущая, 2 - из этой вершины уже вышли)\n'
            'time_in хранит веремя входа в каждую вершину\n'
            'time_out хранит время выхода из каждой вершины\n'
            '\n'
            'НЕКОТОРЫЕ ЗАДАЧИ\n'
            '1. Раскраска графа в 2 цвета\n'
            'Граф можно раскрасить в 2 цвета, если он двудолен\n'
            'Эту задачу можно решить жадным алгоритмом (просто попробовать раскрасить в 2 цвета) и dfs\n'
            'Код:\n'
            'def dfs_2col(v, cur_col):\n'
            '    color[v] = 1\n'
            '    col2[v] = cur_col\n'
            '    for i in g[v]:\n'
            '        if not color[i]:\n'
            '            if cur_col:\n'
            '                dfs_2col(i, 0)\n'
            '            else:\n'
            '                dfs_2col(i, 1)\n'
            '    color[v] = 2\n'
            'def check_2col(v):\n'
            '    used2[v] = True\n'
            '    for i in g[v]:\n'
            '        if col2[v] == col2[i]:\n'
            '            return False\n'
            '        if not used2[i]:\n'
            '            check_2col(i)\n'
            'g = []\n'
            'n = int(input())\n'
            'color = [0] * n\n'
            'col2 = [-1] * n\n'
            'used2 = [False] * n\n'
            'is2 = False\n'
            'for i in range(n):\n'
            '    a = [int(i) for i in input().split()]\n'
            '    g.append(a)\n'
            'dfs_2col(0, 0)\n'
            'ch = check_2col(0)\n'
            'if ch is None:\n'
            '    print(\'Yes\')\n'
            'else:\n'
            '    print(\'No\')\n'
            '\n'
            '2. Нахождение цикла в неориентрированном графе\n'
            'Чтобы найти цикл можно запустить dfs\n'
            'Если мы находим вершину, которая уже посещена, и мы не пришли из неё, то цикл найден\n'
            '\n'
            '3. Нахождение цикла в ориентированном графе\n'
            'Красим граф в 3 цвета:\n'
            'Заходим в вершину, её цвет равен 1\n'
            'Проходим по всем смежным вершинам\n'
            'Если цвет смежной вершины равен 0, то запускаем dfs из неё\n'
            'Если цвет равен 1, то мы нашли цикл\n'
            'После цикла присваиваем вершине цвет 2\n'
            '\n'
            '4. Нахождение диаметра дерева (самый длинный путь)\n'
            'Функция maxlen:\n'
            '   Будем запускать dfs и запоминать расстояния от начальной вершины до всех остальных\n'
            '   Потом выведем позизицию максимума в списке этих расстояний\n'
            'Теперь два раза запустим функцию\n'
            'Первый раз (v1) от 0\n'
            'Второй раз (v2) от v1\n'
            '(v1, v2) - это ответ (пара вершин)\n'
            '\n'
            '5. 0-1 BFS\n'
            'Есть модификация BFS для графа с рёбрами 0 и 1\n'
            'Если ребро до вершины 0, то мы кладём вершину в начало дека (deque)\n'
            'Если ребро до вершины 1, то мы кладём вершину в конец дека\n'
            '\n'
            '6. 0-k BFS\n'
            'BFS может заменить Дейкстру при небольших k\n'
            'Мы имеем k+1 очередь, одна из них текущая (расстояние d)\n'
            'Если мы находим вершину c расстоянием x, то мы кладём её в очердь с вершинами d+x\n'
            'Когда текущая очередь заканчивается, мы переходим в очередь d+1, а прошлая очередь становится максимальной\n'
            'Пример:\n'
            'Максимум был d+5\n'
            'Текущая очередь d закончилась\n'
            'Мы переходим в очередь d+1, а прошлая очередь теперь равна d+6\n'
            '\n'
            'МОСТЫ\n'
            'Мост - это ребро неориентрированного графа, при удалении которого увеличится кол-во компонент связности\n'
            'Найти мосты можно с помощью dfs\n'
            'Обход dfs - это остовное дерево графа\n'
            'Нам нужно искать обратные рёбра\n'
            'Код:\n'
            'struct Edge {\n'
            '    int u, v;\n'
            '    int num;\n'
            '    bool isbridge;\n'
            '    Edge *back;\n'
            '    Edge(int u, int v, int num):u(u), v(v), num(num), isbridge(false) {}\n'
            '};\n'
            '\n'
            'int n, m;\n'
            'vector<vector<Edge*>> gr;\n'
            'vector<bool> used;\n'
            'vector<int> d;\n'
            'vector<int> dp;\n'
            '\n'
            'void dfs(int v, int p = -1, int num_e = -1) {\n'
            '    if (p == -1)\n'
            '        d[v] = 0;\n'
            '    else\n'
            '        d[v] = d[p] + 1;\n'
            '    used[v] = true;\n'
            '    dp[v] = d[v];\n'
            '    for (auto e : gr[v]) {\n'
            '        if (!used[e->v]) {\n'
            '            dfs(e->v, v, e->num);\n'
            '            dp[v] = min(dp[v], dp[e->v]);\n'
            '        }\n'
            '        else if (e->num != num_e)\n'
            '            dp[v] = min(dp[v], dp[e->v]);\n'
            '    }\n'
            '    if (dp[v] < d[v])\n'
            '        for (auto e : gr[v]) {\n'
            '            if (e->num == num_e) {\n'
            '                e->isbridge = true;\n'
            '                e->back->isbridge = true;\n'
            '            }\n'
            '        }\n'
            '}\n'
            '\n'
            'int main() {\n'
            '    fastIO;\n'
            '    cin >> n >> m;\n'
            '    gr.resize(n);\n'
            '    used.resize(n);\n'
            '    d.resize(n);\n'
            '    dp.resize(n);\n'
            '    for (int i = 0; i < m; i++) {\n'
            '        int u, v;\n'
            '        cin >> u >> v;\n'
            '        u--;\n'
            '        v--;\n'
            '        Edge *e1 = new Edge(u, v, i);\n'
            '        Edge *e2 = new Edge(v, u, i);\n'
            '        e1->back = e2;\n'
            '        e2->back = e1;\n'
            '        gr[u].push_back(e1);\n'
            '        gr[v].push_back(e2);\n'
            '    }\n'
            '    dfs(0);\n'
            '    return 0;\n'
            '}\n'
            '\n'
            'С мостами связана ребёрная двусвязность (из одной вершины существует два пути до другой)\n'
            'Можно искать компоненты рёберной двусвязности:\n'
            'Сначала ищем мосты\n'
            'Потом проходим dfs по графу, не проходя по мостам, и ищем компоненты связности\n'
            'Полученные компоненты будут компонентами двусвязности\n'
            '\n'
            'ТОПОЛОГИЧЕСКАЯ СОРТИРОВКА\n'
            'Топологическая сортировка применяется на ориентированных графах'
            'Результат сортировки - массив вершин, в котором выполняется условие "рёбра идут только вправо" (рёбра идут от вершин в начале к вершинам в конце)\n'
            'Сортировка невозможна в графе с циклами\n'
            '\n'
            'Сортировка пишется с использованием dfs\n'
            'Код:\n'
            'void dfs (int v) {\n'
            '    used[v] = true;\n'
            '    for (size_t i=0; i<g[v].size(); ++i) {\n'
            '        int to = g[v][i];\n'
            '        if (!used[to])\n'
            '            dfs (to);\n'
            '    }\n'
            '    ans.push_back (v);\n'
            'reverse(ans.begin(), ans.end())\n'
            '\n'
            'КОНДЕНСАЦИЯ\n'
            'Компонента сильной связности в ориентированном графе - это множество вершин, в котором от любой вершины можно добраться до любой другой\n'
            'Конденсация - это сжатие компонент сильной связности (компонента превращается в вершину), оставляются только рёбра, соединяющие компоненты\n'
            'После конденсации граф будет обязательно ацикличен\n'
            '\n'
            'Вывод компонент сильной связности:\n'
            'Первый шаг: топологическая сортировка графа\n'
            'Второй шаг: dfs по транспонированному графу, испольуя вершины из списка топологической сортировки\n'
            'Код:\n'
            'int n, m;\n'
            'vector<bool> used;\n'
            'vector<vector<int>> g, gr;\n'
            'vector<int> ts, comp;\n'
            '\n'
            'void dfs_ts(int v) {\n'
            '    used[v] = true;\n'
            '    for (int u : g[v])\n'
            '        if (!used[u])\n'
            '            dfs_ts(u);\n'
            '    ts.push_back(v);\n'
            '}\n'
            '\n'
            'void top_sort() {\n'
            '    used.assign(n, false);\n'
            '    for (int u = 0; u < n; u++)\n'
            '        if (!used[u])\n'
            '            dfs_ts(u);\n'
            '    reverse(ts.begin(), ts.end());\n'
            '}\n'
            '\n'
            'void dfs_con(int v) {\n'
            '    used[v] = true;\n'
            '    comp.push_back(v);\n'
            '    for (int u : gr[v])\n'
            '        if (!used[u])\n'
            '            dfs_con(u);\n'
            '}\n'
            '\n'
            'int main() {\n'
            '    fastIO;\n'
            '    int u, v;\n'
            '    cin >> n >> m;\n'
            '    used.resize(n);\n'
            '    g.resize(n);\n'
            '    gr.resize(n);\n'
            '    ts.resize(0);\n'
            '    comp.resize(0);\n'
            '    fori(0, m) {\n'
            '        cin >> u >> v;\n'
            '        u--;\n'
            '        v--;\n'
            '        g[u].push_back(v);\n'
            '        gr[v].push_back(u);\n'
            '    }\n'
            '    top_sort();\n'
            '    used.assign(n, false);\n'
            '    for (int ve : ts) {\n'
            '        if (!used[ve]) {\n'
            '            dfs_con(ve);\n'
            '            printa(comp);\n'
            '            comp.clear();\n'
            '        }\n'
            '    }\n'
            '    return 0;\n'
            '}\n'
            'Примечание: printa - вывод массива, fori(0, n) - цикл от 0 до n\n'
            '\n'
            'ОСТОВНЫЕ ДЕРЕВЬЯ\n'
            'Остовное дерево - это минимальный граф, соединяющий все вершины исходного графа\n'
            'Минимальное остовное дерево (в взвешенном графе) - это граф, соединяющий все вершины исходного графа и имеющий наименьшую длину\n'
            '\n'
            'Для создания остовных деревьев используется структура СНМ (система непересекающихся множеств)\n'
            'Сначала все множества - это изолированные вершины с петлями\n'
            'Каждая вершина хранит предка\n'
            'Чтобы соединить две вершины достаточно изменить у одной из них предка\n'
            'Чтобы проверить, есть ли путь между двумя вершинами, нужно посмотреть, есть ли у них общий предок\n'
            '\n'
            'Код:\n'
            'vector<int> p, d;\n'
            '\n'
            'void init(int n) {\n'
            '    p.resize(n);\n'
            '    d.resize(n);\n'
            '    for (int i = 0; i < n; ++i) {\n'
            '        p[i] = i;\n'
            '        d[i] = 0;\n'
            '    }\n'
            '}\n'
            '\n'
            'int get_par(int v) {\n'
            '    if (p[v] == v) {\n'
            '        return v;\n'
            '    }\n'
            '    return p[v] = get_par(p[v]);\n'
            '}\n'
            '\n'
            'void unite(int u, int v) {\n'
            '    u = get_par(u);\n'
            '    v = get_par(v);\n'
            '    if (u != v) {\n'
            '        if (d[u] > d[v]) {\n'
            '            swap(u, v);\n'
            '        }\n'
            '        p[u] = v;\n'
            '        if (d[u] == d[v]) {\n'
            '            d[v]++;\n'
            '        }\n'
            '    }\n'
            '}\n'
            '\n'
            'Минимальное остовное дерево строится так же, только вначале список рёбер сортируется, добавляются минимальные рёбра\n'
            'В конце нужно проверить, сколько ребёр в структуре. Если кол-во рёбер != n - 1, то граф несвязный, остовное дерево не построено\n'
            '\n'
            'Также можно строить несколько минимальных остовных деревьев\n'
            'Сначала нужно постороить минимальное дерево, а потом в цикле убирать по одному (или больше, если нужно много деревьев) ребру из дерева и заменять его другим в списке рёбер\n'
            'В конце нужно проверять существование нового остовного дерева (написано выше)\n'
            '\n'
            'СНМ позволяет считать минимум, максимум, сумму и т.п. у нескольких множеств (нужно добавить код в unite)\n')


def eratosthenes_sieve():
    return ('N = int(input())                           # До какого числа мы ищем простые числа\n'
            'isPrime = [True] * (N + 1)                 # Создание списка из True\n'
            'Primes = []                                # Список, в котором будут простые числа\n'
            'for d in range(2, N + 1):\n'
            '    if isPrime[d]:\n'
            '        Primes.append(d)\n'
            '        for i in range(d ** 2, N + 1, 2): # Убираем лишние числа\n'
            '            isPrime[i] = False\n'
            'print(Primes)\n'
            '\n'
            'Алгоритм выше работает за O(n log log n)\n'
            'Существует алгоритм решета, работающий за O(n):\n'
            'vector<int> lp(N + 1, 0), pr;  // lp[i] - минимильный простой делитель числа i; pr - список простых чисел\n'
            'for (int i = 2; i <= N; i++) {\n'
            '    if (!lp[i]) {              // простое число или нет\n'
            '        lp[i] = i;\n'
            '        pr.push_back(i);\n'
            '    }\n'
            '    for (int j = 0; j < pr.size() && pr[j] * i <= N && pr[j] <= lp[i]; j++)\n'
            '        lp[pr[j] * i] = pr[j];\n'
            '}\n')


def check_for_simplicity():
    return ('z = False\n'
            'x = int(input())\n'
            'if x % 2 == 0 and x != 2:                    # Проверка, является ли число 2, и делится ли оно на два\n'
            '    print(\'NO\')\n'
            'else:\n'
            '    for i in range(3, int(x ** 0.5) + 1, 2):\n'
            '        if x % i == 0:\n'
            '            z = True\n'
            '            break                            # Если находится хотя бы один делитель, то число уже не является простым\n'
            '    if z:\n'
            '        print(\'NO\')\n'
            '    else:\n'
            '        print(\'YES\')')


def suffix_automaton():
    return ('Суффиксный автомат\n'
            '\n'
            'Суффиксный автомат - один из алгоритмов на строках, представляющий из себя ориентированный ациклический граф слов\n'
            '\n'
            'Граф состоит из состояний (вершин), переходов (рёбер) и суффиксных ссылок\n'
            'На переходах хранятся буквы\n'
            'Код:\n'
            'const int MAXLEN = 100000;\n'
            'state st[MAXLEN * 2];\n'
            'int sz, last;\n'
            '\n'
            'void sa_init() {\n'
            '    sz = last = 0;\n'
            '    st[0].len = 0;\n'
            '    st[0].link = -1;\n'
            '    ++sz;\n'
            '}\n'
            '\n'
            'void sa_extend(char c) {\n'
            '    int cur = sz++;\n'
            '    st[cur].len = st[last].len + 1;\n'
            '    int p;\n'
            '    for (p = last; p != -1 && !st[p].next.count(c); p = st[p].link)\n'
            '        st[p].next[c] = cur;\n'
            '    if (p == -1)\n'
            '        st[cur].link = 0;\n'
            '    else {\n'
            '        int q = st[p].next[c];\n'
            '        if (st[q].len == st[p].len + 1)\n'
            '            st[cur].link = q;\n'
            '        else {\n'
            '            int clone = sz++;\n'
            '            st[clone].link = st[q].link;\n'
            '            st[clone].next = st[q].next;\n'
            '            st[clone].len = st[p].len + 1;\n'
            '            for (; p != -1 && st[p].next[c] == q; p = st[p].link)\n'
            '                st[p].next[c] = clone;\n'
            '            st[q].link = st[cur].link = clone;\n'
            '        }\n'
            '    }\n'
            '    last = cur;\n'
            '}\n'
            '\n'
            'MAXLEN - максимальная длина строки во входных данных\n'
            'Суффиксный автомат каждый раз добавляет новую букву, поэтому создание происходит в цикле по всем буквам строки\n'
            '\n'
            'ПРИМЕНЕНИЯ:\n'
            '1. Проверка, является ли строка (s) подстрокой другой строки (S)n\n'
            'Создадим суффиксный автомат для S\n'
            'Теперь будем идти от t0 (начального состояния) по переходам, хранящим буквы s (если s = \"abc\", то a -> b -> c)\n'
            'Если мы прошли по всей строке, то она является подстрокой. Если в какой-то момент нет нужного перехода, то строка не является подстрокой\n'
            'Код:\n'
            'int v = 0;\n'
            'bool z = true;\n'
            'for (char & i : in) {\n'
            '    if (st[v].next.count(i))\n'
            '        v = st[v].next[i];\n'
            '    else {\n'
            '        z = false;\n'
            '        break;\n'
            '    }\n'
            '}\n'
            'if (z)\n'
            '    cout << "yes" << el;\n'
            'else\n'
            '    cout << "no" << el;\n'
            '\n'
            '2. Кол-во различных подстрок\n'
            'Нужно посчитать кол-во различных путей от начальной вершины\n'
            'Для этого добавим функцию подсчёта путей (dfs с dp):\n'
            'int col[MAXLEN * 2];\n'
            'll dp[MAXLEN * 2];\n'
            'void dfs(int v) {\n'
            '    col[v] = 1;\n'
            '    for (pair<const char, int>& item : st[v].next) {\n'
            '        if (!col[item.second])\n'
            '            dfs(item.second);\n'
            '        dp[v] += dp[item.second];\n'
            '    }\n'
            '    dp[v]++;\n'
            '    col[v] = 2;\n'
            '}\n'
            'Для ответа нужно запустить dfs от вершины 0 и вывести dp[0] - 1 (чтобы не учитывать пустую строку нужно вычесть 1)\n'
            '\n'
            '3. Минимальный циклический сдвиг строки\n'
            'Построим суффиксный автомат для строки (S + S)\n'
            'После этого пройдём по автомату от начальной вершины, выбирая жадно символы (каждый раз берём минимальный символ)\n'
            'Функция:\n'
            'string min_shift(int n) {\n'
            '    string ans;\n'
            '    int cur_len = 0, v = 0;\n'
            '    char c;\n'
            '    while (cur_len < n) {\n'
            '        cur_len++;\n'
            '        for (pair<const char, int>& item: st[v].next) {\n'
            '            v = item.second;\n'
            '            c = item.first;\n'
            '            break;\n'
            '        }\n'
            '        ans.push_back(c);\n'
            '    }\n'
            '    return ans;\n'
            '}\n'
            'Из основной программы функцию нужно запускать с аргументом n - начальная длина строки s (не удвоенная)\n'
            '\n'
            '4. Количество вхождений подстроки (с пересечениями):\n'
            'Создадим суффиксный автомат для большей строки\n'
            'Будем хранить массив cnt\n'
            'Добавим в самое начало (2 строка) функции создания автомата строку cnt[cur] = 1\n'
            'После создания пройдём по переходам-символам меньшей строки (см. пункт 1) и найдём последнее состояние v\n'
            'Выведем cnt[v]\n'
            'Код:\n'
            'void dfs(int v) {\n'
            '    col[v] = 1;\n'
            '    for (pair<const char, int>& item : st[v].next) {\n'
            '        if (!col[item.second])\n'
            '            dfs(item.second);\n'
            '        cnt[st[item.second].link] += cnt[item.second];\n'
            '    }\n'
            '    col[v] = 2;\n'
            '}\n'
            'Основная функция:\n'
            '...'
            'dfs(0);\n'
            'int v = 0;\n'
            'for (char & i : in)\n'
            '    v = st[v].next[i];\n'
            'cout << cnt[v];\n'
            '...\n'
            '\n'
            '5. Позиция первого вхождения строки в строку\n'
            'Будем хранить массив firstpos\n'
            'При создании st[cur] (начало функции), будем добавлять firstpos[cur] = st[cur].len - 1\n'
            'При клонировании firstpos[clone] = firstpos[q]\n'
            'Потом пройдём по символам меньшей строки p (см. предыдущие пункты) и найдём последнее состояние v\n'
            'Ответ: firstpos[v] - p.size() + 1\n'
            '\n'
            '6. Позиции всех вхождений\n'
            'Будем модифицировать предыдущий пункт\n'
            'В state добавим bool is_clone (метка клона). При клонировании будем писать st[clone].is_clone = true\n'
            'В state добавим vector<int> inv_link (ивертированные суффиксные ссылки)\n'
            'Сразу после создания автомата:\n'
            'for (int v = 1; v < sz; v++)\n'
            '    st[st[v].link].inv_link.push_back(v);\n'
            'Потом пройдём по символам меньшей строки и найдём последнее состояние v\n'
            'Ответ будем хранить в массиве allpos\n'
            'Функция для получения ответа:\n'
            'void find_allpos(int v, int p_len) {\n'
            '    if (!st[v].is_clone)\n'
            '        allpos.push_back(firstpos[v] - p_len + 1);\n'
            '    for (int i : st[v].inv_link)\n'
            '        find_allpos(i, p_len);\n'
            '}\n'
            'Из основной программы функцию следует запускать с аргументами v (найденное нами последнее состояние) и p_len (длина меньшей строки)\n'
            'ВАЖНО: 1. до создания автомата нужно проверить, является ли строка подстрокой, иначе ответ будет выглядеть странно\n'
            '       2. allpos не отсортирован; если нужен отсортированный ответ, нужно сделать сортировку до вывода массива\n'
            '\n'
            '7. Кратчайшая строка, не входящая в данную\n'
            'Будем решать с помощью dp\n'
            'Если из вершины v нет переходов по символам из алфавита, то dp[v] = 1\n'
            'Иначе dp[v] - это минимум из ответов по всем переходам + 1\n'
            '\n'
            '8. Наидлиннейшая общая подстрока двух строк\n'
            'Для первой строки построим автомат\n'
            'Втору строку передадми в функцию lcs\n'
            'Код:\n'
            'string lcs(string t) {\n'
            '    int v = 0, l = 0, best = 0, bestpos = 0;\n'
            '    for (int i = 0; i < t.size(); i++) {\n'
            '        while (v && !st[v].next.count(t[i])) {\n'
            '            v = st[v].link;\n'
            '            l = st[v].len;\n'
            '        }\n'
            '        if (st[v].next.count(t[i])) {\n'
            '            v = st[v].next[t[i]];\n'
            '            l++;\n'
            '        }\n'
            '        if (l > best) {\n'
            '            best = l;\n'
            '            bestpos = i;\n'
            '        }\n'
            '    }\n'
            '    return t.substr(bestpos - best + 1, best);\n'
            '}\n')


def no(a):
    global list_com
    list_com = ['all', 'date_time', 'combinations_enumeration', 'binsearch', 'two_pointers', 'testing', 'hashes', 'z_function',
                'Manacher', 'segment_tree', 'sparse_table', 'bit_operations', 'f_Euler', 'quick_pow', 'graphs', 'eratosthenes_sieve', 'check_for_simplicity', 'suffix_automaton']
    if a not in list_com:
        return False
    else:
        return True


def all():
    for i in range(len(list_com)):
        if i != len(list_com) - 1:
            print(list_com[i], end='\n')
        else:
            print(list_com[i])
    return ''


a = '1'
while a != 'exit':
    a = input(colored('>>>', 'green'))
    if a == 'exit':
        sys.exit('Завершение работы...')
    else:
        if not no(a):
            print('Такого раздела не существует!')
        else:
            a += '()'
            print(eval(a))

'''no('')
for i in list_com:
    print(colored(i, 'red'))
    print(eval(i + '()'))
    print('\n\n\n')'''