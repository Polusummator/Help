import sys
from termcolor import colored


def all():
    for i in range(len(list_com)):
        if i != len(list_com) - 1:
            print(list_com[i], end='\n')
        else:
            print(list_com[i])
    return ''


def date_time():
    return ('Задачи на дату/время\n'
            '\n'
            'ВРЕМЯ\n'
            '\n'
            'Считывание при вводе:\n'
            'P: h, m, s = [int(i) for i in input().split(\':\')]\n'
            'C: scanf("%d:%d:%d", &h, &m, &s)\n'
            '\n'
            'Перевод из строки в число:\n'
            'P: int(s[0] + s[1])\n'
            'C: (s[0] - \'0\') * 10 + (s[1] - \'0\') # char является числом (кодом символв в ASCII)\n'
            '\n'
            'проще перевести всё в секунды: sec = h * 3600 + m * 60 + s\n'
            '\n'
            'ДАТЫ\n'
            '\n'
            'Считывание, такое же, как во времени\n'
            '\n'
            'Первод в дни:\n'
            'days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] # можно сделать префиксные суммы\n'
            'd = sum(days[mm - 2]) + dd # может возникнуть проблема с месяцем (если введён первый месяц)\n'
            '\n'
            'Перевод из дней в месяц:\n'
            'i = 0\n'
            'while x > 0:\n'
            '    if x <= days[i]:\n'
            '         print(i + 1)\n'
            '         break\n'
            '    else:\n'
            '         x -= days[i]\n'
            '         i += 1\n'
            '\n'
            'Полный код переводов в C/C++ (високосный год не учитывается):)\n'
            '\ufeff#include <iostream>\n'
            'using namespace std;\n'
            'int prefDays[12];\n'
            'int days[12] = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n'
            'int dateToDays(int m, int d) {\n'
            '\tint ans = 0;\n'
            '\tif (m > 1) {\n'
            '\t\tint ans = prefDays[m - 2];\n'
            '\t}\n'
            '\tans += d;\n'
            '\t/*for (int i = 0; i <= m - 2; ++i) {\n'
            '\t\tans += days[i];*/\n'
            '\treturn ans;\n'
            '}\n'
            'pair <int, int> daysToDate(int x) {\n'
            '\tint m = 1, d = 0;\n'
            '\tfor (int i = 0; i < 12; ++i) {\n'
            '\t\tif (x <= days[i]) {\n'
            '\t\t\td = x;\n'
            '\t\t\treturn {m, x};\n'
            '\t\t}\n'
            '\t\telse {\n'
            '\t\t\tm++;\n'
            '\t\t\tx -= days[i];\n'
            '\t\t}\n'
            '\t}\n'
            '}\n'
            'int main() {\n'
            '\tprefDays[0] = days[0];\n'
            '\tfor (int i = 1; i < 12; ++i) {\n'
            '\t\tprefDays[i] = prefDays[i - 1] + days[i];\n'
            '\t}\n'
            '}\n'
            '\n'
            'Проверка на високосность года:\n'
            'if year % 400 == 0 or (year % 4 == 0 and year % 100 != 0):\n'
            '    print(\'Yes\')\n'
            'else:\n'
            '    print(\'No\')\n'
            '\n'
            'Посчитать кол-во високосных лет с одного заданного года до другого можно так:\n'
            '(year1 - year2) // 4 - (year1 - year2) // 100 + (year1 - year2) // 400\n'
            '\n'
            'Определение дня недели по номеру дня в году (n - номер дня, ng - день недели 1 января)\n'
            'dn = (ng - 2 + n) % 7 + 1\n')


def combinations_enumeration():
    return ('Один из способов перевода - битовые маски\n'
            'Следующий код выводит все сочетания из 0 и 1 длиной n\n'
            '\n'
            '\ufeff#include <iostream>\n'
            '\n'
            'using namespace std;\n'
            '\n'
            'int main() {\n'
            '\tint n;\n'
            '\tcin >> n;\n'
            '\tfor (int i = 0; i < (1 << n); ++i) {\n'
            '\t\tfor (int q = 0; q < n; ++q) {\n'
            '\t\t\tif (i & (1 << q)) {\n'
            '\t\t\t\tcout << 1;\n'
            '\t\t\t}\n'
            '\t\t\telse {\n'
            '\t\t\t\tcout << 0;\n'
            '\t\t\t}\n'
            '\t\t}\n'
            '\t\tcout << endl;\n'
            '\t}\n'
            '}\n'
            '\n'
            'Следующий код свыводит все сочетания чисел от start до end длиной n в лексикографическом порядке\n'
            'Python:\n'
            'def gen(left, cur):\n'
            '    if left == 0:\n'
            '        print(*cur)\n'
            '        return\n'
            '    for i in range(start, end + 1):\n'
            '        gen(left - 1, cur + [i])\n'
            '\n'
            '\n'
            'n, start, end = map(int, input().split())\n'
            'gen(n, [])\n'
            '\n'
            'C++:\n'
            '\ufeff#include <iostream>\n'
            '#include <vector>\n'
            '\n'
            'using namespace std;\n'
            '\n'
            'int n, start, end_;\n'
            '\n'
            'void gen(int left, vector<int> cur) {\n'
            '\tif (left == 0) {\n'
            '\t\tfor (int i : cur) {\n'
            '\t\t\tcout << i << \' \';\n'
            '\t\t}\n'
            '\t\tcout << endl;\n'
            '\t\treturn;\n'
            '\t}\n'
            '\tfor (int i = start; i <= end_; ++i) {\n'
            '\t\tcur.push_back(i);\n'
            '\t\tgen(left - 1, cur);\n'
            '\t\tcur.pop_back();\n'
            '\t}\n'
            '}\n'
            '\n'
            'int main() {\n'
            '\tcin >> n >> start >> end_;\n'
            '\tgen(n, vector<int>{});\n'
            '}\n'
            '\n'
            'Следующий код имеет функцию gen, которая делает то же самое, что и предыдущий код (только без повторений чисел)\n'
            'Также код имеет функию n_permutation (аналог встроенной next_permutation), которая выводит следующую последовательность из цифр в лексикографическом порядке\n'
            '\n'
            '\ufeff#include <iostream>\n'
            '#include <vector>\n'
            '#include <algorithm>\n'
            '\n'
            'using namespace std;\n'
            '\n'
            'int n;\n'
            '\n'
            'void gen(int left, vector<int> cur, vector<int> been) {\n'
            '\tif (left == 0) {\n'
            '\t\tfor (int i : cur) {\n'
            '\t\t\tcout << i << \' \';\t\t\t\n'
            '\t\t}\n'
            '\t\tcout << endl;\n'
            '\t\treturn;\n'
            '\t}\n'
            '\tfor (int i = 0; i < n; ++i) {\n'
            '\t\tif (!been[i]) {\n'
            '\t\t\tbeen[i] = 1;\n'
            '\t\t\tcur.push_back(i + 1);\n'
            '\t\t\tgen(left - 1, cur, been);\n'
            '\t\t\tcur.pop_back();\n'
            '\t\t\tbeen[i] = 0;\n'
            '\t\t}\n'
            '\t}\n'
            '}\n'
            '\n'
            'void n_permutation(vector<int>& p) {\n'
            '\tint n = p.size();\n'
            '\tfor (int i = n - 1; i > 0; --i) {\n'
            '\t\tif (p[i] > p[i - 1]) {\n'
            '\t\t\tint pos;\n'
            '\t\t\tfor (int j = n - 1; j >= i; --j) {\n'
            '\t\t\t\tif (p[j] > p[i - 1]) {\n'
            '\t\t\t\t\tpos = j;\n'
            '\t\t\t\t\tbreak;\n'
            '\t\t\t\t}\n'
            '\t\t\t}\n'
            '\t\t\tswap(p[pos], p[i - 1]);\n'
            '\t\t\tsort(p.begin() + i, p.end());\n'
            '\t\t\tbreak;\n'
            '\t\t}\n'
            '\t}\n'
            '}\n'
            '\n'
            'int main() {\n'
            '\tcin >> n;\n'
            '\tgen(n, vector<int>{}, vector<int>(n, 0));\n'
            '\t/*vector<int> a = { 3, 1, 5, 2, 7, 6, 4 };\n'
            '\tn_permutation(a);\n'
            '\tfor (int i : a) {\n'
            '\t\tcout << i << \' \';\n'
            '\t}*/\n'
            '}\n')


def binsearch():
    return ('Бинпоиск\n'
            '\n'
            'Смысл бинпоиска - поиск элемента в отсортированном массиве путём деления массива на две части\n'
            'Поэтому сложность бинпоиска - log2(n)\n'
            '\n'
            'Код бинпоиска:\n'
            'l = 0\n'
            'r = 10 ** 100\n'
            'while r - l > 1:\n'
            '    m = (l + r) // 2\n'
            '    if f(m) >= x:\n'
            '        r = m\n'
            '    else:\n'
            '        l = m\n'
            'print(r)\n'
            '\n'
            'f - какая-то функция, x - заданное число\n'
            '\n'
            'При вещественном бинпоиске (с нецелыми числами, заданная точность) можно заменить while на for\n'
            'for будет выполняться math.ceil(math.log2((r - l) * 10000000000))\n'
            'кол-во нулей в последнем числе - точность ответа\n'
            '\n'
            'Всторенный бинпоиск\n'
            'Python:\n'
            'from bisect import bisect_right, bisect_left\n'
            '\n'
            'a = [1, 2, 4, 5, 6, 6, 7, 9]\n'
            'ind = bisect_left(a, 5)\n'
            'ind1 = bisect_right(a, 6)\n'
            'print(ind, ind1)\n'
            ''
            'C++:\n'
            '\ufeff#include <iostream>\n'
            '#include <algorithm>\n'
            '#include <vector>\n'
            '\n'
            'using namespace std;\n'
            '\n'
            'int main() {\n'
            '\tvector<int> a {1, 2, 4, 5, 6, 6, 7, 9};\n'
            '\tint b[7] = { 2, 4, 4, 6, 8, 8, 9 };\n'
            '\tauto it = lower_bound(a.begin(), a.end(), 5);\n'
            '\tcout << *it << \' \' << it - a.begin() << endl;\n'
            '\tauto it1 = upper_bound(b, b + 7, 6);\n'
            '\tcout << *it1 << \' \' << it1 - b << endl;\n'
            '}\n'
            '\n'
            'bisect_left и lower_bound ищут первый элемент >= заданного\n'
            'bisect_right и upper_bound ищут первый элемент > заданного\n')


def two_pointers():
    return ('Метод двух указателей\n'
            '\n'
            'Смысл метода заключается в закреплении одного элемента отсортированного массива и передвижения второго\n'
            'Стандартный код метода двух указателей:\n'
            'for (int first_point = 0; first_point < len_array; first_point++) {\n'
            '    while (second_point < len_array && <условие>) {\n'
            '        second_point++;\n'
            '    }\n'
            '}\n'
            '\n'
            'Указатели могут относится к разным массивам\n'
            'Указателей может быть больше двух, тогда добавляются циклы while в цикле for (один указателб - один цикл while)\n')


def testing():
    return ('Тестирование\n'
            '\n'
            'В основном, тестирование - это генерация тестов\n'
            'В Python за генерацию отвечает модуль random\n'
            'Основные функции:\n'
            'randint(start, end)      # случайное целое число от start до end включительно\n'
            'choice(l)                # случайный элемент списка l\n'
            'normalvariate(mu, sigma) # нормальное распределение\n'
            'random()                 # случайное число от 0 до 1\n'
            '\n'
            'Некоторые генерации:\n'
            '1. Правильная скобочная последовательность\n'
            'n = int(input())\n'
            'l = 0\n'
            'bal = 0\n'
            's = \'\'\n'
            'for i in range(n):\n'
            '    if not bal:\n'
            '        s += \'(\'\n'
            '        l += 1\n'
            '        bal += 1\n'
            '    elif bal + 1 > n - l - 1:\n'
            '        s += \')\'\n'
            '        l += 1\n'
            '        bal -= 1\n'
            '    else:\n'
            '        par = randint(0, 1)\n'
            '        if not par:\n'
            '            s += \'(\'\n'
            '            l += 1\n'
            '            bal += 1\n'
            '        else:\n'
            '            s += \')\'\n'
            '            l += 1\n'
            '            bal -= 1\n'
            'print(s)\n'
            '\n'
            '2. Массив заданной длины и суммы элементов\n'
            'n = int(input())\n'
            's = int(input())\n'
            'border = []\n'
            'for i in range(n - 1):\n'
            '    border.append(randint(0, s))\n'
            'border.sort()\n'
            'border = [0] + border + [s]\n'
            'a = []\n'
            'for i in range(1, n + 1):\n'
            '    a.append(border[i] - border[i - 1])\n'
            'print(a)\n'
            '\n'
            '3. Массив заданной длины из чисел от 1 до k без повторений\n'
            'n = int(input())\n'
            'k = int(input())\n'
            'if k < 5 * n:\n'
            '    a = list(range(1, k + 1))\n'
            '    shuffle(a)\n'
            '    a = a[:n]\n'
            '    print(a)\n'
            'else:\n'
            '    s = set()\n'
            '    while len(s) < n:\n'
            '        s.add(randint(1, k))\n'
            '    l = list(s)\n'
            '    shuffle(l)\n'
            '    print(l)\n'
            '\n'
            'ТЕСТИРОВНИЕ НЕПРАВИЛЬНОГО РЕШЕНИЯ ПРИ НАЛИЧИИ МЕДЛЕННОГО ПРАВИЛЬНОГО\n'
            'Правильное, но медленное решение - slow.py. Неработающее решение - testme.py\n'
            '\n'
            'Для начала пишем генератор для программ в отдельном файле (например, gen.py)\n'
            '\n'
            'Теперь нужно написать программу, котрая свяжет всё (генератор, два решения и проверку правильности ответа)\n'
            'Например, run.py\n'
            'Тогда программа run.py будет выглядеть так:\n'
            'import os\n'
            '\n'
            'test = 1\n'
            'while True:\n'
            '    os.system(\'python gen.py > input\')\n'
            '    os.system(\'python testme.py < input > output\')\n'
            '    os.system(\'python slow.py < input > correct\')\n'
            '    output = [i.strip() for i in open(\'output\').readlines()]\n'
            '    correct = [i.strip() for i in open(\'correct\').readlines()]\n'
            '    if output != correct:\n'
            '        print(\'Error at test\', test)\n'
            '        break\n'
            '    print(\'Test\', test, \'is OK\')\n'
            '    print(\'--------------------\')\n'
            '    test += 1\n'
            '\n'
            '< и > перенаправляют вывод в файл\n'
            'Тест, неправильный и правильный ответ можно будет посмотреть после тестирования в файлах input, output и correct\n')


def no(a):
    global list_com
    list_com = ['date_time', 'combinations_enumeration', 'binsearch', 'two_pointers', 'testing']
    if a not in list_com:
        return False
    else:
        return True


a = '1'
while a != 'exit':
    a = input(colored('>>>', 'green'))
    if a == 'exit':
        sys.exit('Завершение работы...')
    else:
        if not no(a):
            print('Такого раздела не существует!')
        else:
            a += '()'
            print(eval(a))