import sys
from termcolor import colored


def all():
    for i in range(len(list_com)):
        if i != len(list_com) - 1:
            print(list_com[i], end='\n')
        else:
            print(list_com[i])
    return ''


def no(a):
    global list_com
    # TODO: объединение словарей, 2 метода строк (3.9)
    list_com = ['all', 'transfer_from_10_sys_to_a_sys',
                'data_types', 'list', 'str', 'dict', 'tuple', 'transfer_from_a_sys_to_10_sys', 'numbers', 'set', 'equality_of_elements',
                'shielded_sequences', 'str_format', 'files', 'bool', 'bytes', 'bytearray', 'exceptions', 'assignment',
                'variables_names', 'NoneType', 'Print', 'If', 'While', 'For', 'iterators', 'list_generators', 'documentation',
                'functions', 'arguments', 'recursion', 'lambda_functions', 'generators', 'modules', 'transitive_reload',
                'classes', 'Range']
    if a not in list_com:
        return False
    else:
        return True


def transfer_from_10_sys_to_a_sys():
    return ('s = str()\n'
            'x = int(input())\n'
            'while x > 0:\n'
            '    s = str(x % a) + s # Берём остаток от деления на a\n'
            '    x = x // a         # Число становится целой частью от деления на a\n'
            'print(s)\n'
            '\n'
            'также существуют функции bin(), oct(), hex() для первода в двоичную, восьмеричную, шестнадцатеричную систему\n'
            'перевод этими функциями осуществляется в таком формате: в начале полученной строки стоит 0b (двоичная), или 0o(восьмеричная), или 0x (шестнадцатеричная)\n')


def data_types():
    return ('str\n'
            'Example: s = \'123Ab5s-o\'\n'
            'P.s. \'123Ab5s-o\' == "123Ab5s-o"   # \' и " - это одно и то же\n'
            'Строки - неизменяемый тип!\n'
            '\n'
            'int\n'
            'Example: a = 12652\n'
            '\n'
            'float\n'
            'Example: a = 127.0002\n'
            '\n'
            'complex\n'
            'Example: a = 42 + 5j\n'
            '\n'
            'tuple\n'
            'Example: a = (1, 2, \'Hello\')\n'
            'Кортежи - неизменяемый тип!\n'
            '\n'
            'list\n'
            'Example: a = [1, 2, 3, \'ab\', 1.02, \'c\']\n'
            '\n'
            'bytes\n'
            'Example: a = b\'123abm\'\n'
            'Байты - это последовательности целых чисел, не превышающих 255.\n'
            'Байты - неизменяемый тип!\n'
            '\n'
            'bytearray\n'
            'Example: bytearray(b\'abbcd\')\n'
            'Bytearray отличается от bytes тем, что bytearray - изменяемый тип.\n'
            '\n'
            'set\n'
            'Example: {1, 2, \'a\'}\n'
            'У set нет индесков!\n'
            '\n'
            'frozenset\n'
            'Example: frozenset({\'b\', \'a\', \'s\'})\n'
            'Frozenset отличатется от set тем, что frozenset - неизменяемый тип\n'
            '\n'
            'memoryview\n'
            'memoryview нельзя вывести, но можно вывести list(memoryview)\n'
            'Example: [97, 98, 115]\n'
            '\n'
            'bool\n'
            'Example: a = False\n'
            '         b = True\n'
            '\n'
            'dict\n'
            'Example: {1: \'John\', 2: \'Mike\'}\n'
            '\n'
            'range\n'
            'range нельзя вывести как последовательность, но можно вывести list(range)'
            'Example: a = range(1, 6, 2)\n'
            'Example: [1, 3, 5]\n'
            '\n'
            'NoneType\n'
            'None\n'
            'Пустой тип\n')


def list():
    return ('list\n'
            '\n'
            'list - последовательность из элементов разных типов\n'
            'Example: l = [\'a\', 43, \'abc\', 4.02, [1, 2, 3]]\n'
            '         l = [b\'abc\', [1, 2, 3], {1, 2, 3}, {1: \'a\', 2: \'b\'}, bytearray(b\'ab\'), range(1, 2), 1, 2, 3.01]\n'
            '\n'
            'СРЕЗЫ И ИНДЕКСЫ:\n'
            'Как и у строк, у списков есть срезы и индексы.\n'
            'l[i] - элемент списка с индексом i\n'
            'Индексы начинаются с 0\n'
            'Есть и отрицательные индексы. Последний элемент списка имеет индекс -1, предпоследний -2 и т.д.\n'
            'Списки - изменяемый тип, поэтому можно изменить один элемент списка так: l[i] = x\n'
            '\n'
            'Срезы - подпоследовательности (и не только) списка.\n'
            's = l[start:end:step] - срез\n'
            'start - начало среза\n'
            'end - конец среза (не достигается)\n'
            'step - шаг (будет браться каждый step-ый элемент)\n'
            'Example: l = [1, 2, 3, 4, 5, 6, 7]\n'
            '         a = l[2:6:2]  --> a = [3, 5]\n'
            '         s = l[:] - копия списка l\n'
            '         l = l[::-1] - разворот списка\n'
            'Если опустить start, то элементы будут браться с начала списка\n'
            'Если опустить end, то элементы будут браться до конца списка\n'
            '\n'
            'start, end, step могут быть отрицательны\n'
            '\n'
            'также срез можно извлекать функцией slice\n'
            'l[slice(start, end, step)]\n'
            '\n'
            'Спискам характерна конкатенация, т.е. можно написать l = list1 + list2\n'
            'Спискам характерно повторение, т.е. можно написать l = list1 * 3\n'
            '\n'
            'Удалить один элемент списка или целый срез можно, используя инструкцию del\n'
            'Example: del [1, 2, 3, 4, 5] --> [2, 4]\n'
            '\n'
            'ФУНКЦИИ:\n'
            'len(l)            # длина списка l\n'
            'all(l)            # True, если все элементы списка истинные (в списке нет False), или список пуст\n'
            'any(l)            # True, если хотя бы один элемент истинный. Если список пуст, то False\n'
            'sum(l)            # сложение всех элементов списка (если список состоит из чисел или bool, иначе TypeError)\n'
            'list(reversed(l)) # переворот списка\n'
            'max(l)            # максимальный элемент списка. Если список состоит из чисел, то будет выдано максимальное число (True считается за 1, False - за 0)\n'
            '                                                 Если список состоит из строк, то будет выведена строка с наибольшей длиной. Если таких строк несколько, то начинается сравнение этих строк (букв - по алфавиту, цифр - по величине)\n'
            'min(l)            # минимальный элемент списка. Если список состоит из чисел, то будет выдано минимальное число (True считается за 1, False - за 0)\n'
            '                                                Если список состоит из строк, то будет выведена строка с наименьшей длиной. Если таких строк несколько, то начинается сравнение этих строк (букв - по алфавиту, цифр - по величине)\n'
            'в min() и max() могут быть переданы несколько списков. Тогда списки сравниваются поэлементно. Выводится весь список\n'
            'в min() и max() может быть прописан параметр key, которому приравнивается функция, которая будет применена к каждому элементу списка\n'
            'Example: l = [1, 2, -3]\n'
            '         s = max(l, key=abs) --> s = -3\n'
            'sorted(l) # аналог l.sort()\n'
            '\n'
            'Проверка, есть ли элемент в списке - in\n'
            'a = x in l - принимает значения True или False\n'
            '\n'
            'ГЕНЕРАТОРЫ:\n'
            'a = [3 for i in range(3)] --> a = [3, 3, 3]\n'
            'a = [3 * i for i in range(5) if i != 3] --> a = [0, 3, 6, 12]\n'
            'Перевод range в list - это тоже генератор\n'
            'a = list(range(start, end, step))\n'
            '\n'
            'МЕТОДЫ:\n'
            'list.append(x)            # добавление элемента x в конец списка list\n'
            'list.extend(A)            # добавление всех елементов списка A в конец списка list (= list + A)\n'
            'list.insert(i, x)         # добавление элемент x на индекс i (только добавление, элементы списка не удаляются)\n'
            'list.remove(x)            # удаление первого элемента x в списке list. Если элемента нет в списке, то будет выведена ошибка ValueError\n'
            'list.pop(i)               # удаление и возвращение i-того элемента в списке list. Если i не указано, то удалится последний элемент\n'
            'list.index(x, start, end) # индекс первого вхождения x в list[start:end]. start и end можно не указывать\n'
            'list.count(x)             # кол-во вхождений элемента x в список list\n'
            'list.reverse()            # разворот списка (= list = list[::-1])\n'
            'list.clear()              # очистка списка\n'
            'list.copy()               # копия списка\n'
            'list.sort(key=, reverse=) #сортировка списка (существует ещё функция sorted() - для многих типов, sort - для списков)\n'
            '                           сортировка списка производится по функции key. Example: l.sort(key=lambda s: s[1]) - сортировка двумерного списка по второму элемену каждого элемента\n'
            '                           если key не указан, то сортировка производится по возрастанию (с числами) и в алфавитном порядке (со строками)\n'
            '                           reverse = True - переворот сортировки. Если применить reverse=True к сортировке по возрастанию, получится сортировка по убыванию\n')
    

def str():
    return('str\n'
           '\n'
           'str - последовательность из разных символов\n'
           'Example: s = \'ab7489(*(894394968486ifiYGGГПгагрока\'\n'
           '\n'
           'Примечание: знак \" эквивалентен знаку \'\n'
           '\n'
           'СРЕЗЫ И ИНДЕКСЫ:\n'
           'Как и у списков, у строк есть срезы и индексы.\n'
           'l[i] - элемент строки с индексом i\n'
           'Индексы начинаются с 0\n'
           'Есть и отрицательные индексы. Последний элемент списка имеет индекс -1, предпоследний -2 и т.д.\n'
           'Строки - НЕизменяемый тип, поэтому НЕЛЬЗЯ изменить один элемент строки так: s[i] = x\n'
           '\n'
           'Срезы - подпоследовательности (и не только) строки\n'
           'l = s[start:end:step] - срез\n'
           'start - начало среза\n'
           'end - конец среза (не достигается)\n'
           'step - шаг (будет браться каждый step-ый элемент)\n'
           'Example: s = \'ryfhyurhfub57786jnuh8\'\n'
           '         a = s[2:6:2]  --> a = \'fy\'\n'
           '         m = s[:] - копия строки s\n'
           '         l = s[::-1] - разворот строки\n'
           'Если опустить start, то элементы будут браться с начала строки\n'
           'Если опустить end, то элементы будут браться до конца строки\n'
           '\n'
           'start, end, step могут быть отрицательны\n'
           '\n'
           'также срез можно извлекать функцией slice\n'
           'l[slice(start, end, step)]\n'
           '\n'
           'Строкам характерна конкатенация, т.е. можно написать s = str1 + str2\n'
           'Строкам характерно повторение, т.е. можно написать s = str1 * 3\n'
           '\n'
           'len(s) - длина строки\n'
           '\n'
           'Проверка, есть ли элемент или подстрока в строке - in\n'
           'a = x in l - принимает значения True или False\n'
           '\n'
           'ФУНКЦИИ:\n'
           'len(s)    # возвращение длины строки s\n'
           'ord(char) # код строчного символа char в таблице ASCII\n'
           'chr(code) # символ в таблице ASCII, имеющий код code\n'
           ''
           'МЕТОДЫ:\n'
           's.find(str, start, end)   # возвращение индекса первого вхождения подстроки str в s[start:end] (start и end могут опускаться). Если элемента нет, возвращает -1\n'
           's.rfind(str, start, end)  # возвращение индекса последнего вхождения подстроки str в s[start:end] (start и end могут опускаться). Если элемента нет, возвращает -1\n'
           's.index(str, start, end)  # возвращение индекса первого вхождения подстроки str в s[start:end] (start и end могут опускаться). Если элемента нет, возвращает ValueError\n'
           's.rindex(str, start, end) # возвращение индекса последнего вхождения подстроки str в s[start:end] (start и end могут опускаться). Если элемента нет, возвращает -1\n'
           's.replace(old, new)       # замена все вхождений old в строке s на new\n'
           's.split(i, maxsplit=)     # разбиение строки по символу i (создание списка из частей строки). maxsplit - кол-во разбиений (можно не указывать, тогда будут сделаны все разбиения)\n'
           's.rsplit(i, maxsplit=)    # то же самое, что split, но разбиение будет производиться справа налево\n'
           's.splitlines(keepends=)   # разбиение строки на строки по символу \\n (создание списка из строк). keepends может быть False и True (по умолчанию False), указывает на то, чтобы оставлять символы переноса строки или нет\n'
           's.isdigit()               # проверка, состоит ли строка только из цифр (True/False)\n'
           's.isalpha()               # проверка, состоит ли строка только из букв (True/False)\n'
           's.isalnum()               # проверка, состоит ли строка из цифр или букв (True/False)\n'
           's.islower()               # проверка, стоят ли все буквы в строке в нижнем регистре (True/False). Если в строке нет букв, будет выдано False\n'
           's.isupper()               # проверка, стоят ли все буквы в строке в верхнем регистре (True/False). Если в строке нет букв, будет выдано False\n'
           's.isspace()               # проверка, состоит ли строка из неотображаемых символов\n'
           '                            (пробел, символ перевода страницы (\'\\f\'), "новая строка" (\'\\n\'), "перевод каретки" (\'\\r\'), "горизонтальная табуляция" (\'\\t\') и "вертикальная табуляция" (\'\\v\'))\n'
           's.istitle()               # проверка, начинаются ли все слова в строке с большой буквы (True/False). Словами считаются подстроки из букв. Если слов нет, то будет выведено False\n'
           's.isdecimal()             # проверка, получится ли целое десятичное число при переводе строки в число (True/False)\n'
           's.isnumeric()             # похоже на isdecimal, но может также использоваться римская система счисления...\n'
           's.isprintable()           # проверка, могут ли все символы строки быть выведены (True/False)\n'
           's.isidentifer()           # проверка, может ли строка быть идентификатором (названием переменной, класса, функции...)\n'
           's.upper()                 # перевод всех букв в строке в верхний регистр\n'
           's.lower()                 # перевод всех букв в строке в нижний регистр\n'
           's.casefold()              # перевод букв строки в нижней регистр, но более агрессивно. Некоторые символы, буквы из других языков заменяются сочетаниями символов. Например, ß перейдёт в ss\n'
           's.startswith(str)         # проверка, начинается ли строка со строки str (True/False)\n'
           's.endswith(str)           # проверка, заканчивается ли строка строкой str (True/False)\n'
           'sep.join(l)               # сборка строки из элементов списка l с разделителем sep\n'
           's.capitalize()            # перевод первого символа строки в верхний регистр (если он является буквой), все остальные буквы переводятся в нижний регистр\n'
           's.center(width, fill)     # центрирование строки. width - длина нужной строки, fill - элемент, который будет стоять слева и справа.\n'
           '                            Example: s = \'abcd\'\n'
           '                            s.center(8, \'-\') --> \'--abcd--\'\n'
           '                            Если длина строки нечётна, а width - чётно, то справа будет на один элемент больше.\n'
           '                            Если длина строки чётна, а width - нечётно, то слева будет на один элемент больше\n'
           's.count(str, start, end)  # возвращение кол-во непересекающихся вхождений строки str в строку s[start:end] (start и end могут опускаться)\n'
           's.expandtabs(tabsize)     # замена всех символов табуляции в строке на пробелы. Кол-во пробелов на один символ - tabsize. По умолчанию tabsize - 8\n'
           's.rstrip(str)             # удаление всех символов str справа строки. По умолчанию - пробелы, знак переноса строки, знаки табуляции\n'
           's.lstrip(str)             # удаление всех символов str слева строки. По умолчанию - пробелы, знак переноса строки, знаки табуляции\n'
           's.strip(str)              # удаление всех символов str справа и слева строки. По умолчанию - пробелы, знак переноса строки, знаки табуляции\n'
           's.partition(sh)           # возвращение кортежа состоящего из части строки до шаблона sh, шаблона sh и части после шаблона. Шаблон берётся, как первое вхождение sh в s\n'
           '                            Если шаблон не найден, то будет возвращён кортеж со строкой на первом месте и двумя пустыми строками на втором и третьем\n'
           's.rpartition(sh)          # возвращение кортежа состоящего из части строки до шаблона sh, шаблона sh и части после шаблона. Шаблон берётся, как последнее вхождение sh в s\n'
           '                            Если шаблон не найден, то будет возвращён кортеж с двумя пустыми строками на первом и втором месте и строкой на третьем\n'
           's.title()                 # перевод первых букв всех слов в строке в верхний регистр, а остальных букв - в нижний. Словом считается последовательность из букв\n'
           's.zfill(width)            # если width больше длины строки, то строка дополняется нулями вначале до длины width\n'
           's.ljust(width, fillchar=) # если width больше длины строки, то строка дополняется вконце символами fillchar\n'
           's.rjust(width, fillchar=) # если width больше длины строки, то строка дополняется вначале символами fillchar\n'
           's.swapcase()              # перевод букв строки нижнего регистра в верхний регистр, верхнего регистра - в нижний регистр\n'
           's.format()                # форматирование строки. Для форматирования в строке должны быть последовательности {}, а в аргументах format нужно записать вставленные соответственно в эти конструкции последовательности\n'
           '                            Example: \'Name: {}, Score: {}\'.format(\'Admin\', 100) --> \'Name: Admin, Score: 100\'\n'
           '                            это не единственный способ форматирования строк. Все способы описаныи в str_format\n'
           's.maketrans(x, y, z)      # создание словаря для воззможности совершения метода translate. Словварь составляется из строк x и y (элементы берутся попарно: первый из x заменится на первый из y...)\n'
           '                            можно указать третью строку. Эта строка символов, которые нужно удалить\n'
           's.translate(table)        # замена символов строки по словарю table, который получится при вызове метода maketrans\n'
           '\n'
           'Экранированные последовательности описаны в shielded_sequences\n'
           '\n'
           'можно делать многострочные блоки текста. Для этого строку нужно заключать в тройные апострофы (или кавычки)\n')


def dict():
    return ('dict\n'
            '\n'
            'dict - это отображение, где некоторым ключам соответствуют значения\n'
            'dict - изменяемый тип данных\n'
            'Ключ и значение могут быть любыми типами данных\n'
            'Ключ и значение записывается через :\n'
            'Example: {1: \'a\', 2: \'b\'}\n'
            'СОЗДАНИЕ СЛОВАРЕЙ\n'
            'd = {}                                             # пустой словарь\n'
            'd = {1: \'1\', 2: \'2\'}                           # просто записать пары через :\n'
            'd = dict(name = \'user\', password = \'123456aa\') # создание с именнованными аргументами\n'
            'd = dict(zip(keys, values))                        # можно создать словарь, используя список ключей и список значений, с помощью zip (берёт попарно элементы списков)\n'
            'd = {i: str(i) for i in range(3, 5)                # можно создать словарь при помощи генератора\n'
            'd = dict.fromkeys(keylist, value)}                 # создание при помощи fromkeys. Каждому элементу списка ключей присваивается значение value (по умолчанию - None)\n'
            'd = dict([(1, \'1\'), (2, \'2\')])                 # создание словаря из списка кортежей, где первый элемент - ключ, а второй - значение\n'
            '\n'
            'Значение по ключу можно получить так: d[1]\n'
            'Создание новой пары: d[3] = \'c\'\n'
            'Т.к. dict - изменяемый тип, можно записать так: d[1] += \'a\'\n'
            'Проверить, есть ли ключ в словаре можно так: k in d\n'
            '\n'
            'ФУНКЦИИ:\n'
            'len(d) # возвращение кол-ва пар в словаре\n'
            '\n'
            'МЕТОДЫ\n'
            'd.keys()         # получение списка ключей в словаре\n'
            'd.get(key, v)    # возвращение значения по ключу key. Если ключа нет в словаре, будет возвращён None (или то, что указано в аргументе v)\n'
            'list(d.keys())   # возвращение списка ключей словаря\n'
            'list(d.values()) # возвращение списка значений словаря\n'
            'list(d.items())  # возвращение списка из кортежей (первый элемент - ключ, второй - значение)\n'
            'd.copy()         # копия словаря\n'
            'd.update(d1)     # слияние словарей. Если в d1 есть ключи d, то значения одинаковых ключей в d заменятся на значения ключей d1\n'
            'd.pop(k)         # удаление и возвращение ключа k (удаляется пара)\n'
            'd.popitem()      # удаление ключа (неизвестно, какого - словари неупорядочены) и возвращение пары: (ключ, значение)\n'
            'd.clear()        # очищение всего словаря\n')


def tuple():
    return ('tuple\n'
            '\n'
            'tuple (кортеж) - это тип последовательностей, очень похож на тип list\n'
            'Example: (1, 2, \'a\', {1, 3})'
            'tuple отличается от list тем, что является неизменяемым типом\n'
            'Срезы и индексы у tuple, такие же, как у list\n'
            'tuple так же поддерживает конкатенацию и повторение, как и list\n'
            'НО: нельзя записать t[0] = 1 (т.к. это неизменяемый тип)\n'
            'ФУНКЦИИ:\n'
            'Такие же, как у списков\n'
            'МЕТОДЫ:\n'
            't.index() и t.count() # такие же, как у списков\n')


def transfer_from_a_sys_to_10_sys():
    return ('для перевода целых чисел можно использовать int(str, base)\n'
            'str - число в a с.с. (можно использовать как с указаниями с.с. (0b, 0o, 0x), так и без них)\n'
            'base - указание с.с. (целое число)\n')


def numbers():
    return ('Числа\n'
            '\n'
            'Числа в Python:\n'
            '    int     # целые\n'
            '    float   # вещественные (дробные)\n'
            '    complex # комплексные\n'
            '    также есть числовые типы из модулей и строковое представление некоторых чисел (например, числа в других с.с.)\n'
            'ОПЕРАЦИИ:\n'
            'представленные операции в основном используются с целыми числами\n'
            '   МАТЕМАТИЧЕСКИЕ ОПЕРАЦИИ:\n'
            '   a + b  # сложение двух чисел\n'
            '   a - b  # разность двух чисел\n'
            '   a * b  # произведение двух чисел\n'
            '   a / b  # частное двух чисел\n'
            '   a // b # целая часть от деления a на b (округление вниз)\n'
            '   a % b  # остаток деления a на b\n'
            '   a ** b # a в стпени b (корень из a равен a ** 0.5)\n'
            '   -a     # отрицание числа\n'
            '   СРАВНЕНИЕ:\n'
            '   можно сравнивать целые и дробные числа'
            '   a == b     # True при равенстве двух чисел (можно сравнивать целые и дробные числа, если дробная часть равна 0)\n'
            '   a is b     # True при идентичности двух чисел (нельзя сравнивать дробные числа с целыми)\n'
            '   a is not b # True при неидентичности двух чисел\n'
            '   a != b     # True при неравенстве двух чисел\n'
            '   a > b      # True, если первое число больше/меньше второго\n'
            '   a < b\n'
            '   a >= b     # True, если первое число больше/меньше или равно второго\n'
            '   a <= b\n'
            '   Python поддерживает цепочки сравнений. Example: a < b <= c\n'
            '   БИТОВЫЕ ОПЕРАЦИИ:\n'
            '   работают с целыми числами\n'
            '   оба числа переводятся в двоичную систему, после этого попарно производятся операции над битами. Полученный результат перводится в десятичную систему\n'
            '   a | b  # дезъюнкция (ИЛИ)\n'
            '   a ^ b  # исключающее ИЛИ (XOR)\n'
            '   a & b  # конъюнкция (И)\n'
            '   ~a     # инверсия (НЕ)\n'
            '   a >> b # сдвиг битов (двигаются единицы)\n'
            '   a << b\n'
            'ПРИОРИТЕТ МАТЕМАТИЧЕСКИХ ОПЕРАЦИЙ:\n'
            'чем ниже в таблице, тем первее выполняется\n'
            '+\n'
            '-\n'
            '*\n'
            '%\n'
            '/, //\n'
            '**\n'
            '\n'
            'в Python есть модуль с вещественными числами фиксированной точности: decimal\n'
            'в Python есть модуль с рациональными числами: fraction\n'
            'можно перевести вещественное число в кортеж из числителя и знаменателя, использую метод as_integer_ratio\n')
           

def set():
    return ('set\n'
            '\n'
            'set (множество) - коллекция неизменяемых элементов. Каждый элемент в множестве может встречаться только один раз\n'
            'множество может состоять из элементов любого типа\n'
            'в множестве нет порядка!!! Поэтому у него нет индексов, срезов\n'
            '\n'
            'set записывается, как последовательность в фигурных скобках. Не стоит путать со словарями.\n'
            'создавать пустое множество нужно так: set(). {} - это пустой словарь\n'
            'Example: {1, 2, 3, 4}\n'
            '         set([1, 2, 3, 4]) --> {1, 2, 3, 4}\n'
            '         set(\'abc\') --> {\'a\', \'b\', \'c\'}\n'
            'для создания множеств можно использовать генераторы, как в списках. Нужно только заменить квадратные скобки на фигурные\n'
            'len(x) - длина множества\n'
            '\n'
            'ОПЕРАЦИИ:\n'
            'x & y  # персечение множеств\n'
            'x | y  # объединение множеств\n'
            'x - y  # разница множеств\n'
            'x ^ y  # симметричная разница множеств\n'
            'x <= y # проверка, является ли множество родительским/дочерним\n'
            'x >= y\n'
            'x == y # проверка на равенство множеств (нельзя проверить равенство множеств, используя is)\n'
            '\n'
            'МЕТОДЫ:\n'
            'методы, в отличие от операторов, позволяют принимать любые итерируемые объекты\n'
            'x.add(item)                      # добавление элемента item во множество\n'
            'x.remove(item)                   # удаление элемента item из множества. Если элемента нет, то будет выведена ошибка\n'
            'x.discard(item)                  # удаление элемента item из множества. Если элемента нет, то ничего не произойдёт\n'
            'x.pop()                          # удаление и возвращение элемента множества. Неизвестно, какой элемент будет удалён, т.к. у множества нет порядка\n'
            'x.clear()                        # удаление всех элементов множества\n'
            'x.union(y, z)                    # объединение множеств x, y, z (равно |)\n'
            'x.intersection(y)                # пересечение множеств x, y (равно &)\n'
            'x.difference(y)                  # разница множеств x и y (множество элементов, которые есть в x, но нет в y) (равно -)\n'
            'x.symmetric_difference()         # симметричная разница множеств (множество элементов множеств, которые не являются общими) (равно ^)\n'
            'x.issubset(y)                    # проверка, является ли x дочерним множеством множества y (True/False) (равно <=)\n'
            'x.issuperset(y)                  # проверка, является ли x родительским множеством множества y (True/False) (равно >=)\n'
            'x.copy()                         # копия множества\n'
            'x.isdisjoint(y)                  # проверка, есть ли у множеств x и y общие элементы (если есть - False, если нет - True)\n'
            'x.difference_update(y)           # то же самое, что difference, но множеству x присваивается полученное множество\n'
            'x.symmetric_difference_update(y) # то же самое, что symmetric_difference, но множеству x присваивается полученное множество\n'
            'x.update(y)                      # то же самое, что union, но множеству x присваивается полученное множество\n'
            'x.intersection_update(y)         # то же самое, что intersection, но множеству x присваивается полученное множество\n'
            '\n'
            'существует ещё один тип множеств - frozenset\n'
            'единственное отличие frozenset от set - frozenset является неизменяемым типом данных\n'
            'frozenset поддерживает методы set, кроме всех методов с update, clear, add, remove, discard, pop\n')


def equality_of_elements():
    return('Равенство элементов\n'
           'проверить равенство двух элементов можно несколькими способами:\n'
           '    ==\n'
           '    is\n'
           '. . .\n'
           'применение этих способов различно\n'
           '== проверяет равенство значений переменных\n'
           'Example:\n'
           'a = 3\n'
           'b = 3\n'
           'a == b --> True\n'
           '\n'
           'is проверяет идентичность переменных (переменные должны относиться к одному объекту)\n'
           'Example:\n'
           'a = 3\n'
           'b = 3\n'
           'a is b --> False\n'
           'но:\n'
           'a = 3\n'
           'b = a\n'
           'a is b --> True\n'
           '\n'
           'Ссылки и копии объектов\n'
           'a = 3\n'
           'b = 3\n'
           'в этом примере переменные относятся к разным объектам. Следовательно, изменение одной переменной не приведёт к изменению второй\n'
           'a = 3\n'
           'b = a\n'
           'в этом примере переменные относятся к одному объекту, но при изменении одной переменной вторая не изменится, т.к. изменится и её объект\n'
           'a = [1, 2, 3]\n'
           'b = a\n'
           'а в этом примере, если мы изменим список a (добавим элемент, удалим, отсортируем методом sort...), то список b тоже изменится, т.к. изменится только часть объекта, а сам объект не изменится.\n'
           '\n'
           'проблема изменения сразу двух переменных будет возникать, если мы будем изменять только часть одной переменной. С числами такого не будет.\n'
           'чтобы избегать такую проблему, можно использовать ссылки\n'
           'копия списков, строк - срез s[:]\n'
           'также у списков, множеств, строк есть метод copy\n'
           'также можно пользоваться модулем copy\n')


def shielded_sequences():
    return ('Экранированные последовательности\n'
            '\n'
            '\\\\         # символ обратного слеша (остаётся один символ)\n'
            '\\\'         # апостороф (остаётся \')\n'
            '\\\"         # кавычки (остаётся \")\n'
            '\\a         # звонок\n'
            '\\b         # забой (удаление элемента перед символом забоя)\n'
            '\\f         # перевод формата\n'
            '\\n         # перевод строки\n'
            '\\r         # возврат каретки (с этого символа начнётся печать строки). Если знак стоит в конце, то будет напечатана вся строка\n'
            '\\v         # вертикальная табуляция\n'
            '\\t         # горизонтальная табуляция\n'
            '\\xnn       # символ с шестнадцетиричным кодом nn\n'
            '\\nnn       # символ с восьмеричным кодом nnn\n'
            '\\0         # символ Null\n'
            '\\N{id}     # идентификатор ID базы данных Юникода (получение символа по названию)\n'
            '\\unnnn     # 16-битный символ Юникода в шестнадцетеричном представлении (nnnn - код)\n'
            '\\Unnnnnnnn # 32-битный символ Юникода в шестнадцатеричном представлении (nnnnnnnn - код)\n'
            'в других строках с обратным слешем слеш сохраняется, строка не является экранированной последовательностью\n'
            'подавлять экранирование можно, поставив букву r перед строкой\n')


def str_format():
    return ('Форматирование строк\n'
            '\n'
            'Есть два основных способа форматирования строк: выражения форматирования и метод форматирования\n'
            '\n'
            'ВЫРАЖЕНИЯ ФОРМАТИРОВАНИЯ\n'
            'В строке ставятся спецификаторы, начинающиеся с % (вместо спецификаторов будет что-то вставляться). Слева от строки ставится оператор %, после которого пишется кортеж из тех элементов, которые мы хотм вставить\n'
            'Спецификаторы (ставятся после % в строке):\n'
            's # строка (если вставляемый объект не является строкой, то будет выполнена функция str(x))\n'
            'r # строка, но используется функция repr, а не str (если будет введена строка, то она будет вставлена вместе с кавычками)\n'
            'c # символ (строчный символ или цифра)\n'
            'd # целое число. Если будет введено вещественное число, то дробная часть будет усечена\n'
            'i # то же самое, что d\n'
            'u # то же самое, что d\n'
            'o # воьмеричное целое число (лучше вводить с 0o). Если введено не воьмеричное число, то оно перводится в воьмеричное\n'
            'x # шестнадцетиричное целое число (лучше вводить с 0x). Буквы возвращаются в нижнем регистре. Если введено не шестнадцетиричное число, то оно переводится в шестнадцетиричное\n'
            'X # то же самое, что x, но буквы возвращаются в верхнем регистре\n'
            'e # число в экспоненциальноной форме. Если введено не десятичное число, то оно переводится в десятичное. Буквы возвращаются в нижнем регистре\n'
            'E # то же самое, что e , но буквы возвращаются в верхнем регистре\n'
            'f # вещественное число в десятичном представлении (6 знаков после запятой). Если введено не десятичное число, то оно переводится в десятичное\n'
            'F # то же самое, что f\n'
            'g # вещественное число в десятичном представлении или в экспоненциальной форме (буквы в нижнем регистре)\n'
            'G # то же самое, что g, но буквы в верхнем регистре\n'
            'Examples:\n'
            '\'Number %d\' % 9 --> Number 9\n'
            '\'Number %s or %c\' % (\'nine\', \'9\') --> Number nine or 9\n'
            '\'E: %e\' % (12.34) --> E: 1.234000e+01\n'
            '\'0x %x\' % 0x1234a5b --> 0x 1234a5b\n'
            '\n'
            'Но выражения форматирования могут состоять не только из % и буквы\n'
            '%[(name)][flags][width][.precision]code\n'
            '(name)     # ключ словаря\n'
            'flags      # некоторые функции: + (знак числа), - (признак выравнивания), 0 (наличие ведущих нулей)\n'
            'width      # требуемая длина вставляемого объекта\n'
            '.precision # кол-во знаков после запятой в вещественном числе\n'
            'code       # тип объекта (буква из вышеописанной таблицы)\n'
            '\n'
            'width и precision могут принимать значение *, тогда во входных данных перед объектом должно указываться число, соответствующее значению параметра\n'
            'Example: \'%-*.2f\' % (6, 12.34567899999999) --> 12.35\n'
            '\n'
            'Можно вставлять значения из словаря по ключу, указанному в (name)\n'
            'Example: \'Print %(y)s or %(n)s\' % {\'y\': \'yes\', \'n\': \'no\'} --> Print yes or no\n'
            'можно получить словарь из всех переменных программы (описанных до вызова функции) функцией vars()\n'
            '\n'
            'МЕТОД ФОРМАТИРОВАНИЯ\n'
            'метод форматирования осуществляяется при помощи метода строки format\n'
            'в строке должны содержаться конструкции {}\n'
            'вставляемые объекты пишутся в аргументах метода format\n'
            'Example: \'Print {} or {}\'.format(\'yes\', \'no\') --> Print yes or no\n'
            '\n'
            'Полный синтакис метода форматирования: {fieldname!conversionflag:formatspec}\n'
            'fieldname      # порядковый номер элемента в аргументах format или имя именованного аргумента, после чего идёт необязательное имя атрибута .name или индекс аргумента\n'
            'conversionflag # может быть равен r (repr), s (str), a (ascii). Применение функции к объекту\n'
            'formatspec     # синтаксис formatspec описан ниже\n'
            '\n'
            '[[fill]align][sign][#][0][width][.precision][typecode]\n'
            'fill       # символ, которым будет заполняться лишние места (если длина строки больше длины объекта)\n'
            'align      # выравнивание. < (по левому краю), > (по правому краю), ^ (по центру), = (дополнение между знаком числа и числом)\n'
            'sign       # знак числа. Может быть равен + и -\n'
            'width      # требуемая длина вставляемого элемента\n'
            '.precision # кол-во знаков после запятой в вещественном числе\n'
            'typecode   # тип объекта (то же самое, что у выражений форматирования, но здесь есть b (для двоичных чисел), нет i и u)\n'
            'Example: \'Print {[0]:-=+{}.2f}\'.format([4.444], 10) --> Print +-----4.44\n'
            'в аргументах format так же может быть словарь. Тогда в fieldname должен быть указан ключ словаря\n'
            'также перед typecode можно поставить знак \',\'. Тогда в числе тройки цифр будут разбиваться запятой\n')


def files():
    return('Работа с файлами\n'
           '\n'
           'Открываются файлы функцией open\n'
           '\n'
           'f = open(\'file_name\', operator) - синтаксис открытия файлов\n'
           'file_name # название файла (с расширением). Если переменная среды PYTHON_PATH не прописана до указанного файла, то нужно прописывать в file_name полный путь до файла\n'
           '            при прописывании пути к файлу могут получится экранированные последовательности. Чтобы убрать их,Ж нужно поставить букву r перед строкой, содержащей путь к файлу\n'
           'operator  # буква, символ (или сочетание букв и символов), указывает на действие с файлом и тип данных файла\n'
           '\n'
           'Возможные значения operator описаны ниже\n'
           'r   # чтение файла. Можно не указывать - стоит по умолчанию\n'
           'w   # запись в файла. Файл переписывается (предыдущее содержимое стирается). Если файла нет, то он будет создан\n'
           'a   # дозапись файла. Предыдущее содержимое не стирается. Новые данные записываются после предыдущих. Если файла нет, то он будет создан\n'
           'r+  # чтение и запись файла\n'
           'w+  # чтение и запись файла. Если файла нет, то он будет создан\n'
           'a+  # дозапись и чтение файла\n'
           'rb  # чтение байтовых строк\n'
           'rb+ # чтение и запись байтовых строк\n'
           'wb  # запись байтовых строк\n'
           'wb+ # чтение и запись байтовых строк. Если файла нет, то он будет создан\n'
           '\n'
           'ЧТЕНИЕ ФАЙЛОВ\n'
           'f.read()          # чтение файла в одну строку (создаётся строка из всех строк файла)\n'
           'f.readlines(size) # чтение всех строк файла сразу (создаётся список из всех строк). size - кол-во байтов, которое нужно прочитать (отсчёт с начала файла)\n'
           'f.readline()      # чтение строки файла (если записать несколько readline, то строки будут читаться по порядку)\n'
           '\n'
           'ЗАПИСЬ В ФАЙЛ\n'
           'f.write()         # запись строки в файл\n'
           'f.writelines()    # запись списка строк в файл (можно записать и строку - эквиваленто write)\n'
           '\n'
           'ПРОЧИЕ МЕТОДЫ:\n'
           'f.close()    # закрытие файла и выталкивание выходных буферов на диск (то же самое происходит при окончании программы)\n'
           'f.flush()    # выталкивание выходных буферов на диск (файл не закрывается)\n'
           'f.seek(n, o) # сдвиг позиции для следующей операции на n байтов от начала файла (если o равен 0), от текущей позиции (если o равен 1), от конца файла (если o равен 2)\n'
           'f.seekable() # проверка на возможность сдвига позиции в файле (не все типы файлов поддерживают сдвиг позиции) (True/False)\n'
           'f.writable() # проверка, можно ли совершать запись в файл (зависит от режима открытия файла) (True/False)\n'
           'f.readable() # проверка, можно ли читать файл (зависит от режима открытия файла) (True/False)\n'
           'f.tell()     # возвращает текущую позицию в файле (кол-во байт от начала файла)\n'
           'f.name       # возвращает имя файла (с путём (если он был указан при открытии))\n'
           'f.encoding   # возвращает кодировку файла\n'
           'f.mode       # возвращает режим открытия файла\n'
           'f.closed     # проверка, закрыт ли файл (True/False)\n'
           '\n'
           'Удобно читать файл, используя итератор файлов:\n'
           'for line in f:\n'
           '    print(line.strip())\n'
           '\n'
           'можно использовать метод __next__. Он делает то же самое, что и readline, но при окончании файла он выдаст ошибку StopIteration (readline выдаст пустую строку)\n'
           '\n'
           'в файлах хранятся строки, а не объекты. Чтобы получить объект из строки, можно использовать функцию eval (делает код из строки)\n'
           '\n'
           'проще записывать в файл данные, используя параметр file в print. Example: print(\'No\', file=open(r\'C:\\User\\No.txt\', \'w\'))\n'
           '\n'
           'чтобы не заниматься преобразованием объектов в строки (в файлы можно записывать только строки, объекты - нельзя) и наоборот, можно автоматизировать это модулем pickle\n'
           'pickle.dump(object, file) # запись любого объекта в файл\n'
           'Example:\n'
           'import pickle\n'
           'a = 4\n'
           'f = open(r\'C:\\Click\\No.txt\', \'wb\')\n'
           'pickle.dump(a, f)\n'
           'f.close()\n'
           '\n'
           'pickle записывает байты, поэтому файл может выглядеть странно\n'
           '\n'
           'чтобы обратно получить данные из файла можно воспользоваться pickle.load()\n'
           'Example:\n'
           'import pickle\n'
           'f = open(r\'C:\\Click\\No.txt\', \'rb\')\n'
           'e = pickle.load(f)\n'
           'f.close()\n'
           '\n'
           'pickle загрузит данные из файла и преобразует их в нужный тип\n')


def bool():
    return ('bool\n'
            '\n'
            'тип bool - это логический тип (истина/ложь)\n'
            'Истина - True, ложь - False\n'
            '\n'
            'можно проверить истинна ли переменная так:\n'
            'if n:\n'
            '   s += 1\n'
            'ложь:\n'
            'if not n:\n'
            '   s -= 1\n'
            '\n'
            'можно проверять истинность сразу нескольких выражений при помощи and и or\n'
            'and и or возвращают объекты, а не True и False\n'
            '\n'
            'x or y\n'
            'будет возвращён левый операнд, если он истинный. Иначе будет возвращён правый операнд\n'
            '\n'
            'x and y\n'
            'будет возвращён левый операнд, если он ложный. Иначе будет возвращён правый операнд\n'
            '\n'
            'но истинными и ложными могут быть не только перменные типа bool\n'
            '\n'
            '[]  # False\n'
            '{}  # False\n'
            '\'\'  # False\n'
            '()  # False\n'
            '0   # False\n'
            '0.0 # False\n'
            '\n'
            '[1]  # True\n'
            '{1}  # True\n'
            '\'s\'  # True\n'
            '(0,) # True\n'
            '1    # True\n'
            '1.23 # True\n')


def bytes():
    return ('bytes\n'
            '\n'
            'bytes - это разновидность типа str, имеет те же методы и функции\n'
            'выглядит строка байтов так: b\'abc\'\n'
            'но на самом деле строка байтов - это список чисел (если взять один элемент строки (a[i]), то это будет число)\n'
            'если сделать список, словарь, множество из объекта bytes, то там тоже будут числа\n'
            'эти числа - это порядковые номера символов в таблице кодировки (в которой дан объект типа bytes)\n'
            '\n'
            'перевести из str в bytes можно при помощи метода строки encode\n'
            'b = s.encode(кодировка)\n'
            '\n'
            'обратный перевод:\n'
            's = b.decode(кодировка)\n'
            '\n'
            'байтовые строки записываются в файлы с прибавлением к режиму открытия файлов буквы b\n'
            '\n'
            'bytes - неизменяемый тип данных!\n')


def bytearray():
    return ('bytearray\n'
            '\n'
            'bytearray очнь похож на тип bytes, но имеет неоторые отличия\n'
            '\n'
            'bytearray нельзя ппросто представить. Для представления его нужно перевести в list\n'
            'тогда получится список из чисел (значение чисел описано в разделе bytes)\n'
            '\n'
            'отличие bytearray от bytes - bytearray - изменяемый тип данных\n'
            'поэтому bytearray имеет методы pop, remove, append (эти методы описаны в методах типа list)\n')


def exceptions():
    return ('Обработка исключений\n'
            '\n'
            'в программе могут происходить ошибки. Их можно перехватывать и делать какие-то действия при обнаружении ошибки\n'
            '\n'
            'для этого используется конструкция try/except/else/finally\n'
            'Синтаксис:\n'
            '\n'
            'try:\n'
            '   код, в которм ищется ошибка\n'
            'except имя ошибки:\n'
            '   действие, если мы наши ошибку\n'
            'else:\n'
            '   действие, если мы не нашли ошибку\n'
            'finally:\n'
            '   код, который выполнится в любом случае\n'
            '\n'
            'else и finally можно не писать\n'
            'у ошибок есть своя иерархия. Будут перехватываться все дочерние ошибки\n'
            'если нужно перехватить все ошибки, то нужно написать except Exception\n')


def assignment():
    return ('Присваивание\n'
            '\n'
            'присваивание создаёт ссылку на объект (переменную)\n'
            '\n'
            'a = 4           # обычное приваивание\n'
            'a, b = \'a\', \'b\' # присваивание кортежей. Первый элемент справа присваивается первому элементу слева и т.д. (позиционное присваивание)\n'
            '[a, b] = 1, 2   # присваивание списков. Первый элемент справа присваивается первому элементу слева и т.д. (позиционное присваивание)\n'
            'также можно присваивать кортеж списку и наоборот\n'
            'a, b, c = \'abc\' # обобщённое присваивание последовательностей. Первой переменной присваивается первый элемент последовательности и т.д.\n'
            'a, *b = [1, 2, 3] # операция распаковывания последовательностей\n'
            'a = b = 3         # групповое присваивание одного значения\n'
            's += 1            # комбинированная инструкция присваивания (эквивалентно s = s + 1)\n'
            '\n'
            'РАСПАКОВЫВАНИЕ ПОСЛЕДОВАТЕЛЬНОСТЕЙ\n'
            'a, *b = [1, 2, 3]\n'
            'переменной a присваивается первый элемент последовательности, а переменной b всё оставшееся, т.е  a = 1, b = [2, 3]\n'
            '\n'
            'нельзя слева написать только переменную со звёздочкой. Обязательно должны быть переменные до этой переменной\n'
            'если вся последовательность уже присвоена переменным до переменной со звёздочкой, то этой переменной будет присвоена пустая последовательность\n'
            '\n'
            'ПРИСВАИВАНИЕ ПОСЛЕДОВАТЕЛЬНОСТЕЙ\n'
            'a, b = \'ab\'\n'
            'переменной a будет присвоен первый элемент последовательности, переменной b - второй\n'
            '\n'
            'можно присвсваивать вложенные последовательности\n'
            '(a, b), c = (\'ab\', \'c\')\n'
            'a равно \'a\', b равно \'b\', c равно \'c\'\n'
            '\n'
            'КОБМИНИРОВАННЫЕ КОНСТРУКЦИИ ПРИСВАИВАНИЯ\n'
            'комбинорованная конструкция s -= 2 равна s = s - 2\n'
            'для каждого оператора есть комбинированная конструкция присваивания\n'
            'x += y\n'
            'x -= y\n'
            'x /= y\n'
            'x *= y\n'
            'x %= y\n'
            'x //= y\n'
            'x &= y\n'
            'x ^= y\n'
            'x |= y\n'
            'x <<= y\n'
            'x >>= y\n'
            'x **= y\n'
            '\n'
            'Но есть некоторые различия у комбинированной конструкции присваивания и обычным присваиванием списков\n'
            '\n'
            'l = [1, 2]\n'
            'm = l\n'
            'l = l + [3]\n'
            '\n'
            'в этом примере m не изменится\n'
            '\n'
            'l = [1, 2]\n'
            'm = l\n'
            'l += [3]\n'
            '\n'
            'а в этом изменится\n')


def variables_names():
    return ('Именование переменных\n'
            '\n'
            'есть определённые правила именования переменных\n'
            '\n'
            '1. Имена переменных должны начинаться с символа подчёркивания или буквы. Дальше могут идти буквы, цифры и символы подчёркивания. Другие символы запрещены\n'
            '2. Регистр букв переменных имеет значение. a и A - разные переменные\n'
            '3. Нельзя использовать зарезервированные слова, как имена пересенных\n'
            'Зарезервированные слова:\n'
            'False    class      finally   is         return\n'
            'None     continue   for       lambda     try\n'
            'True     def        from      nonlocal   while\n'
            'and      del        global    not        with\n'
            'as       elif       if        or         yield\n'
            'assert   else       import    pass\n'
            'break    except     in        raise\n')


def NoneType ():
    return ('None\n'
            '\n'
            'None - это тип данных, который особо ничего не обозначает\n'
            'у None нет методов, нет индивидуальных функций\n'
            '\n'
            'None - это значение, которое возвращают методы и функции, ничего не возвращают\n'
            'Example: x = l.sort() --> x = None\n')


def Print():
    return ('Операция print\n'
            '\n'
            'Операция print предназначена для вывода данных программы\n'
            'Имеет такой синтаксис:\n'
            '\n'
            'print([object][, sep=][, end=][, file=])\n'
            'object # то, что нужно вывести (объектов может быть несколько)\n'
            'sep    # что будет между объектами (по умолчанию \' \')\n'
            'end    # что будет в конце вывода (по умолчанию \'\\n\')\n'
            'file   # куда будут выведены данные (сюда можно передать объекты, напоминающие файлы или объекты файлов) (по умолчанию sys.stdout)\n'
            '\n'
            'print - это более удобный и более функциональный эквивалент sys.stdout.write()\n'
            'перенаправление текста в файл в sys.stdout:\n'
            'import sys\n'
            'sys.stdout = open(\'file.txt\', \'w\')\n'
            'print(x)\n'
            '\n'
            'все print пишут текст в sys.stdout, а sys.stdout мы уже напрвили в файл\n'
            'поэтому все print после перенаправления будут писать текст в файл\n')


def If():
    return ('Условный оператор if/elif/else\n'
            '\n'
            'В языке Python есть только один условный оператор\n'
            'Синтакис:\n'
            '\n'
            'if условие:\n'
            '   код\n'
            'elif условие:\n'
            '   код\n'
            'else:\n'
            '   код\n'
            '\n'
            'if проверяет условие, и, если оно выполняется, то запускается код\n'
            'elif проверяет условие и выполняет код, если не выполнилось условие в if (или в предыдущем elif). В условном операторе может быть несколько elif\n'
            'elif эквивалентен else:\n'
            '                      if условие:\n'
            '                              код\n'
            'else выпольняет код если не выполнилось условие if или elif\n'
            'else и elif могут опускаться\n'
            'если вам нужно проверить условие, но ничего не сделать при его выполнении, можно написать вместо кода слово pass\n'
            '\n'
            'Examples:\n'
            'if 1:\n'
            '   print(\'True\')\n'
            '\n'
            'if x == 1:\n'
            '   print(\'Yes\')\n'
            'else:\n'
            '   print(\'No\')\n'
            '\n'
            'if a == \'Hi\':\n'
            '   if s == 1:\n'
            '       l.append(1)\n'
            '   else:\n'
            '       pass\n'
            '   print(\'Hi\')\n'
            'elif a == \'Bye\':\n'
            '   s = 0\n'
            '   print(\'Goodbye\')\n'
            'else:\n'
            '   print(\'What?\')\n'
            '\n'
            'фактически if проверяет истинно ли выражение или нет\n'
            '\n'
            'для написания условий можно использовать and и or\n'
            'выражение будет истинно, если оба выражения (слева и справа от and) истинны\n'
            'выражение будет истинно, если хотя бы одно выражение (справа и слева от or) истинно\n'
            'если в условии несколько or и and, то сначала будут проверены все or, а потом все and\n'
            '\n'
            'ОПЕРАТОР IF В ОДНУ СТРОКУ\n'
            'a = a1 if x else a2\n'
            'a станет равно a1, если выполнится условие x, иначе a станет равно a2\n'
            'в операторе в одну строку нельзя использовать elif и вложенные условия\n'
            '\n'
            'это же можно записать по-другому\n'
            'a = [a2, a1][x]\n'
            'если x == True, то a будет элемент списка с индексом 1 (True == 1), иначе будет присвоен элемент с индексом 0 (False == 0)\n'
            '\n'
            'ВЫБОР ОДНОГО ИЗ МНОЖЕСТВА\n'
            'проверить, что объект равен одному из множества можно так:\n'
            'if a == a1:\n'
            '   s = 0\n'
            'elif a == a2:\n'
            '   s = 1\n'
            'else:\n'
            '   s = None\n'
            '\n'
            'или так (нужно найти непустой элемент во множестве пустых):\n'
            'a = a1 or a2 or None\n'
            '\n'
            'таким же способом можно записать первый метод, используя функции, возвращающие True или False\n'
            'этот метод возможен, т.к. при нахождении непустого элемента проверка закончится (следующие or не будут выполняться)\n')


def While():
    return ('Цикл while\n'
            '\n'
            'цикл while - это цикл с предусловием (сначала проверяется условие. Если оно верно, цикл выполняется)\n'
            'Синтаксис:\n'
            '\n'
            'while условие:\n'
            '   код\n'
            'else:\n'
            '   код\n'
            '\n'
            'блок else является необезательным. Этот блок выполняется, если цикл был завершён не инструкцией break\n'
            '\n'
            'в теле цикла (код, который происходит в цикле) могут быть инструкции break, pass, continue\n'
            'break    # выход из цикла\n'
            'pass     # ничего. Ничего не происходит, используется, когда нужно проверить условие, но не нужно ничего сделать на выполнение условия\n'
            'continue # переход в начало цикла. Всё, что стоит после continue не выполняется\n'
            '\n')


def For():
    return ('Цикл for\n'
            '\n'
            'цикл for - универсальный итератор последовательностей\n'
            'Синтаксис:\n'
            '\n'
            'for переменная in объект:\n'
            '   код\n'
            'else:\n'
            '   код\n'
            '\n'
            'с каждым разом цикл берёт следующий элемент последовательности <объект> и выполняет тело цикла для него\n'
            'Example:\n'
            'a = [1, 2, 3]\n'
            'for i in a:\n'
            '   i += 1\n'
            'print(a) --> a = [2, 3, 4]\n'
            '\n'
            'else выполняется, сели цикл был завершён не инструкцией break\n'
            'в цикле for могут использоваться инструкции break, pass, continue (описаны в While)\n'
            'циклом можно обходить и вложенные последовательности. Поэто можно написать так:\n'
            'c = [(1, 2), (2, 3), (3, 4)]\n'
            'for (a, b) in c:\n'
            '   print(a + b)\n'
            'это же можно записать по-другому:\n'
            'for i in c:\n'
            '   a, b = i\n'
            '   print(a + b)\n'
            '\n'
            'циклом for можно обходить словари\n'
            'a = {1: \'1\', 2: \'2\'}\n'
            'for key in a:\n'
            'print(\'key: {}, value {}\'.format(key, a[key]))\n'
            '\n'
            'раширенное присваивание в цикле:\n'
            'for (a, *b, c) in [(1, 2, 3, 4),(5, 6, 7, 8)]:\n'
            '   print(a, b, c) --> 1 [2, 3] 4\n'
            '                      5 [6, 7] 8\n'
            '\n'
            'циклы могут быть вложенными\n'
            'for i in (1, 2):\n'
            '   for j in (3, 4):\n'
            '       print(i + j, end=\' \') --> 4 5 5 6\n'
            '\n'
            'RANGE В ЦИКЛЕ FOR\n'
            'Удобно использовать тип данных range в качестве <объект>\n'
            '\n'
            'for переменная in range(start, end, step)\n'
            '   код\n'
            '\n'
            'С range можно обходить и последовательности, используя индексы\n'
            'for i in range(5):\n'
            '   print(a[i])\n'
            '\n'
            'ЧТЕНИЕ ФАЙЛОВ В FOR\n'
            'В цикле проще читать файл (посимвольно, побайтно, построчно...)\n'
            '\n'
            'for char in open(\'file.txt\', \'r\').read():  # чтение посимвольно\n'
            '   print(char) \n'
            '\n'
            'for line in open(\'file.txt\', \'r\'):         # чтение построчно\n'
            '   print(line, end=\' \')\n'
            '\n'
            'для обхода сразу нескольких последовательностей можно использовать ыункцию zip\n'
            'функция zip делает кортежи из элементов последовательностей (необязательно двух) с одинаковыми индексами (берутся первые элементы, вторые и т.д.)\n'
            'кортежи перестают создаваться после того, как достигнута длина одной из последовательностей\n'
            'просто так вывести zip нельзя, но можно вывести list от zip\n'
            'c = zip([1, 2], [3, 4])\n'
            'for (a, b) in c:\n'
            '   print(a + b, end=\' \') --> 4 6 \n'
            '\n'
            'во время обхода последовательности бывает нужно хранить и индексы элементов\n'
            'для этого есть функция enumerate\n'
            'функция enumerate делает из последовательности кортежи (индекс, элемент)\n'
            'получать новый кортеж можно функцией next(enumerate-объект) или можно обойти объект в цикле\n')


def Range():
    return ('range\n'
            '\n'
            'range - это тип последовательностей. Генерирует последовательности целых чисел\n'
            'Синтаксис:\n'
            '\n'
            'a = range(start, end, step)\n'
            'start # от какого числа будет идти последовательность\n'
            'end   # до какого числа будет идти последовательность (не достигается)\n'
            'step  # с каким шагом будут браться числа (будет браться каждое step-ное число)\n'
            '\n'
            'start и step необязательны\n'
            '\n'
            'просто так вывести range нельзя, но можно вывести list от range\n'
            '\n'
            'ФУНКЦИИ\n'
            'такие же, как у list\n'
            'некоторые функции делают list из range\n'
            'МЕТОДЫ\n'
            'index и count (описаны в list)\n')


def iterators():
    return('Итераторы\n'
           '\n'
           'итерируемые объекты - это объекты, котрые поддерживают итерацию (последовательности и объекты, котрые многократно воспроизводят по одному результату  при момощи интструметнов выполнения итераций\n'
           '\n'
           'ИТЕРАТОРЫ ФАЙЛОВ\n'
           'readline\n'
           'метод readline каждый раз возвращает следующую строку файла. Если файл закончился, будет выведена пустая строка\n'
           '\n'
           '__next__\n'
           'метод __next__ делает то же самое, что readline, но при окончании файла будет выведена ошибка StopIteration\n'
           '\n'
           'next\n'
           'next - это функция\n'
           'то же самое, что __next__\n'
           '\n'
           'for\n'
           'можно пройти по строкам файла в цикле\n'
           'for line in f:\n'
           '    print(line, end=\' \')\n'                                                                                                                                                                                                                                                                                 
           '\n'
           'ВЫПОЛНЕНИЕ ИТЕРАЦИЙ ВРУЧНУЮ:\n'
           'можно сделать итератор из многих типов данных при помоши функции iter\n'
           'Example:\n'
           'a = [1, 2]\n'
           'b = iter(a)\n'
           'print(b.__next__) --> 1\n'
           'print(next(b)) --> 2\n'
           '\n'
           'ИТЕРАТОР СЛОВАРЕЙ\n'
           'у словарей есть итератор. При его помощи можно пройти по ключам словаря\n'
           'Example:\n'
           'd = {1: \'a\', 2: \'b\'}\n'
           'for key in d:\n'
           '    print(key, d[key], end=\', \', sep=\' - \') --> 1 - a  2 - b  \n'
           '\n'
           'функции zip, map и filter возвращают итераторы\n'
           'функция map применяет одну и ту же функцию для всех элементов итерируемого объекта\n'
           'map(func, object)\n'
           '\n'
           'функция zip делает кортеж из первых элементов итерируемых объектов, кортеж их вторых элементов и т.д.\n'
           'zip(object1, object2, object3)\n'
           '\n'
           'filter возвращает только те элементы итерируемого объекта, для которых функция возвращает True\n'
           'filter(func, object)\n'
           '\n'
           'все эти функции возвращают итераторы, для того, чтобы вывести полученные объекты полностью, нужно преобразовать в другой тип данных\n')


def list_generators():
    return ('Генераторы списков\n'
            '\n'
            'создавать списики можно в цикле, проверяя какие-то условия. Записать это в одну строку можно при помощи генератора списка\n'
            'Синтаксис:\n'
            '\n'
            '[expression for variable in object if condition]\n'
            'expression # выражение, из которого будет получен элемент, который будет добавлен в список\n'
            'variable   # переменная цикла\n'
            'object     # итерируемый объект\n'
            'condition  # условие. Если условие ложно, то объект не будет добавлен в список\n'
            '\n'
            'Example:\n'
            'l = [i + 1 for i in (1, 2, 3, 0) if i != 0] --> l = [2, 3, 4]\n'
            '\n'
            'в генераторе может быть несколько циклов. Тогда последующие циклы будут вложены в предыдущие\n'
            '\n'
            'Example:\n'
            'l = [i + j for i in (1, 2, 3) for j in (1, 2, 3)] --> l = [2, 3, 4, 3, 4, 5, 4, 5, 6]\n')


def documentation():
    return ('Документация\n'
            '\n'
            'Прочитать документацию можно, вызвав функцию help(). В скобках может находится имя объекта, метод объекта и т.д.\n'
            '\n'
            'Можно вызвать функцию dir от объекта. Тогда будет выведен список всех методов объекта\n'
            '\n'
            'Можно найти документацию по модулям на PyDoc (файл Module Docs)\n'
            '\n'
            'СОЗДАНИЕ СОБСТВЕННОЙ ДОКУМЕНТАЦИИ\n'
            'можно писать комментирующие строки (начинаются с #)\n'
            '\n'
            'также можно писать документацию для всей программы, классов, функций\n'
            'такая документация пищется в тройных кавычках (апострофах)\n'
            'Example:\n'
            '\'\'\'doc of program\'\'\'\n'
            'def func():\n'
            '   \'\'\'doc of func\'\'\'\n'
            '\n'
            'такую документацию можно прочитать при помощи метода __doc__\n'
            'Example:\n'
            'print(func.__doc__) --> doc\n'
            'документацию программы можно прочитать, импортировав программу в другую программу и применив метод к названию программы\n'
            '\n'
            '__doc__ можно использовать не только для создания своей документации. Этим методом можно вызвать встроенную документацию объектов\n')


def functions():
    return ('Функции\n'
            '\n'
            'Функции помогают разбивать программу на отдельные этапы\n'
            'Синтакис:\n'
            '\n'
            'def name(args):\n'
            '   code\n'
            '\n'
            'name - название функции (нельзя использовать зарезервированные имена)\n'
            'если, например, назвать функцию print, то при вызове функции print, будет исполняться эта функция, а не встроенная\n'
            '\n'
            'args - аргументы функции. В скобках указываются имена аргументов (эти имена будут использоваться в функции, вводить объекты можно с любыми именами)\n'
            '\n'
            'вызов функции производится так:\n'
            'name(args)\n'
            '\n'
            'можно хранить информацию в атрибутах функции\n'
            'создание атрибута:\n'
            'a.atrr_name = object\n'
            'вызов атрибута:\n'
            'print(a.attr)\n'
            '\n'
            'возвратить какие-то данные из функции можно при помощи return\n'
            'return не печатает данные только возвращает\n'
            'Example:\n'
            'def a(i):\n'
            '   return i * 2\n'
            'x = a(3)\n'
            'print(x) --> 6\n'
            '\n'
            'для создания функций можно использовать условный оператор\n'
            'Example:\n'
            'if x:\n'
            '   def a(n):\n'
            '       return n * 2\n'
            'else:\n'
            '   def a(n):\n'
            '       return n * 3\n'
            'создание функций похоже на присваивание\n'
            '\n'
            '-ОБЛАСТИ ВИДИМОСТИ-\n'
            'переменная, определённая в функции видна только в функции. Её нельзя вызвать в остальном коде\n'
            'если в функции и остальном коде будут одинаково названные переменные, то они не будут конфликтовать. Они находятся в разных областях видимости\n'
            '\n'
            'если присваивание переменной происходит в функции, то эта переменная является локальной для этой функции\n'
            'если присваивание переменной происходит в объемлющей функции (вложенные функции), то переменная является нелокальной для вложенной функции\n'
            'если присваивание переменной происходит вне всех инструкций функций, то эта переменной является глобальной\n'
            '\n'
            'ВСТРОЕННАЯ ОБЛАСТЬ ВИДИМОСТИ\n'
            'переменные встроенной области видимости находятся в модуле builtins\n'
            'его можно импортировать и посмотреть имена переменных, вызвав dir от builtins\n'
            '\n'
            'ИНСТРУКЦИЯ GLOBAL\n'
            'инстркция global позволяет делать из локальных переменных глобальные\n'
            'Example:\n'
            'x = 88     # глобальная переменная\n'
            'def f():\n'
            '   global x\n'
            '   x = 99\n'
            'f()\n'
            'print(x) --> 99\n'
            '\n'
            'глобальную переменную можно увидеть в функции, но её нельзя изменять без global\n'
            '\n'
            'ВЛОЖЕННЫЕ ФУНКЦИИ\n'
            'Example:\n'
            'def f1():\n'
            '   x = 88\n'
            '   def f2():\n'
            '       print(x)\n'
            '   f2()\n'
            'f1() --> 88\n'
            '\n'
            'во вложенной функции можно увидеть переменную в объемлющей функции, но нельзя её изменить\n'
            '\n'
            'во вложенных функциях можно возвращать функции\n'
            'Examples:\n'
            'def f1():\n'
            '   x = 88\n'
            '   def f2():\n'
            '       print(x)\n'
            '   return f2\n'
            'a = f1()\n'
            'a() --> 88\n'
            '\n'
            'def m(n):\n'
            '   def a(x):\n'
            '       return x ** n\n'
            '   return a\n'
            'f = m(2)\n'
            'print(f(3)) --> 9\n'
            'g = m(3)\n'
            'print(g(2)) --> 8\n'
            '\n'
            'во вложенную функцию можно передавать аргументы из объемлющей функции\n'
            'Example:\n'
            'def f1():\n'
            '   x = 88\n'
            '   def f2(x=x):\n'
            '       print(x)\n'
            '   f2()\n'
            'f1() --> 88\n'
            '\n'
            'можно не вкладывать функции, а вызывать одну функцию внутри другой\n'
            'Example:\n'
            'def f1():\n'
            '   x = 88\n'
            '   f2(x)\n'
            'def f2():\n'
            '   print(x)\n'
            'f1() --> 88\n'
            '\n'
            'вкладывать можно и lambda-выражения\n'
            'Examples:\n'
            'def f():\n'
            '   x = 4\n'
            '   a = (lambda n: x ** n)\n'
            '   return a\n'
            'x = f()\n'
            'print(x(2)) --> 16\n'
            '\n'
            'def f():\n'
            '   x = 3\n'
            '   a = (lambda n, x=x: x ** n)\n'
            '   return a\n'
            'b = f()\n'
            'print(b(2)) --> 9\n'
            '\n'
            'есть одна проблема с вложением функции в цикл объемлющей функции\n'
            'def f():\n'
            '    a = []\n'
            '    for i in range(5):\n'
            '        a.append(lambda: print(i))\n'
            '    return a\n'
            's = f()\n'
            's[0](); s[2]() --> 4\n'
            '                   4\n'
            '\n'
            'все вызовы lambda будут выводить одно и то же число - 4, т.к. берётся последнее значение i\n'
            'чтобы избежать этого, нужно указывать i во вложенной функции\n'
            'def f():\n'
            '    a = []\n'
            '    for i in range(5):\n'
            '        a.append(lambda i=i: print(i))\n'
            '    return a\n'
            's = f()\n'
            's[0](); s[2]() --> 0\n'
            '                   2\n'
            '\n'
            'ИНСТРУКЦИЯ NONLOCAL\n'
            'инструкция nonlocal позволяет не только видеть переменный объемлющей функции во вложенной, но и изменять их\n'
            'Example:\n'
            'def a():\n'
            '    x = 2\n'
            '    def b():\n'
            '        nonlocal x\n'
            '        x += 1\n'
            '        print(x)\n'
            '    return b()\n'
            'a()() --> 3\n'
            '\n'
            'инструкцию nonlocal нельзя использовать для переменных, не описанных раньше\n')


def arguments():
    return ('Аргументы\n'
            '\n'
            'Аргументы - это ссылки на объекты, которые передаются в функции\n'
            'Переменной в функции присваивается соответствующее значение аргумента\n'
            'аргументы, передаваемые в функцию, пишутся в скобках после имени функции\n'
            'Example:\n'
            'def f(a):\n'
            '    a += 1\n'
            '    return a\n'
            'b = f(3)\n'
            'print(b) --> 4\n'
            '\n'
            'если передавать изменяемые аргументы, то при изменении аргумента в функции может изменяться объект в программе\n'
            'Example:\n'
            'def f(a):\n'
            '    a[0] = 3\n'
            'l = [1, 2]\n'
            'f(l)\n'
            'print(l) --> [3, 2]\n'
            '\n'
            'чтобы избежать изменения, нужно делать копии объектов\n'
            'Example:\n'
            'def f(a):\n'
            '    a = a[:]\n'
            '    a[0] = 3\n'
            'l = [1, 2]\n'
            'f(l)\n'
            'print(l) --> [1, 2]\n'
            '\n'
            'РЕЖИМЫ СОПОСТАВЛЕНИЯ АРГУМЕНТОВ\n'
            'func(value)             # обычный аргумент, сопоставление производится по позиции\n'
            'Example:\n'
            'def f(a):\n'
            '    print(a)\n'
            'b = 3\n'
            'f(b) --> 3\n'
            '\n'
            'func(name=value)        # именованный аргумент, сопоставление производится по указанному имени\n'
            'Example:\n'
            'def f(a):\n'
            '    a += 1\n'
            '    print(a)\n'
            'l = 4\n'
            'f(a=l) --> 4\n'
            '\n'
            'func(*sequence)         # объекты в последовательности передаются, как отдельные позиционные аргументы\n'
            'Example:'
            'def f(a, b, c):\n'
            '    print(a, b, c)\n'
            'f(*(1, 2, [1, 2])) --> 1 2 [1, 2]\n'
            '\n'
            'func(**dict)            # все пары ключ/значение передаются как отдельные именованные аргументы\n'
            'Example:\n'
            'def f(a, b, c)\n'
            '    print(a, b, c)\n'
            'd = {\'a\': 2, \'b\': 3, \'c\': [1]}\n'
            'f(**d) --> 1 2 [1]\n'
            '\n'
            'def func(name)          # обычный аргумент, сопоставление производится по позиции или имени\n'
            '\n'
            'def func(name=value)    # значение по умолчанию (на случай если аргумент не передаётся функции)\n'
            '\n'
            'def func(*name)         # объединение аргументов в кортеж\n'
            '\n'
            'def func(**name)        # объединение именованных аргументов в словарь\n'
            '\n'
            'def func(*args, name)   # аргументы после *args и * могут быть только именованными\n'
            'def func(*, name=value)\n'
            '\n'
            'ЗНАЧЕНИЯ ПО УМОЛЧАНИЮ\n'
            'для аргументов можно описать значениение по умолчанию (на случай елси эти аргументы не передаются функции)\n'
            'Example:\n'
            'def f(a, b=1, c=2):\n'
            '    print(a, b, c)\n'
            '\n'
            'здесь описаны значения по умолчанию для b и c. Аргумент a обязателен\n'
            '\n'
            'если вызвать функцию не только с аргументом a, то значения по умолчанию будут заменены на введённые значения\n'
            'Examples:\n'
            'f(1) --> 1 1 2\n'
            '\n'
            'f(1, 2) --> 1 2 2\n'
            '\n'
            'f(0, 0, 0) --> 0 0 0\n'
            '\n'
            'f(0, c=3) --> 0 1 3\n'
            '\n'
            'ПРОИЗВОЛЬНОЕ ЧИСЛО АРГУМЕНТОВ\n'
            'для описания произвольного числа аргументов используются расширения * и **\n'
            '\n'
            'def f(*args):\n'
            '    print(args)\n'
            '\n'
            'Examples:\n'
            'f() --> ()\n'
            'f(1, 2) --> (1, 2)\n'
            '\n'
            'def f(**args):\n'
            '    print(args):\n'
            '\n'
            'Examples:\n'
            'f() --> {}\n'
            'f(a=1, b=2) --> {\'a\': 1, \'b\': 2}\n'
            '\n'
            'Можно кобминировать разные виды аргументов:\n'
            'def f(a, *pargs, **kargs):\n'
            '    print(a, pargs, kargs)\n'
            'f(1, 2, 3, x=1, y=2) --> 1 (2, 3) {\'x\': 1, \'y\': 2}\n'
            '\n'
            'def f(a, *b, c=6, **d):\n'
            '   print(a, b, c, d)\n'
            'f(1, *(2, 3), c=7, **dict(x=4, y=5)) --> 1 (2, 3), 7 {\'x\': 4, \'y\': 5}\n'
            '\n'
            'Информация о функции:\n'
            'func.__name__             # имя функции\n'
            'func.__annotations__      # аннотации функции\n'
            'func.__code__.co_varnames # имена переменных в функции\n'
            'func.__code__.co_argcount # кол-во аргументов в функции\n'
            '\n'
            'АННОТАЦИИ\n'
            'аннотациями можно указывать тип аргументов, тип вывода\n'
            '\n'
            'def f(a: 5, b: (1, 10) = 5, c: int = 4) -> int:\n'
            '    return a + b + c\n'
            '\n'
            'здесь всем аргументам и выводы присвоены аннотации\n'
            'можно ввести аргументы только тех типов, котрые указаны\n'
            'получить словарь аннотация можно в атрибуте __annotations__\n'
            'print(f.__annotations__) --> {\'a\': 5, \'b\': (1, 10), \'c\': <class \'int\'>, \'return\': <class \'int\'>}\n'
            '\n'
            'после аннотации можно писать значения по умолчанию (они написаны для аргументов b и c)\n')


def recursion():
    return('Рекурсия\n'
           '\n'
           'Рекурсия - это функция, многократно вызывающая саму себя\n'
           '\n'
           'Пример использования рекурсии для нахождения суммы чисел (или конкатенация последовательностей в списке) в одномерном списке:\n'
           'def mysum(l):\n'
           '    if not L:\n'
           '        return 0\n'
           '    else:\n'
           '        return l[0] + mysum(l[1:])\n'
           'a = [1, 2, 3, 4, 5]\n'
           'print(mysum(a)) --> 15\n'
           '\n'
           'для нахождения суммы чисел в многомерном списке:\n'
           'def sumtree(l):\n'
           '    tot = 0\n'
           '    for x in l:\n'
           '        if not isinstance(x, list):\n'
           '            tot += x\n'
           '        else:\n'
           '            sumtree(x)\n'
           '    return tot\n'
           'a = [1, [2, [3, 4], 5], 6, [7, 8]]\n'
           'print(sumtree(a)) --> 36\n'
           '\n'
           'Не следует применять рекурию там, где можно обойтись без неё, потому что может быть переполнение стэка.\n'
           'Можно увеличить дно рекурсии\n'
           'sys.setrecursionlimit(number) - number меньше, чем int в C\n')


def lambda_functions():
    return('lambda-выражения\n'
           '\n'
           'lambda - это анонимные функции (они не емеют названий)\n'
           '\n'
           'Синтаксис:\n'
           'func = lambda: arg1, arg2...: expression\n'
           '\n'
           'arg1, arg2... # аргументы. Можно выставлять значения по умолчанию\n'
           'expression    # однострочное выражение (код, котрый будет выполняться в функции)\n'
           'func          # переменная, котрой будет присвоен объект функции\n'
           '\n'
           'т.к. переменной присвоен объект функции, вызвыть функцию можно так: func(arg1, arg2...)\n'
           '\n'
           'lambda-функции можно вкадывать друг в друга\n'
           'Example:\n'
           'x = (lambda a: lambda b: a * b)\n'
           's = x(2)(3)\n'
           'print(s) --> 6\n'
           '\n'
           'вложенные lambda имеют доступ к переменным в объемлющих lambda\n')


def generators():
    return('Генераторы\n'
           '\n'
           'Генераторы делятся на функции-генераторы и выражения-генераторы\n'
           '\n'
           'ФУНКЦИИ-ГЕНЕРАТОРЫ\n'
           'функции-генераторы - это функции, которые могут возвращать значения и продолжать свою работу с того места, где были приостановлены\n'
           'для этого используется инструкция yield\n'
           '\n'
           'генераторы поддерживают протокол итераций (итераторы описаны в разделе iterators)\n'
           'Example:\n'
           'def g():\n'
           '    for i in range(5):\n'
           '        yield i\n'
           'x = g()\n'
           'print(next(x)) --> 0\n'
           'print(next(x)) --> 1\n'
           'print(next(x)) --> 2\n'
           '\n'
           'yield может быть в составе выражения\n'
           'x = yield i\n'
           'x = (yield i) + 42\n'
           '\n'
           'Example:\n'
           'def gen():\n'
           '    for i in range(10):\n'
           '        x = yield i\n'
           '        print(x)\n'
           'x = gen()'
           '\n'
           'если yield находится в выражении, можно использовать метод send\n'
           'метод send подставляет вместо yield в выражении число, которое передано в качестве аргумента, и переходит к сдедующей итерации\n'
           '\n'
           'чтобы использовать этот метод, нужно сначала запустить итерацию (например, функцией next)\n'
           'next(x)\n'
           'x.send(3) --> 3\n'
           '              1\n'
           'x.send(1) --> 1\n'
           '              2\n'
           '\n'
           'ВЫРАЖЕНИЯ-ГЕНЕРАТОРЫ\n'
           'выражения-генераторы - это то же самое, что генераторы списков, но в круглых скобках\n'
           'эти выражения поддерживают протокол итераций\n'
           '\n'
           'из выражений-генераторов можно сделать генераторы списков, словарей, множеств\n')


def modules():
    return('Модули\n'
           '\n'
           'модули - это файлы, которые можно импортировать в программу\n'
           '\n'
           'импортирование производится при момощи инструкции import\n'
           'Синтаксис:\n'
           'import module1, module2...\n'
           '\n'
           'название модуля пишется без расширения и пути\n'
           '\n'
           'после импортирования в программе можно получить доступ к функциям, переменным, классам... программы\n'
           'функции доступны в виде методов (module.func())\n'
           'переменные доступны в виде атрибутов (module.variable)\n'
           '\n'
           'можно импортировать функции и переменные прямо в программу\n'
           'для этого используется from\n'
           'Синтаксис:\n'
           'from module import object1, object2...\n'
           '\n'
           'теперь можно вызывать объекты модули только по имени (не нужно писать module.)\n'
           '\n'
           'чтобы импортировать все объекты, можно написать from module import *\n'
           '\n'
           'При импортировании происходит три этапа: поиск модуля, компиляция (если необходимо), запуск\n'
           'если модуль был уже загружен, то выполняется только третий пункт\n'
           '\n'
           'Поиск осуществляется в следующем порядке:\n'
           '1. Домашний каталог программы\n'
           '2. Содержимое переменной окружения (настраивается в переменных системы). Также пути в эту перемнную можно добавить, вызвав список sys.path и добавив в него путь - путь хранится только во время работы программы\n'
           '3. Каталоги стандартной библиотеки модулей (идут вместе с компилятором)\n'
           '4. Содержимое файлов с расширением .pht\n'
           '\n'
           'ПОВТОРНАЯ ЗАГРУЗКА МОДУЛЕЙ\n'
           'если делать изменения в модуле во время выполнения программы, то в программе этих изменений не будет (будет использоваться перевая версия модуля)\n'
           'чтобы добавить изменения в модуле в программу, нужно повторно его загрузить\n'
           'для этого используется reload\n'
           '\n'
           'Example:\n'
           '#module.py\n'
           'a = 1\n'
           '\n'
           '#program.py\n'
           'import module\n'
           'from importlib import reload\n'
           'print(module.a) --> 1'
           'a = input()                  # перед вводом изменим module.py. Изменим a на 2\n'
           'reload(module)\n'
           'print(module.a) --> 2'
           '\n'
           'без reload в программе была бы запущена первая версия модуля, и вывелось бы первое значения a (1)\n'
           '\n'
           'ПАКЕТЫ МОДУЛЕЙ\n'
           'помимо модулей, можно импортировать пакеты модулей (папки с модулями)\n'
           '\n'
           'импортирование пакетов можно начинать из папки, к котрой прописана переменная PYTHONPATH\n'
           'записываются пакеты через точку\n'
           'Example:\n'
           'import dir1.dir2.module\n'
           '\n'
           'dir1, dir2 - папки (dir2 находится в dir1)\n'
           'ещё одну условие импортирования пакетов - в каждом каталоге в пути к модулю должен быть файл __init__.py\n'
           'эти файлы будут выполняться при импортировании\n'
           '\n'
           'в __init__ файлах можно прописать, что будет доступно при использовании from\n'
           'для этого нужно прописать в списке __all__ имена субмодулей, которые будут доступны\n'
           '\n'
           'список __all__ в модулях помогает скрыть некоторую информацию при вызове from module import *\n'
           'нужно прописатть в списке __all__ то, что будет передаваться программе (имена объектов)\n'
           'то же самое можно сделать, если ставить перед названиями объектов _\n'
           'такие объекты не будут передаваться\n'
           '\n'
           'ИМПОРТИРОВАНИЕ ПО ОТНОСИТЕЛЬНОМУ ПУТИ\n'
           'импортирование по относительному пути предполагает, что модули будут искаться только в каталоге, где находится импортирующая программа\n'
           '\n'
           'такое импортирование пишется при помощи .\n'
           'Example:\n'
           'from . import module # файл module будт искаться в домашнем каталоге программы\n'
           '\n'
           '. можно писать перед названием пакетов или модулей\n'
           'Example:\n'
           'from .module import a # импортируется переменная из модуля в домашнем каталоге программы\n'
           '\n'
           'точек может быть несколько. Каждая точка поднимает поиск на один уровень выше\n'
           '\n'
           'СМЕШАННЫЕ РЕЖИМЫ ИСПОЛЬЗОВАНИЯ\n'
           'у каждой программы есть атрибут __name__\n'
           'если модуль запущен, как самостоятельная программа, то __name__ равняется \'__main__\'\n'
           'если модуль импортирован, то __name__ равняется имени модуля\n'
           '\n'
           'этот атрибут позволяет запускать модуль, как самостоятельную программу\n'
           'для этого нужно написать:\n'
           'if __name__ == \'__main__\':\n'
           '    code\n'
           '\n'
           'так же можно проверять, запущена ли программа, как модуль\n'
           'if __name__ == \'module_name\':\n'
           '    code\n'
           '\n'
           'если модуль запущен как самостоятельная программа, то можно обрабатывать аргументы командной строки\n'
           'делается это при помощи списка sys.argv\n'
           'первый элемент списка всегда равен названию файла\n'
           'Example:\n'
           '#module.py\n'
           'import sys\n'
           'if __name__ == \'__main__\':\n'
           '    d = map(int, sys.argv[:1])\n'
           '    print(sum(d))'
           'else:\n'
           '    s = -1\n'
           '\n'
           '#cmd\n'
           'C:\\Modules> py module.py 1 23\n'
           '24\n'
           '\n'
           'РАСШИРЕНИЕ AS\n'
           'модули и имена из модулей можно импортировать не под теми именами, которыми они называются\n'
           'это делается с помощью as\n'
           'Example:\n'
           'import module as md # теперь в программе будет md, имени module не существует\n'
           'from module import expression_variable as ex_var\n'
           '\n'
           'то же самое можно сделать по-другому\n'
           'import module\n'
           'md = module\n'
           'del module\n'
           '\n'
           'ИМПОРТИРОВАНИЕ МОДУЛЕЙ ПО ИМЕНИ В ВИДЕ СТРОКИ\n'
           'такое импортирование можно сделать при помощи функции exec\n'
           'эта функция делает код из строки\n'
           'Example:\n'
           'a = \'module\'\n'
           'exec(\'import \' + a)\n'
           '\n'
           'такое импортирование можно сделать по-другому\n'
           's = \'module\'\n'
           'module = __import__(s) # мы получили модуль с именем module\n'
           '\n'
           'ТРАНЗИТИВНАЯ ПЕРЕЗАГРУЗКА МОДУЛЕЙ\n'
           'при перезагрузке модуля будет перезагружен только сам модуль, вложенные модули перезагружены не будут\n'
           'встроенной функции транзитивной перезагрузки нет\n'
           'программа для такой перезагрузки находится в разделе transitive_reload\n')


def transitive_reload():
    return ('Транзитивная перезагрузка модулей\n'
            '\n'
            'информацию о транзитивной перезагрузке можно найти в разделе modules\n'
            'ниже представлен код этой перезагрузки\n'
            '\n'
            'import types\n'
            'from importlib import reload\n'
            'def status(module):\n'
            '    print(\'reloading \' + module.__name__)\n'
            'def transitive_reload(module, visited):\n'
            '    if not module in visited:\n'
            '        status(module)\n'
            '        reload(module)\n'
            '        visited[module] = None\n'
            '        for attrobj in module.__dict__.values():\n'
            '            if type(attrobj) == types.ModuleType:\n'
            '                transitive_reload(attrobj, visited)\n'
            'def reload_all(*args):\n'
            '    visited = {}\n'
            '    for arg in args:\n'
            '        if type(arg) == types.ModuleType:\n'
            '            transitive_reload(arg, visited)\n')


def classes():
    return ('ООП (Объекто-ориентированное программирование)\n'
            '\n'
            'ООП непосредственно связано с созданием классов\n'
            'классы - это объекты со своими пространствами имён, свойствами\n'
            '\n'
            'НАСЛЕДОВАНИЕ КЛАССОВ\n'
            'есть объекты классов, а есть объекты экземпляров классов\n'
            'экземпляры классов наследуют какие-то свойства от классов, а какие-то свойства являются уникальными\n'
            'от одного класса можно создать любое кол-во экземпляров\n'
            'поэтому все экземпляры класса могут быть разными\n'
            '\n'
            'у классов могут быть подклассы\n'
            '\n'
            'порядок наследования свойств класса экземплярами определяется деревом наследования\n'
            'пердположим, что есть класс C2 и класс C3; C1 - подкласс классов C2 и C3; I1, I2 - экземпляры класса C1\n'
            'дерево наследования показано на схеме:\n'
            '------            ------\n'
            '| C2 |            | C3 |\n'
            '| .x |<----  ---->| .w |\n'
            '| .y |    |  |    | .z |\n'
            '------    |  |    ------\n'
            '         ------\n'
            '         | C1 |\n'
            '         | .x |\n'
            '         | .y |\n'
            '         ------\n'
            '-------   ^  ^   -------\n'
            '|  I1 |   |  |   |  I2 |\n'
            '|.name|----  ----|.name|\n'
            '-------          -------\n'
            'дерево наследования показывает, в каком порядке будут искаться атрибуты\n'
            '\n'
            'например, мы запускаем i1.x\n'
            'программа начинает искать .x в дереве наследования\n'
            'сначала атрибут ищется в классе, от которого создан атрибут (C1)\n'
            'мы находим этот атрибут там\n'
            '\n'
            'теперь вызовем i2.w\n'
            'сначала атрибут ищется в классе C1\n'
            'там его нет\n'
            'потом программа будет искать атрибуты в суперклассах (C2, C3)\n'
            'там атрибут ищется в том порядке, в каком порядке суперклассы были указаны в скобках подкласса\n'
            'предположим, что они были указаны так: class C1 (C2, C3)\n'
            'значит, сначала атрибут ищется в C2\n'
            'там его нет\n'
            'атрибут находится в C3\n'
            'если атрибут не найден, возбуждается исключение\n'
            '\n'
            'у I2 и I1 есть атрибуты name, если их вызвать то поиск по дереву осуществляться не будет (эти атрибуты есть у самих экземпляров)\n'
            '\n'
            'создадим такое дерево наследования\n'
            'классы создаются при помощи инструкции class\n'
            '\n'
            'class C2:...\n'
            'class C3:...\n'
            'class C1(c2, C3):...\n'
            'I1 = C1()\n'
            'I2 = C1()\n'
            '\n'
            'в классах пишутся методы при помощи def\n'
            'атрибуты присваиваиваются к экземплярам при помощи аргумента self\n'
            '\n'
            'пример класса:\n'
            'class C1:\n'
            '    def setname(self, who):\n'
            '        self.name = who\n'
            'I1 = C1()\n'
            'I2 = C1()\n'
            'I1.setname(\'John\')\n'
            'I2.setname(\'Jane\')\n'
            'print(I1.name, I2.name) --> John Jane\n'
            '\n'
            'более сложный пример:\n'
            'class C1:\n'
            '    def __init__(self, who):             # __init__ - это встроенное название метода. При создании экземпляра автоматически будет запускаться __init__. Аргументы для него пишутся в скобках\n'
            '        self.name = who\n'
            '    def __add__(self, other):            # перегрузка оператора +. Метод будет запускаться, если экземпляр находится в выражении с +\n'
            '        print(self.name + other)\n'
            'class C2(C1):                            # подкласс класса C1\n'
            '    def __init__(self, who):             # изменение метода __init__ lля подкласса (все методы класса будут доступны для подкласса, некоторые можно изменить)\n'
            '        self.name = \'Professor \' + who\n'
            'i1 = C1(\'mike\')\n'
            'i1.selfname = \'mike1\'                # добавление атрибута экземпляру. Атрибут будет храниться в классе. Другие экземпляры класса имеют доступ к этому атрибуту\n'
            'print(i1.selfname) --> \'mike1\'\n'
            'print(i1.name) --> \'mike\'\n'
            'i1 + \'r\' --> miker\n'
            'i2 = C2(\'Mark\')\n'
            'i2 + \'III\'--> Professor MarkIII\n'
            '\n'
            'если нужно создать новый экземпляр в классе и присвоить ему атрибут, то нужно писать return Class_name(attr). Это будет работать, если в классе есть __init__\n'
            'если в классе нет __init__, то можно написать так: i = Class_name();i.setname(attr);return i\n'
            'подразумевается, что есть метод, который приcваивает экземпляру атрибут\n'
            'Examples:\n'
            'class C1:\n'
            '    def __init__(self, value):\n'
            '        self.name = value\n'
            '    def __add__(self, other):\n'
            '        return C1(self.name + other)\n'
            'i1 = C1(1)\n'
            'i2 = i1 + 2\n'
            'print(i2.name) --> 3\n'
            '\n'
            'class C2:'
            '    def setname(self, value):\n'
            '        self.name = value\n'
            '    def __add__(self, other):\n'
            '        i = C2()\n'
            '        i.setname(self.name + other)\n'
            '        return i\n'
            'i1 = C2()\n'
            'i1.setname(\'Py\')\n'
            'i2 = i1 + \'thon\'\n'
            'print(i2.name) --> Python\n'
            '\n'
            'ПЕРЕГРУЗКА ОПЕРАТОРОВ\n'
            'классы могут перегружать встроенные операторы (будет производиться какое-то действие, если над экземпляром будет производиться встроенная операция)\n'
            'методы классов для перегрзки операторов должны иметь особые встроенные названия (эти названия начинаются и заканчиваются двумя нижними подчёркиваниями (__name__))\n'
            'например:\n'
            '__add__      # действие, если экземпляр находится в выражении с +\n'
            '__sub__      # действие, если экземпляр находится в выражении с -\n'
            '__truediv__  # действие, если экземпляр находится в выражении с /\n'
            '__floordiv__ # действие, если экземпляр находится в выражении с //\n'
            '__mul__      # действие, если экземпляр находится в выражении с *\n'
            '__del__      # действие на удаление объекта (в том числе сборщиком мусора)\n'
            '__str__      # действие, если экземпляр находится в функции str (или методе, функции, которая преобразует в строку, например, print)\n'
            '(то же самое с __bool__, __bytes__, __complex__, __float__, __int__, __iter__, __abs__)\n'
            '\n'
            'у классов есть встроенные атрибуты __dict__(пространство имён класса), __bases__(кортеж суперклассов класса)...\n'
            'у экземпляров есть встроенный атрибут __class__(класс, от которого наследуется экземпляр)\n'
            '\n'
            'методы могут создаваться не в классах\n'
            'Example:\n'
            'def up(self):\n'
            '    return self.n.upper()\n'
            'class C1:\n'
            '    def __init__(self, who):\n'
            '        self.n = who\n'
            'C1.method = up               # присвоение классу метода method\n'
            'x = C1(\'name\')\n'
            'print(up(x)) --> NAME        # функция может работать вне класса\n'
            'print(C1.method(x)) --> NAME # функция может работать, как метод класса\n'
            '\n'
            'классы можно использовать для хранения информации\n'
            'хранения в классах:\n'
            'class Job:\n'
            '    pass\n'
            'Job.name = \'Nick\'\n'
            'Job.job = \'junior-developer\'\n'
            'Job.age = 23\n'
            '\n'
            'хранение в экземплярах:\n'
            'class Job:\n'
            '    pass\n'
            'pers1 = Job()\n'
            'pers2 = Job()\n'
            'pers1.job = \'junior-developer\'\n'
            'pers2.job = \'senior-developer\'\n'
            '\n'
            'или так:\n'
            'class Person:\n'
            '    def __init__ (self, age, name, job)\n'
            '        self.age = age\n'
            '        self.name = name\n'
            '        self.job = job\n'
            '    def info(self):\n'
            '        print(\'Age:  {}\'.format(self.age)\n'
            '              \'Name: {}\'.format(self.name)\n'
            '              \'Job:  {}\'.format(self.job), sep=\'\\n\')\n'
            'pers1 = Person(20, \'Oleg\', teacher)\n'
            'pers2 = Person(56, \'George\', musician)\n'
            '\n'
            'Более сложный пример класса:\n'
            'from classtools import AttrDisplay\n'
            'class Person (AttrDisplay):\n'
            '    """\n'
            '    Создаёт и обрабатывает записи с информацией о людях\n'
            '    """\n'
            '    def __init__(self, name, job=None, pay=0):\n'
            '        self.name = name\n'
            '        self.job = job\n'
            '        self.pay = pay\n'
            '    def lastName(self):\n'
            '        return self.name.split()[-1]\n'
            '    def giveRaise(self, percent):\n'
            '        self.pay = int(self.pay * (1 + percent))\n'
            'class Manager(Person):\n'
            '    """\n'
            '    Версия класса Person, адаптированная в соответствии\n'
            '    со специальными требованиями\n'
            '    """\n'
            '    def __init__(self, name, pay):\n'
            '        Person.__init__(self, name, \'mgr\', pay)\n'
            '    def giveRaise(self, percent, bonus=.10):\n'
            '        Person.giveRaise(self, percent+bonus)\n'
            'if __name__ == \'__main__\':\n'
            '    bob = Person(\'Bob Smith\')\n'
            '    sue = Person(\'Sue Jones\', job=\'dev\', pay=100000)\n'
            '    print(bob.name, bob.pay)\n'
            '    print(sue.name, sue.pay)\n'
            '    print(bob.lastName(), sue.lastName())\n'
            '    sue.giveRaise(.10)\n'
            '    print(sue)\n'
            '    tom = Manager(\'Tom Jones\', 50000)\n'
            '    tom.giveRaise(.10)\n'
            '    print(tom.lastName())\n'
            '    print(tom)\n'
            '    print(\'--All three--\')\n'
            '    for object in (bob, sue, tom):\n'
            '        object.giveRaise(.10)\n'
            '        print(object)\n'
            '\n'
            'в примере использован модуль classtools. Вот этот файл:\n'
            '"""Различные утилиты и инструменты для работы с классами"""\n'
            'class AttrDisplay:\n'
            '    """\n'
            '    Реализует наследуемый метод перегрузки операции вывода, отображающий\n'
            '    имена классов экземпляров и все атрибуты в виде пар имя+значение,\n'
            '    имеющиеся в экземплярах (исключая атрибуты, унаследованных от классов).\n'
            '    Может добавляться в любые классы и способен работать с любыми\n'
            '    экземплярами.\n'
            '    """\n'
            '    def gatherAttrs(self):\n'
            '        attrs = []\n'
            '        for key in sorted(self.__dict__):\n'
            '            attrs.append(\'%s=%s\' % (key, getattr(self, key)))\n'
            '        return \', \'.join(attrs)\n'
            '    def __str__(self):\n'
            '        return \'[%s: %s]\' % (self.__class__.__name__, self.gatherAttrs())\n'
            'if __name__ == \'__main__\':\n'
            '    class TopTest(AttrDisplay):\n'
            '        count = 0\n'
            '        def __init__(self):\n'
            '            self.attr1 = TopTest.count\n'
            '            self.attr2 = TopTest.count + 1\n'
            '            TopTest.count += 2\n'
            '    class SubTest(TopTest):\n'
            '        pass\n'
            '    X, Y = TopTest(), SubTest()\n'
            '    print(X)\n'
            '    print(Y)\n')


a = '1'
print(colored('Help of Python 3\n', 'green'))
print(colored('Это программа-тетрадь о языке Python 3\n'
        'Программа разделена на разделы. Чтобы прочитать документацию по одной теме, напишите её название\n'
        'Чтобы увидеть список всех тем, напишите all\n'
        'Чтобы выйти из программы, напишите exit\n', 'blue'))
while a != 'exit':
    a = input(colored('>>>', 'green'))
    if a == 'exit':
        sys.exit('Завершение работы...')
    else:
        if not no(a):
            print('Такого раздела не существует!')
        else:
            a += '()'
            print(eval(a))


'''list_com = ['all', 'check_for_simplicity', 'transfer_from_10_sys_to_a_sys',
                'data_types', 'list', 'str', 'dict', 'tuple', 'transfer_from_a_sys_to_10_sys', 'numbers', 'set', 'equality_of_elements',
                'shielded_sequences', 'str_format', 'files', 'bool', 'bytes', 'bytearray', 'exceptions', 'assignment',
                'variables_names', 'NoneType', 'Print', 'If', 'While', 'For', 'iterators', 'list_generators', 'documentation',
                'functions', 'arguments', 'recursion', 'lambda_functions', 'generators', 'modules', 'transitive_reload',
                'classes', 'Range']
for i in list_com:
    print(colored(i, 'red'))
    print(eval(i + '()'))
    print('\n\n\n')'''