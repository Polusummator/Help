import sys
from termcolor import colored


def all():
    for i in range(len(list_com)):
        if i != len(list_com) - 1:
            print(list_com[i], end='\n')
        else:
            print(list_com[i])
    return ''


def numbers():
    return ('Числа\n'
            '\n'
            'ЦЕЛЫЕ ЧИСЛА\n'
            '\n'
            'Целые числа в C++ представлены типами:\n'
            'char      (8 бит)\n'
            'short     (16 бит)\n'
            'int       (24 бита)\n'
            'long      (32 бита)\n'
            'long long (64 бита)\n'
            '\n'
            'Размеры типов могут варьироваться в зависимости от системы\n'
            '(максимальные и минимальные значения можно посмотреть в константах заголовочного файла climits)\n'
            'Также можно узнать кол-во байт, выделенных на тип или переменную с помощью sizeof:\n'
            'sizeof(int) для типов\n'
            'sizeof num  для переменных\n'
            '\n'
            'Также существуют unsigned-типы (целочисленные типы без отрицательных чисел). Их верхняя граница в 2 раза больше, чем у обычных типов\n'
            'например:\n'
            'unsigned n1 (тип int)\n'
            'ungigned long long n2\n'
            '\n'
            'СИСТЕМЫ СЧИСЛЕНИЯ:\n'
            'Целочисленные литералы могут хранится в трёх видах:\n'
            '1. Десятеричная с.с.      Обычная запись чисел в десятеричной с.с. Пример: -1, 0, 1323\n'
            '2. Восьмеричная с.с.      Первый символ - 0.                       Пример: 0425, 01\n'
            '3. Шестнадцатеричная с.с. Первый символ - 0, второй - x.           Пример: 0x1234a, 0xABBA\n'
            '\n'
            'Числа в этих с.с. можно выводить с помощью манипуляторов dec, oct и hex в cout:\n'
            'cout << oct; - замена вывода на восьмеричный формат\n'
            'По умолчанию стоит dec\n'
            '\n'
            'СУФФИКСЫ:\n'
            'Константы, наподобие cout << 24;, хранятся по умолчанию в типе int, но это можно изменить добавлением суффиксов (в любом регистре):\n'
            'l  - long\n'
            'll - long long\n'
            'u  - unsigned (можно добавлять к другим суффиксам: ul, ull)\n'
            'Примеры: 220ll, 30UL, 10u\n'
            '\n'
            'CHAR:\n'
            'char обозначает одиночный символ (из таблицы ASCII)\n'
            'Если использовать cin и cout, то при вводе char cin переведёт его в код символа (число), а cout переведёт его обратно в символ\n'
            'В основной программе char хранится в виде числа\n'
            'Если же присвоить значение char переменной типа int (или другого целочисленного типа), то при выводе этой переменной число не будет переводиться в символ\n'
            '\n'
            'Также отобразить одиночный символ можно функцией cout.put()\n'
            '\n'
            'ЭКРАНИРОВАННЫЕ ПОСЛЕДОВАТЕЛЬНОСТИ'
            'Говоря о символах, нельзя не упомянуть управляющие последовательности (экранированные последовательности)\n'
            'В языке C++ они почти полностью совпадают с последовательностями в языке Python\n'
            'Последовательности можно записывать не только в виде символов, но и в числовой записи (в разных с.с.):\n'
            '\\b = \\10 = \\12 = \\0x8\n'
            '\n'
            'CHAR: ДОПОЛНИТЕЛЬНО\n'
            'По умолчанию char не является типом со знаком или беззнаковым типом, но это можно исправить:\n'
            'signed char   - char со знаком\n'
            'unsigned char - char без знака\n'
            '\n'
            'Размер char можно увеличить другими типами:\n'
            '1. wchar_t (16 бит)\n'
            'Перед значением переменной ставится префикс L: wchar_t one = L\'K\'\n'
            'cin и cout не подходят для работы с эти типом, но есть wcin и wcout\n'
            '2. char16_t (16 бит)\n'
            'является беззнаковым\n'
            'Перед значением ставится префикс u\n'
            '3. char32_t (32 бита)\n'
            'является беззнаковым\n'
            'Перед значением ставится префикс U\n'
            '\n'
            'BOOL\n'
            'bool - это логический тип\n'
            'принимает значения true и false\n'
            'true = 1, false = 0, поэтому можно присваивать переменным другич числовых типов\n'
            'Также любая нулевая переменная равна false, ненулевая - true\n'
            '\n'
            'ЧИСЛА С ПЛАВАЮЩЕЙ ТОЧКОЙ\n'
            'Примеры:\n'
            '1.0\n'
            '0.111\n'
            '3.45E6\n'
            '2.52e+8\n'
            '5.11E-1\n'
            '7E5 (=7.0E+05, знак точки можно опускать)\n'
            'Типы с плавающей точкой в C++:\n'
            'float       (32 бита)\n'
            'double      (64 бита)\n'
            'long double (128 бит)\n'
            'Размеры типов могут варьироваться в зависимости от системы\n'
            'Ограничения можно найти в файле cfloat\n'
            '\n'
            'Исключить вывод экспоненциальной записи можно при помощи cout.setf(ios_base::fixed, ios_base::floatfield)\n'
            'также этот метод сделает фиксированное кол-во знаков после точки - 6\n'
            '\n'
            'КОНСТАНТЫ С ПЛАВАЮЩЕЙ ТОЧКОЙ:\n'
            'По умолчанию стоит тип double, но это можно изменить с помощью суффиксов (в любом регистре):\n'
            'f - float\n'
            'l - long double\n'
            'Примеры: 1.23f, 2.44E+28F, 1.111e20l\n')


def const():
    return ('const\n'
            '\n'
            'const - это квалификатор, позволяющий создавать символический константы\n'
            'Пример: const int N = 10;\n'
            'Теперь в программе N будет заменять 10\n'
            '\n'
            'Константа инициализируется в объявлении. Такой пример недопустим:\n'
            'const int N;\n'
            'N = 10;\n')


def arithmetic_operations():
    return ('Арифметические операции\n'
            '\n'
            '+ - сложение\n'
            '- - вычитание\n'
            '* - умножение\n'
            '/ - деление\n'
            '% - остаток от деления\n'
            '\n'
            'C++ поддерживает такие операции, как +=, -=, *=, /=, %=\n'
            'b += 1; - эквивалент b = b + 1;\n'
            '\n'
            'ДЕЛЕНИЕ\n'
            'Поведение операции деления зависит от типов операндов\n'
            '\n'
            'Если операнды одинаковых типов, то и результат будет такого же типа\n'
            '(при целых операндах будет выполнена операция взятия целой части от деления)\n'
            '\n'
            'Если один из операндов имеет тип числа с плавающей точкой, то результат будет числом с плавающей точкой\n')


def type_conversion():
    return ('Преобразования типов\n'
            '\n'
            'C++ автоматически преобразует типы при:\n'
            '1. присваивании значения одной переменной другой переменной другого типа\n'
            '2. комбинировании разных типов в выражениях\n'
            '3. передаче аргументов функциям\n'
            '\n'
            'Пример:\n'
            'short a = 10;\n'
            'int c = a;   // преобразование short -> int\n'
            'int b = 2;\n'
            'a += b;      // преобразование int -> short\n'
            'int d = 3.3; // преобразование double -> int (усечение дробной части)\n'
            '\n'
            'С преобразованием типов могут появляться проблемы\n'
            'Например, значение большого типа передаётся переменной меньшего типа, в которую это значение "не влезает"\n'
            'Также могут быть проблемы с точностью (double -> float)\n'
            '\n'
            'Избежать такие проблемы можно, используя списковую инициализацию\n'
            'Списковая инициализация не допускает "сужения" (значение "не влезает" в тип)\n'
            '\n'
            'Такая инициализация будет работать, если значение - это константа, и это значение "влезает" в тип, или тип переменной, значение которой присваивается, имеет меньшие ограничения\n'
            'Пример:\n'
            'const int a = 260;\n'
            'int d = 10;\n'
            'int b = {a};   // можно\n'
            'short c = {a}; // можно\n'
            'short e = {d}; // нельзя, т.к. e - не константа\n'
            'long f = {d};  // можно, т.к. long > int\n'
            'char g {1000}; // нельзя\n'
            '\n')


def no(a):
    global list_com
    list_com = ['all', 'numbers, const', 'arithmetic_operations', 'type_conversion']
    if a not in list_com:
        return False
    else:
        return True


a = '1'
print(colored('Help of C++\n', 'green'))
print(colored('Это программа-тетрадь о языке C++\n'
              'Программа разделена на разделы. Чтобы прочитать документацию по одной теме, напишите её название\n'
              'Чтобы увидеть список всех тем, напишите all\n'
              'Чтобы выйти из программы, напишите exit\n', 'blue'))
while a != 'exit':
    a = input(colored('>>>', 'green'))
    if a == 'exit':
        sys.exit('Завершение работы...')
    else:
        if not no(a):
            print('Такого раздела не существует!')
        else:
            a += '()'
            print(eval(a))
